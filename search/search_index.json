{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Chaos Engineering Experiments Automation \u00b6 The Chaos Toolkit aims to be the simplest and easiest way to explore building your own Chaos Engineering Experiments. It also aims to define a vendor and technology independent way of specifying Chaos Engineering experiments by providing an Open API . We suggest you start with the tutorials to get a feel for how the Chaos Toolkit can help you automate your Chaos Engineering effort. Once you are ready for your own experiments, have a look at the various driver extensions we support, which ranges from platforms to cloud providers while giving you tools to observe your system as you run your experiments. Finally, if you came to contribute , you are more than welcome. Start with joining the community and read our references like the Open API which specifies the Chaos Toolkit experiment format. Above all, have fun!","title":"Home"},{"location":"#chaos-engineering-experiments-automation","text":"The Chaos Toolkit aims to be the simplest and easiest way to explore building your own Chaos Engineering Experiments. It also aims to define a vendor and technology independent way of specifying Chaos Engineering experiments by providing an Open API . We suggest you start with the tutorials to get a feel for how the Chaos Toolkit can help you automate your Chaos Engineering effort. Once you are ready for your own experiments, have a look at the various driver extensions we support, which ranges from platforms to cloud providers while giving you tools to observe your system as you run your experiments. Finally, if you came to contribute , you are more than welcome. Start with joining the community and read our references like the Open API which specifies the Chaos Toolkit experiment format. Above all, have fun!","title":"Chaos Engineering Experiments Automation"},{"location":"deployment/k8s/operator/","text":"Deploy Chaos Toolkit as a Kubernetes Operator \u00b6 Kubernetes operators are a popular approach to create bespoke controllers of any application on top of the Kubernetes API. The Chaos Toolkit operator listens for experiment declarations and triggers a new Kubernetes pod, running the Chaos Toolkit with the specified experiment. Deploy the operator \u00b6 The operator can be found on the Chaos Toolkit incubator. It is deployed via typical Kubernetes manifests which need to be applied via Kustomize , the native configuration manager. First, download the Kustomize binary : curl -s \"https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh\" | bash For macOS, you can also install it via the Homebrew package manager: brew install kustomize Next, simply run the following: kustomize build manifests/overlays/generic-rbac | kubectl apply -f - This will build the manifests and apply them on your current default cluster. Notice how we use the RBAC variant of the deployment. If you have other requirements (no-RBAC, pod security or network policies), then check the operator\u2019s documentation to deploy the appropriate variant. You can install another variant as follows: kustomize build manifests/overlays/generic[-rbac[-podsec[-netsec]]] | kubectl apply -f - By now, you should have the operator running in the chaostoolkit-crd . kubectl -n chaostoolkit-crd get pods NAME READY STATUS RESTARTS AGE chaostoolkit-crd-7ddb9b78d9-dgxx7 1/1 Running 0 35s The operator deployment created two namespaces, by default: - the chaostoolkit-crd namespace contains the operator pod and Chaos Toolkit experiment definitions - the chaostoolkit-run namespace contains pods running the Chaos Toolkit experiments Run an experiment \u00b6 Now that your controller is listening, you can ask it to schedule a Chaos Toolkit experiment by applying a resource with the following API: apiVersion : chaostoolkit.org/v1 kind : ChaosToolkitExperiment Below is a basic example, assuming a file named basic.yaml : --- apiVersion : v1 kind : ConfigMap metadata : name : chaostoolkit-experiment namespace : chaostoolkit-run data : experiment.json : | { \"version\": \"1.0.0\", \"title\": \"Hello world!\", \"description\": \"Say hello world.\", \"method\": [ { \"type\": \"action\", \"name\": \"say-hello\", \"provider\": { \"type\": \"process\", \"path\": \"echo\", \"arguments\": \"hello\" } } ] } --- apiVersion : chaostoolkit.org/v1 kind : ChaosToolkitExperiment metadata : name : my-chaos-exp namespace : chaostoolkit-crd First, we will use the default namespace in which the Chaos Toolkit will run. Then, we need a config map to pass the experiment to execute. Finally, we simply create a ChaosToolkitExperiment object that the controller picks up and understand as a new experiment to run in its own pod. Apply it as follows: kubectl apply -f basic.yaml Then, you can check the Chaos Toolkit experiment has been registered, and will be scheduled to run as soon as possible: kubectl -n chaostoolkit-crd get ctks Look at the Chaos Toolkit running: kubectl -n chaostoolkit-run get pods The status of the experiment\u2019s run, if it deviated, defines the status if the pod. So, when the experiment does deviate, the pod should have a status set to Error . Otherwise, the status will be Completed . Manage the Chaos Toolkit Experiments \u00b6 List and inspect experiments \u00b6 You can list your experiments as follows: kubectl -n chaostoolkit-crd get chaosexperiments You can describe one experiment as follows: kubectl -n chaostoolkit-crd describe chaosexperiment my-chaos-exp You can also use the short names for the custom resource ctks and ctk . Delete the experiment run\u2019s resources \u00b6 You can delete an experiment and its related resources as follows: kubectl -n chaostoolkit-crd delete ctk my-chaos-exp However, the custom resources (ConfigMap, Secrets, etc.) won\u2019t be deleted. This command only deletes the resources that the operator creates for the experiment to be able to run. To delete all the run\u2019s resources, simply delete the objects as follows: kubectl delete -f basic.yaml Various configurations \u00b6 You may decide to change various aspects of the final pod (such as passing settings as secrets, changing the roles allowed to the pod, even override the entire pod template). Make the operator more verbose \u00b6 By default, the operator logs at INFO level. To enable the DEBUG level, you need to change the operator\u2019s deployment command: In the file manifests/base/common/deployment.yaml : Change: - name : crd image : chaostoolkit/k8scrd:latest imagePullPolicy : Always to: - name : crd image : chaostoolkit/k8scrd:latest imagePullPolicy : Always command : - kopf args : - run - --verbose - --namespace - chaostoolkit-crd - controller.py Then re-deploy using Kustomize. Configure the toolkit with environment variables \u00b6 Chaos Toolkit experiments often expect data to be passed as environment variables of the chaos \u2018s command shell. The operator allows you to specify those values through the config map: --- apiVersion : v1 kind : ConfigMap metadata : name : chaostoolkit-env namespace : chaostoolkit-run data : NAME : \"Jane Doe\" They will be injected into the Chaos Toolkit\u2019s pod as environment variables. You might need several environment config maps for various experiments. You can tell the operator where to find the config map to be loaded as environment variables. We\u2019ll assume you defined another config map named my-chaos-env-vars . You can use it by setting the configMapName in the env block of the pod spec: --- apiVersion : chaostoolkit.org/v1 kind : ChaosToolkitExperiment metadata : name : my-chaos-exp namespace : chaostoolkit-crd spec : pod : env : configMapName : my-chaos-env-vars You can disable loading environment variables into the pod by using the enabled property: --- apiVersion : chaostoolkit.org/v1 kind : ChaosToolkitExperiment metadata : name : my-chaos-exp namespace : chaostoolkit-crd spec : pod : env : enabled : false Plain text environment variables might not be secure enough in some use cases, such as database user name & passord, API keys, tokens, etc. You can define multiple encrypted key-value pairs in a Kubernetes secret and load them as environment variables. To to so, you shall indicate the name of the secret with the secretName property. Assuming you created a generic secret named chaostoolkit-secrets , you can load the values as shown below: --- apiVersion : chaostoolkit.org/v1 kind : ChaosToolkitExperiment metadata : name : my-chaos-exp namespace : chaostoolkit-crd spec : pod : env : secretName : chaostoolkit-secrets All the key-value pairs from the secret will be injected into the Chaos Toolkit\u2019s pod as environment variables. Handle multiple experiment files \u00b6 In the basic example, the name of the config map holding the experiment is the default value chaostoolkit-experiment . Usually, you\u2019ll want a more unique name since you\u2019ll probably run multiple experiments from the chaostoolkit-run namespace. In that case, do it as follows: --- apiVersion : v1 kind : ConfigMap metadata : name : chaostoolkit-experiment-1234 namespace : chaostoolkit-run data : experiment.json : | { \"title\": \"...\", } --- apiVersion : chaostoolkit.org/v1 kind : ChaosToolkitExperiment metadata : name : my-chaos-exp namespace : chaostoolkit-crd spec : pod : experiment : configMapName : chaostoolkit-experiment-1234 You need to define the configMapName in the experiment block of the pod spec. Use the experiment in YAML format \u00b6 If your experiments are encoded using YAML, you can set it as follows: --- apiVersion : v1 kind : ConfigMap metadata : name : chaostoolkit-experiment-1234 namespace : chaostoolkit-run data : experiment.yaml : | --- title: \"...\" --- apiVersion : chaostoolkit.org/v1 kind : ChaosToolkitExperiment metadata : name : my-chaos-exp namespace : chaostoolkit-crd spec : pod : experiment : configMapName : chaostoolkit-experiment-1234 configMapExperimentFileName : experiment.yaml Load the experiment from a URL \u00b6 By default, the experiment is read from a file. But you may store it remotely e.g. GitHub and have it available over HTTP. You might want to load it from its remote URL instead. You can tell the Chaos Toolkit to load it from a remote URL rather than from a local file, as follows: --- apiVersion : v1 kind : ConfigMap metadata : name : chaostoolkit-env namespace : chaostoolkit-run data : EXPERIMENT_URL : \"https://example.com/experiment.json\" --- apiVersion : chaostoolkit.org/v1 kind : ChaosToolkitExperiment metadata : name : my-chaos-exp namespace : chaostoolkit-crd spec : pod : experiment : asFile : false First, you need to pass the EXPERIMENT_URL environment variable. Then, tell the operator not to mount the default experiment volume. To do so, you need to set asFile to false in the experiment block of the pod spec. Run experiments in another namespace \u00b6 You may create the namespace in which the resources will be deployed: --- apiVersion : chaostoolkit.org/v1 kind : ChaosToolkitExperiment metadata : name : my-chaos-exp namespace : chaostoolkit-crd spec : namespace : my-other-namespace You need to defined the namespace value at the spec level. If the namespace already exists, a message will be logged but this will not abort the operation. However, this namespace will be entirely under your responsibility. No network nor pod securities will be managed in your namespace, if the operator was installed with those variants. You\u2019ll need to manage them yourself. Pass Chaos Toolkit settings as a Kubernetes secret \u00b6 Chaos Toolkit reads its settings from a file and you can pass yours by creating a Kubernetes secret named, by default, chaostoolkit-settings . For instance, assuming you have a Chaos Toolkit settings file, you can create a secret from it as follows: kubectl -n chaostoolkit-run \\ create secret generic chaostoolkit-settings \\ --from-file=settings.yaml=./settings.yaml Note, the settings file must be named as settings.yaml within the secret. Reading settings is disabled by default, so you need to let the operator know it should allow it for that run: --- apiVersion : chaostoolkit.org/v1 kind : ChaosToolkitExperiment metadata : name : my-chaos-exp namespace : chaostoolkit-crd spec : namespace : chaostoolkit-run pod : settings : enabled : true You need to set the variable enabled to true in the settings block of the pod spec. The default name for that secret is chaostoolkit-settings but you can change it with the secretName variable, as follows: --- apiVersion : chaostoolkit.org/v1 kind : ChaosToolkitExperiment metadata : name : my-chaos-exp namespace : chaostoolkit-crd spec : namespace : chaostoolkit-run pod : settings : enabled : true secretName : my-super-secret Keep generated resources even when the CRO is deleted \u00b6 When you delete the ChaosToolkitExperiment resource, all the allocated resources are deleted too (pod, service account, \u2026). To prevent this, you may set the keep_resources_on_delete property to true at the spec level. --- apiVersion : chaostoolkit.org/v1 kind : ChaosToolkitExperiment metadata : name : my-chaos-exp namespace : chaostoolkit-crd spec : namespace : chaostoolkit-run keep_resources_on_delete : true In that case, you are responsible to cleanup all resources. Pass your own role to bind to the service account \u00b6 If your cluster has enabled RBAC, then the operator automatically binds a basic role to the service account associated with the chaostoolkit pod. That role allows your experiment to create/get/list/delete other pods in the same namespace. You probably have more specific requirements, here is how to do it: --- apiVersion : chaostoolkit.org/v1 kind : ChaosToolkitExperiment metadata : name : my-chaos-exp namespace : chaostoolkit-crd spec : namespace : chaostoolkit-run role : name : my-role The property name should be set to the name of the role you have created in the namespace which the experiment is executed in. The service account associated with the pod will be bound to that role. Override the default chaos command arguments \u00b6 The pod template executes the chaos run command by default. You may want to extends or change the sub-command to execute when running the pod. You can define the chaos arguments as follow: --- apiVersion : chaostoolkit.org/v1 kind : ChaosToolkitExperiment metadata : name : my-chaos-exp namespace : chaostoolkit-crd spec : namespace : chaostoolkit-run pod : chaosArgs : - --verbose - run - --dry - $(EXPERIMENT_PATH) You need to set the list of arguments in the chaosArgs variable at pod spec level. Label your Chaos Toolkit experiment \u00b6 Experiment labels can be defined in the ChaosToolkitExperiment \u2018s metadata. All labels will be forwarded, if not already defined, in the pod running the experiment. You can define labels as follow: --- apiVersion : chaostoolkit.org/v1 kind : ChaosToolkitExperiment metadata : name : my-chaos-exp namespace : chaostoolkit-crd labels : environment : staging tier : backend target : database These labels can then be used as selectors. Allow network traffic for Chaos Toolkit experiments \u00b6 When the operator is installed with the network security variant, the chaostoolkit pod has limited network access. The pod is, by default, isolated for ingress connectivity and is limited to only DNS lookup & HTTPS for external traffic. To allow the pod for other access, you may create another network policy within the chaostoolkit-run namespace for pods matching the app: chaostoolkit label: --- kind : NetworkPolicy apiVersion : networking.k8s.io/v1 metadata : name : my-custom-network-policy namespace : chaostoolkit-run spec : podSelector : matchLabels : app : chaostoolkit Run periodic and recurring experiments \u00b6 The operator supports crontab schedule for running Chaos Toolkit experiments periodically on a given schedule. To do so, you can define a .spec.schedule section, as follow: --- apiVersion : chaostoolkit.org/v1 kind : ChaosToolkitExperiment metadata : name : my-chaos-exp namespace : chaostoolkit-crd spec : namespace : chaostoolkit-run schedule : kind : cronJob value : \"*/1 * * * *\" This example runs a Chaos Toolkit experiment every minute. You can list your scheduled experiments with the kubernetes\u2019 cronjob resource: kubectl -n chaostoolkit-run get cronjobs Run an experiment with specific extensions \u00b6 The default container image used by the operator is the official Chaos Toollkit image which embeds no Chaos Toolkit extensions . This means that you will likely need to create your bespoke container image. For instance, to install the Chaos Toolkit Kubernetes extension, create a Dockerfile like this: FROM chaostoolkit/chaostoolkit USER root RUN apk update && \\ apk add --virtual build-deps libffi-dev openssl-dev gcc python3-dev \\ musl-dev && \\ pip install --no-cache-dir chaostoolkit-addons chaostoolkit-reliably && \\ apk del build-deps USER 1001 Then create the image with docker: docker build --tag my/chaostoolkit -f ./Dockerfile . or, something such as Podman : podman build --tag my/chaostoolkit -f ./Dockerfile You can check your image contains the installed extensions as follows: docker run --rm -it my/chaostoolkit info extensions Once this image is pushed to any registry you can access, you need to let the operator know it must use it. --- apiVersion : chaostoolkit.org/v1 kind : ChaosToolkitExperiment metadata : name : my-chaos-exp namespace : chaostoolkit-crd spec : namespace : chaostoolkit-run pod : image : my/chaostoolkit Uninstall the operator \u00b6 To uninstall the operator and its own resources, simply run the following command for the overlay that is deployed. kustomize build manifests/overlays/generic[-rbac[-podsec[-netsec]]] | kubectl delete -f -","title":"Operator"},{"location":"deployment/k8s/operator/#deploy-chaos-toolkit-as-a-kubernetes-operator","text":"Kubernetes operators are a popular approach to create bespoke controllers of any application on top of the Kubernetes API. The Chaos Toolkit operator listens for experiment declarations and triggers a new Kubernetes pod, running the Chaos Toolkit with the specified experiment.","title":"Deploy Chaos Toolkit as a Kubernetes Operator"},{"location":"deployment/k8s/operator/#deploy-the-operator","text":"The operator can be found on the Chaos Toolkit incubator. It is deployed via typical Kubernetes manifests which need to be applied via Kustomize , the native configuration manager. First, download the Kustomize binary : curl -s \"https://raw.githubusercontent.com/kubernetes-sigs/kustomize/master/hack/install_kustomize.sh\" | bash For macOS, you can also install it via the Homebrew package manager: brew install kustomize Next, simply run the following: kustomize build manifests/overlays/generic-rbac | kubectl apply -f - This will build the manifests and apply them on your current default cluster. Notice how we use the RBAC variant of the deployment. If you have other requirements (no-RBAC, pod security or network policies), then check the operator\u2019s documentation to deploy the appropriate variant. You can install another variant as follows: kustomize build manifests/overlays/generic[-rbac[-podsec[-netsec]]] | kubectl apply -f - By now, you should have the operator running in the chaostoolkit-crd . kubectl -n chaostoolkit-crd get pods NAME READY STATUS RESTARTS AGE chaostoolkit-crd-7ddb9b78d9-dgxx7 1/1 Running 0 35s The operator deployment created two namespaces, by default: - the chaostoolkit-crd namespace contains the operator pod and Chaos Toolkit experiment definitions - the chaostoolkit-run namespace contains pods running the Chaos Toolkit experiments","title":"Deploy the operator"},{"location":"deployment/k8s/operator/#run-an-experiment","text":"Now that your controller is listening, you can ask it to schedule a Chaos Toolkit experiment by applying a resource with the following API: apiVersion : chaostoolkit.org/v1 kind : ChaosToolkitExperiment Below is a basic example, assuming a file named basic.yaml : --- apiVersion : v1 kind : ConfigMap metadata : name : chaostoolkit-experiment namespace : chaostoolkit-run data : experiment.json : | { \"version\": \"1.0.0\", \"title\": \"Hello world!\", \"description\": \"Say hello world.\", \"method\": [ { \"type\": \"action\", \"name\": \"say-hello\", \"provider\": { \"type\": \"process\", \"path\": \"echo\", \"arguments\": \"hello\" } } ] } --- apiVersion : chaostoolkit.org/v1 kind : ChaosToolkitExperiment metadata : name : my-chaos-exp namespace : chaostoolkit-crd First, we will use the default namespace in which the Chaos Toolkit will run. Then, we need a config map to pass the experiment to execute. Finally, we simply create a ChaosToolkitExperiment object that the controller picks up and understand as a new experiment to run in its own pod. Apply it as follows: kubectl apply -f basic.yaml Then, you can check the Chaos Toolkit experiment has been registered, and will be scheduled to run as soon as possible: kubectl -n chaostoolkit-crd get ctks Look at the Chaos Toolkit running: kubectl -n chaostoolkit-run get pods The status of the experiment\u2019s run, if it deviated, defines the status if the pod. So, when the experiment does deviate, the pod should have a status set to Error . Otherwise, the status will be Completed .","title":"Run an experiment"},{"location":"deployment/k8s/operator/#manage-the-chaos-toolkit-experiments","text":"","title":"Manage the Chaos Toolkit Experiments"},{"location":"deployment/k8s/operator/#list-and-inspect-experiments","text":"You can list your experiments as follows: kubectl -n chaostoolkit-crd get chaosexperiments You can describe one experiment as follows: kubectl -n chaostoolkit-crd describe chaosexperiment my-chaos-exp You can also use the short names for the custom resource ctks and ctk .","title":"List and inspect experiments"},{"location":"deployment/k8s/operator/#delete-the-experiment-runs-resources","text":"You can delete an experiment and its related resources as follows: kubectl -n chaostoolkit-crd delete ctk my-chaos-exp However, the custom resources (ConfigMap, Secrets, etc.) won\u2019t be deleted. This command only deletes the resources that the operator creates for the experiment to be able to run. To delete all the run\u2019s resources, simply delete the objects as follows: kubectl delete -f basic.yaml","title":"Delete the experiment run's resources"},{"location":"deployment/k8s/operator/#various-configurations","text":"You may decide to change various aspects of the final pod (such as passing settings as secrets, changing the roles allowed to the pod, even override the entire pod template).","title":"Various configurations"},{"location":"deployment/k8s/operator/#make-the-operator-more-verbose","text":"By default, the operator logs at INFO level. To enable the DEBUG level, you need to change the operator\u2019s deployment command: In the file manifests/base/common/deployment.yaml : Change: - name : crd image : chaostoolkit/k8scrd:latest imagePullPolicy : Always to: - name : crd image : chaostoolkit/k8scrd:latest imagePullPolicy : Always command : - kopf args : - run - --verbose - --namespace - chaostoolkit-crd - controller.py Then re-deploy using Kustomize.","title":"Make the operator more verbose"},{"location":"deployment/k8s/operator/#configure-the-toolkit-with-environment-variables","text":"Chaos Toolkit experiments often expect data to be passed as environment variables of the chaos \u2018s command shell. The operator allows you to specify those values through the config map: --- apiVersion : v1 kind : ConfigMap metadata : name : chaostoolkit-env namespace : chaostoolkit-run data : NAME : \"Jane Doe\" They will be injected into the Chaos Toolkit\u2019s pod as environment variables. You might need several environment config maps for various experiments. You can tell the operator where to find the config map to be loaded as environment variables. We\u2019ll assume you defined another config map named my-chaos-env-vars . You can use it by setting the configMapName in the env block of the pod spec: --- apiVersion : chaostoolkit.org/v1 kind : ChaosToolkitExperiment metadata : name : my-chaos-exp namespace : chaostoolkit-crd spec : pod : env : configMapName : my-chaos-env-vars You can disable loading environment variables into the pod by using the enabled property: --- apiVersion : chaostoolkit.org/v1 kind : ChaosToolkitExperiment metadata : name : my-chaos-exp namespace : chaostoolkit-crd spec : pod : env : enabled : false Plain text environment variables might not be secure enough in some use cases, such as database user name & passord, API keys, tokens, etc. You can define multiple encrypted key-value pairs in a Kubernetes secret and load them as environment variables. To to so, you shall indicate the name of the secret with the secretName property. Assuming you created a generic secret named chaostoolkit-secrets , you can load the values as shown below: --- apiVersion : chaostoolkit.org/v1 kind : ChaosToolkitExperiment metadata : name : my-chaos-exp namespace : chaostoolkit-crd spec : pod : env : secretName : chaostoolkit-secrets All the key-value pairs from the secret will be injected into the Chaos Toolkit\u2019s pod as environment variables.","title":"Configure the toolkit with environment variables"},{"location":"deployment/k8s/operator/#handle-multiple-experiment-files","text":"In the basic example, the name of the config map holding the experiment is the default value chaostoolkit-experiment . Usually, you\u2019ll want a more unique name since you\u2019ll probably run multiple experiments from the chaostoolkit-run namespace. In that case, do it as follows: --- apiVersion : v1 kind : ConfigMap metadata : name : chaostoolkit-experiment-1234 namespace : chaostoolkit-run data : experiment.json : | { \"title\": \"...\", } --- apiVersion : chaostoolkit.org/v1 kind : ChaosToolkitExperiment metadata : name : my-chaos-exp namespace : chaostoolkit-crd spec : pod : experiment : configMapName : chaostoolkit-experiment-1234 You need to define the configMapName in the experiment block of the pod spec.","title":"Handle multiple experiment files"},{"location":"deployment/k8s/operator/#use-the-experiment-in-yaml-format","text":"If your experiments are encoded using YAML, you can set it as follows: --- apiVersion : v1 kind : ConfigMap metadata : name : chaostoolkit-experiment-1234 namespace : chaostoolkit-run data : experiment.yaml : | --- title: \"...\" --- apiVersion : chaostoolkit.org/v1 kind : ChaosToolkitExperiment metadata : name : my-chaos-exp namespace : chaostoolkit-crd spec : pod : experiment : configMapName : chaostoolkit-experiment-1234 configMapExperimentFileName : experiment.yaml","title":"Use the experiment in YAML format"},{"location":"deployment/k8s/operator/#load-the-experiment-from-a-url","text":"By default, the experiment is read from a file. But you may store it remotely e.g. GitHub and have it available over HTTP. You might want to load it from its remote URL instead. You can tell the Chaos Toolkit to load it from a remote URL rather than from a local file, as follows: --- apiVersion : v1 kind : ConfigMap metadata : name : chaostoolkit-env namespace : chaostoolkit-run data : EXPERIMENT_URL : \"https://example.com/experiment.json\" --- apiVersion : chaostoolkit.org/v1 kind : ChaosToolkitExperiment metadata : name : my-chaos-exp namespace : chaostoolkit-crd spec : pod : experiment : asFile : false First, you need to pass the EXPERIMENT_URL environment variable. Then, tell the operator not to mount the default experiment volume. To do so, you need to set asFile to false in the experiment block of the pod spec.","title":"Load the experiment from a URL"},{"location":"deployment/k8s/operator/#run-experiments-in-another-namespace","text":"You may create the namespace in which the resources will be deployed: --- apiVersion : chaostoolkit.org/v1 kind : ChaosToolkitExperiment metadata : name : my-chaos-exp namespace : chaostoolkit-crd spec : namespace : my-other-namespace You need to defined the namespace value at the spec level. If the namespace already exists, a message will be logged but this will not abort the operation. However, this namespace will be entirely under your responsibility. No network nor pod securities will be managed in your namespace, if the operator was installed with those variants. You\u2019ll need to manage them yourself.","title":"Run experiments in another namespace"},{"location":"deployment/k8s/operator/#pass-chaos-toolkit-settings-as-a-kubernetes-secret","text":"Chaos Toolkit reads its settings from a file and you can pass yours by creating a Kubernetes secret named, by default, chaostoolkit-settings . For instance, assuming you have a Chaos Toolkit settings file, you can create a secret from it as follows: kubectl -n chaostoolkit-run \\ create secret generic chaostoolkit-settings \\ --from-file=settings.yaml=./settings.yaml Note, the settings file must be named as settings.yaml within the secret. Reading settings is disabled by default, so you need to let the operator know it should allow it for that run: --- apiVersion : chaostoolkit.org/v1 kind : ChaosToolkitExperiment metadata : name : my-chaos-exp namespace : chaostoolkit-crd spec : namespace : chaostoolkit-run pod : settings : enabled : true You need to set the variable enabled to true in the settings block of the pod spec. The default name for that secret is chaostoolkit-settings but you can change it with the secretName variable, as follows: --- apiVersion : chaostoolkit.org/v1 kind : ChaosToolkitExperiment metadata : name : my-chaos-exp namespace : chaostoolkit-crd spec : namespace : chaostoolkit-run pod : settings : enabled : true secretName : my-super-secret","title":"Pass Chaos Toolkit settings as a Kubernetes secret"},{"location":"deployment/k8s/operator/#keep-generated-resources-even-when-the-cro-is-deleted","text":"When you delete the ChaosToolkitExperiment resource, all the allocated resources are deleted too (pod, service account, \u2026). To prevent this, you may set the keep_resources_on_delete property to true at the spec level. --- apiVersion : chaostoolkit.org/v1 kind : ChaosToolkitExperiment metadata : name : my-chaos-exp namespace : chaostoolkit-crd spec : namespace : chaostoolkit-run keep_resources_on_delete : true In that case, you are responsible to cleanup all resources.","title":"Keep generated resources even when the CRO is deleted"},{"location":"deployment/k8s/operator/#pass-your-own-role-to-bind-to-the-service-account","text":"If your cluster has enabled RBAC, then the operator automatically binds a basic role to the service account associated with the chaostoolkit pod. That role allows your experiment to create/get/list/delete other pods in the same namespace. You probably have more specific requirements, here is how to do it: --- apiVersion : chaostoolkit.org/v1 kind : ChaosToolkitExperiment metadata : name : my-chaos-exp namespace : chaostoolkit-crd spec : namespace : chaostoolkit-run role : name : my-role The property name should be set to the name of the role you have created in the namespace which the experiment is executed in. The service account associated with the pod will be bound to that role.","title":"Pass your own role to bind to the service account"},{"location":"deployment/k8s/operator/#override-the-default-chaos-command-arguments","text":"The pod template executes the chaos run command by default. You may want to extends or change the sub-command to execute when running the pod. You can define the chaos arguments as follow: --- apiVersion : chaostoolkit.org/v1 kind : ChaosToolkitExperiment metadata : name : my-chaos-exp namespace : chaostoolkit-crd spec : namespace : chaostoolkit-run pod : chaosArgs : - --verbose - run - --dry - $(EXPERIMENT_PATH) You need to set the list of arguments in the chaosArgs variable at pod spec level.","title":"Override the default chaos command arguments"},{"location":"deployment/k8s/operator/#label-your-chaos-toolkit-experiment","text":"Experiment labels can be defined in the ChaosToolkitExperiment \u2018s metadata. All labels will be forwarded, if not already defined, in the pod running the experiment. You can define labels as follow: --- apiVersion : chaostoolkit.org/v1 kind : ChaosToolkitExperiment metadata : name : my-chaos-exp namespace : chaostoolkit-crd labels : environment : staging tier : backend target : database These labels can then be used as selectors.","title":"Label your Chaos Toolkit experiment"},{"location":"deployment/k8s/operator/#allow-network-traffic-for-chaos-toolkit-experiments","text":"When the operator is installed with the network security variant, the chaostoolkit pod has limited network access. The pod is, by default, isolated for ingress connectivity and is limited to only DNS lookup & HTTPS for external traffic. To allow the pod for other access, you may create another network policy within the chaostoolkit-run namespace for pods matching the app: chaostoolkit label: --- kind : NetworkPolicy apiVersion : networking.k8s.io/v1 metadata : name : my-custom-network-policy namespace : chaostoolkit-run spec : podSelector : matchLabels : app : chaostoolkit","title":"Allow network traffic for Chaos Toolkit experiments"},{"location":"deployment/k8s/operator/#run-periodic-and-recurring-experiments","text":"The operator supports crontab schedule for running Chaos Toolkit experiments periodically on a given schedule. To do so, you can define a .spec.schedule section, as follow: --- apiVersion : chaostoolkit.org/v1 kind : ChaosToolkitExperiment metadata : name : my-chaos-exp namespace : chaostoolkit-crd spec : namespace : chaostoolkit-run schedule : kind : cronJob value : \"*/1 * * * *\" This example runs a Chaos Toolkit experiment every minute. You can list your scheduled experiments with the kubernetes\u2019 cronjob resource: kubectl -n chaostoolkit-run get cronjobs","title":"Run periodic and recurring experiments"},{"location":"deployment/k8s/operator/#run-an-experiment-with-specific-extensions","text":"The default container image used by the operator is the official Chaos Toollkit image which embeds no Chaos Toolkit extensions . This means that you will likely need to create your bespoke container image. For instance, to install the Chaos Toolkit Kubernetes extension, create a Dockerfile like this: FROM chaostoolkit/chaostoolkit USER root RUN apk update && \\ apk add --virtual build-deps libffi-dev openssl-dev gcc python3-dev \\ musl-dev && \\ pip install --no-cache-dir chaostoolkit-addons chaostoolkit-reliably && \\ apk del build-deps USER 1001 Then create the image with docker: docker build --tag my/chaostoolkit -f ./Dockerfile . or, something such as Podman : podman build --tag my/chaostoolkit -f ./Dockerfile You can check your image contains the installed extensions as follows: docker run --rm -it my/chaostoolkit info extensions Once this image is pushed to any registry you can access, you need to let the operator know it must use it. --- apiVersion : chaostoolkit.org/v1 kind : ChaosToolkitExperiment metadata : name : my-chaos-exp namespace : chaostoolkit-crd spec : namespace : chaostoolkit-run pod : image : my/chaostoolkit","title":"Run an experiment with specific extensions"},{"location":"deployment/k8s/operator/#uninstall-the-operator","text":"To uninstall the operator and its own resources, simply run the following command for the overlay that is deployed. kustomize build manifests/overlays/generic[-rbac[-podsec[-netsec]]] | kubectl delete -f -","title":"Uninstall the operator"},{"location":"drivers/ansible/","text":"Extension chaosansible \u00b6 Version 0.2.2 Repository https://github.com/Mickael-Roger/chaostoolkit-ansible This project is a collection of actions and probes , gathered as an extension to the Chaos Toolkit . Please NOTE This extension is in the early stages of development. Please feel free to create an issue in case of needed ehancement or misfunctioning. Install \u00b6 This package requires Python 3.5+ To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install -U chaostoolkit-ansible Principles \u00b6 This chaos toolkit driver provides you an easy way to execute probe and/or actions using ansible modules. By using it, you can execute tasks, gather facts, \u2026 on remote systems Usage \u00b6 Basic \u00b6 Probes \u00b6 To use the probes from this package, add the following to your experiment file: In JSON: \"steady-state-hypothesis\" : { \"title\" : \"Tests\" , \"probes\" : [ { \"type\" : \"probe\" , \"name\" : \"test-current-directory\" , \"tolerance\" : { \"type\" : \"jsonpath\" , \"path\" : \"$.*.task\" , \"expect\" : \"/home/me\" }, \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosansible.probes\" , \"func\" : \"chaosansible_probe\" , \"arguments\" : { \"host_list\" : [ \"myserver1\" , \"myserver2\" ], \"facts\" : \"yes\" , \"ansible\" : { \"module\" : \"shell\" , \"args\" : \"pwd\" } } } } ] } In YAML: --- steady-state-hypothesis : title : The current working directory must be /home/me probes : - type : probe name : test-current-directory tolerance : type : jsonpath target : \"$.*.task\" pattern : /home/me provider : type : python module : chaosansible.probes func : chaosansible_probe arguments : host_list : [ \"myserver1\" , \"myserver2\" ] facts : True ansible : module : shell args : pwd That\u2019s it! Probes can be gathered by using the stdout of an ansible task or through the ansible gather_facts module. Each time chaostoolkit-ansible runs, it returns a json that can be used in tolerance (using jsonpath, regex, \u2026) This json is always formatted the same way (Exemple for a two targets host_list): { \"target1\" : { \"fact\" : \" -> JSON result of the ansible gather_facts\" , \"task\" : \" -> String result containing the stdout value of the task result - Empty when ansible task do not return stdout\" }, \"target2\" : { \"fact\" : \"...\" , \"task\" : \"...\" } } Actions \u00b6 To use the actions from this package, add the following to your experiment file: In JSON: \"method\" : [ { \"type\" : \"action\" , \"name\" : \"delete-etc-hosts-file\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosansible.actions\" , \"func\" : \"chaosansible_run\" , \"arguments\" : { \"host_list\" : [ \"server1\" , \"server2\" ], \"become\" : true , \"ansible\" : { \"module\" : \"file\" , \"args\" : { \"path\" : \"/etc/hosts\" , \"state\" : \"absent\" } } } } } ] In YAML: --- method : - type : action name : delete-etc-hosts-file provider : type : python module : chaosansible.actions func : chaosansible_run arguments : host_list : [ \"server1\" , \"server2\" ] become : True ansible : module : file args : path : /etc/hosts state : absent Detailled usage \u00b6 Configuration block \u00b6 The configuration block can be used to specify specific parameters to use. This block can be omit unless you really need to change default ansible parameters to run your exeperiment Configuration variables that can be used by this driver are: ansible_module_path : Path of your ansible library ansible_become_user : Privileged user used when you call privilege escalation (root by default) ansible_ssh_private_key : Your ssh private key used to connect to targets (~/.ssh/id_rsa by default) ansible_user : User on target host used by ansible (current username by default) become_ask_pass : Password to escalate privileged when sudo needs one In case you need to change one/or many default configuration(s), you can specify your value using the configuration block Please feel free to ask, if you need access to other ansible configuration parameters In JSON: \"configuration\" : { \"ansible_ssh_private_key\" : \"/home/me/.ssh/mykey\" } In YAML: configuration : ansible_ssh_private_key : \"/home/me/.ssh/mykey\" Arguments \u00b6 chaosansible_run and chaosansible_probes use arguements (Most argument are classical ansible parameters): Argument Type Required Default value Description host_list Array localhost List of host to use facts bool false Gather_facts become bool false Escalate privilege to run task run_once bool false Run the task only once on one target num_target str all \u201call\u201d or \u201cx\u201d where x is an integer. Run the task to only x target among the host_list. Ideal to create random event ansible dict {} Execute ansible task. Cf ansible dict format. If ansible is not set, no task except ansible gather_facts (if facts set to True) Ansible dict format: Classic ansible task are in the form: name : task name ansible-module-name : module-parameter1 : value1 module-parameter2 : value2 This is translate into chaos experiment file like this: In JSON \"ansible\" : { \"module\" : \"ansible-module-name\" , \"args\" : { \"module-parameter1\" : \"value1\" , \"module-parameter2\" : \"value2\" } } In YAML ansible : module : ansible-module-name args : module-parameter1 : value1 module-parameter2 : value2 Example with the ansible mount module (Umount a filesystem): In JSON \"ansible\" : { \"module\" : \"mount\" , \"args\" : { \"path\" : \"/data\" , \"state\" : \"unmounted\" } } In YAML ansible : module : mount args : path : /data state : unmounted Example of usage \u00b6 Delete /etc/hosts file on 2 random servers out of 5 \u00b6 In JSON \"method\" : [ { \"type\" : \"action\" , \"name\" : \"delete-etc-hosts-file\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosansible.actions\" , \"func\" : \"chaosansible_run\" , \"arguments\" : { \"host_list\" : [ \"server1\" , \"server2\" , \"server3\" , \"server4\" , \"server5\" ], \"num_target\" : \"2\" , \"become\" : true , \"ansible\" : { \"module\" : \"file\" , \"args\" : { \"path\" : \"/etc/hosts\" , \"state\" : \"absent\" } } } } } ] In YAML method : - type : action name : delete-etc-hosts-file provider : type : python module : chaosansible.actions func : chaosansible_run arguments : host_list : [ \"server1\" , \"server2\" , \"server3\" , \"server4\" , \"server5\" ] become : True num_target : \"2\" ansible : module : file args : path : /etc/hosts state : absent Run 100% cpu load on 3 server out of 5 \u00b6 In JSON \"method\" : [ { \"type\" : \"action\" , \"name\" : \"delete-etc-hosts-file\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosansible.actions\" , \"func\" : \"chaosansible_run\" , \"arguments\" : { \"host_list\" : [ \"server1\" , \"server2\" , \"server3\" , \"server4\" , \"server5\" ], \"num_target\" : \"3\" , \"ansible\" : { \"module\" : \"shell\" , \"args\" : { \"cmd\" : \"stress-ng --cpu 0 --cpu-method matrixprod -t 60s\" , } } } } } ] In YAML method : - type : action name : delete-etc-hosts-file provider : type : python module : chaosansible.actions func : chaosansible_run arguments : host_list : [ \"server1\" , \"server2\" , \"server3\" , \"server4\" , \"server5\" ] become : True num_target : \"3\" ansible : module : shell args : cmd : stress-ng --cpu 0 --cpu-method matrixprod -t 60s Contribute \u00b6 If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. The Chaos Toolkit projects require all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR. Develop \u00b6 If you wish to develop on this project, make sure to install the development dependencies. But first, create a virtual environment and then install those dependencies. $ pip install -r requirements-dev.txt -r requirements.txt Then, point your environment to this directory: $ pip install -e . Now, you can edit the files and they will be automatically be seen by your environment, even when running from the chaos command locally. Test \u00b6 To run the tests for the project execute the following: $ pytest Exported Activities \u00b6 actions \u00b6 chaosansible_run \u00b6 Type action Module chaosansible.actions Name chaosansible_run Return None Run a task through ansible and eventually gather facts from host Signature: def chaosansible_run ( host_list : list = 'localhost' , configuration : Dict [ str , Dict [ str , str ]] = None , facts : bool = False , become : bool = False , run_once : bool = False , ansible : dict = {}, num_target : str = 'all' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required host_list list \u201clocalhost\u201d No facts boolean false No become boolean false No run_once boolean false No ansible mapping {} No num_target string \u201call\u201d No Usage: { \"name\" : \"chaosansible-run\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosansible.actions\" , \"func\" : \"chaosansible_run\" } } name : chaosansible-run provider : func : chaosansible_run module : chaosansible.actions type : python type : action probes \u00b6 chaosansible_probe \u00b6 Type probe Module chaosansible.probes Name chaosansible_probe Return None Run a task through ansible and eventually gather facts from host Signature: def chaosansible_probe ( host_list : list = 'localhost' , configuration : Dict [ str , Dict [ str , str ]] = None , facts : bool = False , become : bool = False , run_once : bool = False , ansible : dict = {}, num_target : str = 'all' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required host_list list \u201clocalhost\u201d No facts boolean false No become boolean false No run_once boolean false No ansible mapping {} No num_target string \u201call\u201d No Usage: { \"name\" : \"chaosansible-probe\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosansible.probes\" , \"func\" : \"chaosansible_probe\" } } name : chaosansible-probe provider : func : chaosansible_probe module : chaosansible.probes type : python type : probe","title":"Ansible"},{"location":"drivers/ansible/#extension-chaosansible","text":"Version 0.2.2 Repository https://github.com/Mickael-Roger/chaostoolkit-ansible This project is a collection of actions and probes , gathered as an extension to the Chaos Toolkit . Please NOTE This extension is in the early stages of development. Please feel free to create an issue in case of needed ehancement or misfunctioning.","title":"Extension chaosansible"},{"location":"drivers/ansible/#install","text":"This package requires Python 3.5+ To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install -U chaostoolkit-ansible","title":"Install"},{"location":"drivers/ansible/#principles","text":"This chaos toolkit driver provides you an easy way to execute probe and/or actions using ansible modules. By using it, you can execute tasks, gather facts, \u2026 on remote systems","title":"Principles"},{"location":"drivers/ansible/#usage","text":"","title":"Usage"},{"location":"drivers/ansible/#basic","text":"","title":"Basic"},{"location":"drivers/ansible/#probes","text":"To use the probes from this package, add the following to your experiment file: In JSON: \"steady-state-hypothesis\" : { \"title\" : \"Tests\" , \"probes\" : [ { \"type\" : \"probe\" , \"name\" : \"test-current-directory\" , \"tolerance\" : { \"type\" : \"jsonpath\" , \"path\" : \"$.*.task\" , \"expect\" : \"/home/me\" }, \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosansible.probes\" , \"func\" : \"chaosansible_probe\" , \"arguments\" : { \"host_list\" : [ \"myserver1\" , \"myserver2\" ], \"facts\" : \"yes\" , \"ansible\" : { \"module\" : \"shell\" , \"args\" : \"pwd\" } } } } ] } In YAML: --- steady-state-hypothesis : title : The current working directory must be /home/me probes : - type : probe name : test-current-directory tolerance : type : jsonpath target : \"$.*.task\" pattern : /home/me provider : type : python module : chaosansible.probes func : chaosansible_probe arguments : host_list : [ \"myserver1\" , \"myserver2\" ] facts : True ansible : module : shell args : pwd That\u2019s it! Probes can be gathered by using the stdout of an ansible task or through the ansible gather_facts module. Each time chaostoolkit-ansible runs, it returns a json that can be used in tolerance (using jsonpath, regex, \u2026) This json is always formatted the same way (Exemple for a two targets host_list): { \"target1\" : { \"fact\" : \" -> JSON result of the ansible gather_facts\" , \"task\" : \" -> String result containing the stdout value of the task result - Empty when ansible task do not return stdout\" }, \"target2\" : { \"fact\" : \"...\" , \"task\" : \"...\" } }","title":"Probes"},{"location":"drivers/ansible/#actions","text":"To use the actions from this package, add the following to your experiment file: In JSON: \"method\" : [ { \"type\" : \"action\" , \"name\" : \"delete-etc-hosts-file\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosansible.actions\" , \"func\" : \"chaosansible_run\" , \"arguments\" : { \"host_list\" : [ \"server1\" , \"server2\" ], \"become\" : true , \"ansible\" : { \"module\" : \"file\" , \"args\" : { \"path\" : \"/etc/hosts\" , \"state\" : \"absent\" } } } } } ] In YAML: --- method : - type : action name : delete-etc-hosts-file provider : type : python module : chaosansible.actions func : chaosansible_run arguments : host_list : [ \"server1\" , \"server2\" ] become : True ansible : module : file args : path : /etc/hosts state : absent","title":"Actions"},{"location":"drivers/ansible/#detailled-usage","text":"","title":"Detailled usage"},{"location":"drivers/ansible/#configuration-block","text":"The configuration block can be used to specify specific parameters to use. This block can be omit unless you really need to change default ansible parameters to run your exeperiment Configuration variables that can be used by this driver are: ansible_module_path : Path of your ansible library ansible_become_user : Privileged user used when you call privilege escalation (root by default) ansible_ssh_private_key : Your ssh private key used to connect to targets (~/.ssh/id_rsa by default) ansible_user : User on target host used by ansible (current username by default) become_ask_pass : Password to escalate privileged when sudo needs one In case you need to change one/or many default configuration(s), you can specify your value using the configuration block Please feel free to ask, if you need access to other ansible configuration parameters In JSON: \"configuration\" : { \"ansible_ssh_private_key\" : \"/home/me/.ssh/mykey\" } In YAML: configuration : ansible_ssh_private_key : \"/home/me/.ssh/mykey\"","title":"Configuration block"},{"location":"drivers/ansible/#arguments","text":"chaosansible_run and chaosansible_probes use arguements (Most argument are classical ansible parameters): Argument Type Required Default value Description host_list Array localhost List of host to use facts bool false Gather_facts become bool false Escalate privilege to run task run_once bool false Run the task only once on one target num_target str all \u201call\u201d or \u201cx\u201d where x is an integer. Run the task to only x target among the host_list. Ideal to create random event ansible dict {} Execute ansible task. Cf ansible dict format. If ansible is not set, no task except ansible gather_facts (if facts set to True) Ansible dict format: Classic ansible task are in the form: name : task name ansible-module-name : module-parameter1 : value1 module-parameter2 : value2 This is translate into chaos experiment file like this: In JSON \"ansible\" : { \"module\" : \"ansible-module-name\" , \"args\" : { \"module-parameter1\" : \"value1\" , \"module-parameter2\" : \"value2\" } } In YAML ansible : module : ansible-module-name args : module-parameter1 : value1 module-parameter2 : value2 Example with the ansible mount module (Umount a filesystem): In JSON \"ansible\" : { \"module\" : \"mount\" , \"args\" : { \"path\" : \"/data\" , \"state\" : \"unmounted\" } } In YAML ansible : module : mount args : path : /data state : unmounted","title":"Arguments"},{"location":"drivers/ansible/#example-of-usage","text":"","title":"Example of usage"},{"location":"drivers/ansible/#delete-etchosts-file-on-2-random-servers-out-of-5","text":"In JSON \"method\" : [ { \"type\" : \"action\" , \"name\" : \"delete-etc-hosts-file\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosansible.actions\" , \"func\" : \"chaosansible_run\" , \"arguments\" : { \"host_list\" : [ \"server1\" , \"server2\" , \"server3\" , \"server4\" , \"server5\" ], \"num_target\" : \"2\" , \"become\" : true , \"ansible\" : { \"module\" : \"file\" , \"args\" : { \"path\" : \"/etc/hosts\" , \"state\" : \"absent\" } } } } } ] In YAML method : - type : action name : delete-etc-hosts-file provider : type : python module : chaosansible.actions func : chaosansible_run arguments : host_list : [ \"server1\" , \"server2\" , \"server3\" , \"server4\" , \"server5\" ] become : True num_target : \"2\" ansible : module : file args : path : /etc/hosts state : absent","title":"Delete /etc/hosts file on 2 random servers out of 5"},{"location":"drivers/ansible/#run-100-cpu-load-on-3-server-out-of-5","text":"In JSON \"method\" : [ { \"type\" : \"action\" , \"name\" : \"delete-etc-hosts-file\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosansible.actions\" , \"func\" : \"chaosansible_run\" , \"arguments\" : { \"host_list\" : [ \"server1\" , \"server2\" , \"server3\" , \"server4\" , \"server5\" ], \"num_target\" : \"3\" , \"ansible\" : { \"module\" : \"shell\" , \"args\" : { \"cmd\" : \"stress-ng --cpu 0 --cpu-method matrixprod -t 60s\" , } } } } } ] In YAML method : - type : action name : delete-etc-hosts-file provider : type : python module : chaosansible.actions func : chaosansible_run arguments : host_list : [ \"server1\" , \"server2\" , \"server3\" , \"server4\" , \"server5\" ] become : True num_target : \"3\" ansible : module : shell args : cmd : stress-ng --cpu 0 --cpu-method matrixprod -t 60s","title":"Run 100% cpu load on 3 server out of 5"},{"location":"drivers/ansible/#contribute","text":"If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. The Chaos Toolkit projects require all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR.","title":"Contribute"},{"location":"drivers/ansible/#develop","text":"If you wish to develop on this project, make sure to install the development dependencies. But first, create a virtual environment and then install those dependencies. $ pip install -r requirements-dev.txt -r requirements.txt Then, point your environment to this directory: $ pip install -e . Now, you can edit the files and they will be automatically be seen by your environment, even when running from the chaos command locally.","title":"Develop"},{"location":"drivers/ansible/#test","text":"To run the tests for the project execute the following: $ pytest","title":"Test"},{"location":"drivers/ansible/#exported-activities","text":"","title":"Exported Activities"},{"location":"drivers/ansible/#actions_1","text":"","title":"actions"},{"location":"drivers/ansible/#chaosansible_run","text":"Type action Module chaosansible.actions Name chaosansible_run Return None Run a task through ansible and eventually gather facts from host Signature: def chaosansible_run ( host_list : list = 'localhost' , configuration : Dict [ str , Dict [ str , str ]] = None , facts : bool = False , become : bool = False , run_once : bool = False , ansible : dict = {}, num_target : str = 'all' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required host_list list \u201clocalhost\u201d No facts boolean false No become boolean false No run_once boolean false No ansible mapping {} No num_target string \u201call\u201d No Usage: { \"name\" : \"chaosansible-run\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosansible.actions\" , \"func\" : \"chaosansible_run\" } } name : chaosansible-run provider : func : chaosansible_run module : chaosansible.actions type : python type : action","title":"chaosansible_run"},{"location":"drivers/ansible/#probes_1","text":"","title":"probes"},{"location":"drivers/ansible/#chaosansible_probe","text":"Type probe Module chaosansible.probes Name chaosansible_probe Return None Run a task through ansible and eventually gather facts from host Signature: def chaosansible_probe ( host_list : list = 'localhost' , configuration : Dict [ str , Dict [ str , str ]] = None , facts : bool = False , become : bool = False , run_once : bool = False , ansible : dict = {}, num_target : str = 'all' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required host_list list \u201clocalhost\u201d No facts boolean false No become boolean false No run_once boolean false No ansible mapping {} No num_target string \u201call\u201d No Usage: { \"name\" : \"chaosansible-probe\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosansible.probes\" , \"func\" : \"chaosansible_probe\" } } name : chaosansible-probe provider : func : chaosansible_probe module : chaosansible.probes type : python type : probe","title":"chaosansible_probe"},{"location":"drivers/aws/","text":"Extension chaosaws \u00b6 Version 0.16.0 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-aws This project is a collection of actions and probes , gathered as an extension to the Chaos Toolkit . Install \u00b6 This package requires Python 3.5+ To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install -U chaostoolkit-aws Usage \u00b6 To use the probes and actions from this package, add the following to your experiment file: { \"name\" : \"stop-an-ec2-instance\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ec2.actions\" , \"func\" : \"stop_instance\" , \"arguments\" : { \"instance_id\" : \"i-123456\" } } }, { \"name\" : \"create-a-new-policy\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.iam.actions\" , \"func\" : \"create_policy\" , \"arguments\" : { \"name\" : \"mypolicy\" , \"path\" : \"user/Jane\" , \"policy\" : { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Effect\" : \"Allow\" , \"Action\" : [ \"s3:ListAllMyBuckets\" , \"s3:GetBucketLocation\" ], \"Resource\" : \"arn:aws:s3:::*\" } ] } } } } Or select one at random from an AZ: { \"name\" : \"stop-an-ec2-instance-in-az-at-random\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ec2.actions\" , \"func\" : \"stop_instance\" , \"arguments\" : { \"az\" : \"us-west-1\" } } } That\u2019s it! Please explore the code to see existing probes and actions. Configuration \u00b6 Credentials \u00b6 This extension uses the boto3 library under the hood. This library expects that you have properly configured your environment to connect and authenticate with the AWS services. Use default profile from ~/.aws/credentials or ~/.aws/config \u00b6 This is the most basic case, assuming your default profile is properly configured in ~/.aws/credentials (or ~/.aws/config ), then you do not need to pass any specific credentials to the experiment. Use a non-default profile from ~/.aws/credentials or ~/.aws/config \u00b6 Assuming you have configure a profile in your ~/.aws/credentials (or ~/.aws/config ) file, you may declare it in your experiment as follows: { \"configuration\" : { \"aws_profile_name\" : \"dev\" } } Your ~/.aws/credentials should look like this: [dev] aws_access_key_id = XYZ aws_secret_access_key = UIOPIY Or, your ~/.aws/config should look like this: [profile dev] output = json aws_access_key_id = XYZ aws_secret_access_key = UIOPIY Assume an ARN role from a non-default profile \u00b6 Assuming you have configure a profile in your ~/.aws/config file with a specific ARN role you want to assume during the run: { \"configuration\" : { \"aws_profile_name\" : \"dev\" } } Your ~/.aws/config should look like this: [default] output = json [profile dev] role_arn = arn:aws:iam::XXXXXXX:role/role-name source_profile = default Assume an ARN role from within the experiment \u00b6 You mays also assume a role by declaring the role ARN in the experiment directly. In that case, the profile has no impact if you also set it. \"configuration\" : { \"aws_assume_role_arn\" : \"arn:aws:iam::XXXXXXX:role/role-name\" , \"aws_assume_role_session_name\" : \"my-chaos\" } The aws_assume_role_session_name key is optional and will be set to \"ChaosToolkit\" when not provided. When this approach is used, the extension performs a assume role call against the AWS STS service to fetch credentials dynamically. Pass credentials explicitely \u00b6 You can pass the credentials as a secret to the experiment definition as follows: { \"secrets\" : { \"aws\" : { \"aws_access_key_id\" : \"your key\" , \"aws_secret_access_key\" : \"access key\" , \"aws_session_token\" : \"token\" , } } } Note that the token is optional. Then, use it as follows: { \"name\" : \"stop-an-ec2-instance\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ec2.actions\" , \"func\" : \"stop_instance\" , \"secrets\" : [ \"aws\" ], \"arguments\" : { \"instance_id\" : \"i-123456\" } } } Setting the region \u00b6 In additon to the authentication credentials, you must configure the region against which you want to use. You can either declare it at the top level of the experiment, add: { \"configuration\" : { \"aws_region\" : \"us-east-1\" } } or { \"configuration\" : { \"aws_region\" : { \"env\" : \"type\" , \"key\" : \"AWS_REGION\" } } } But you can also simply set either AWS_REGION or AWS_DEFAULT_REGION in your terminal session without declaring anything in the experiment. If none of these are set, your experiment will likely fail. Contribute \u00b6 If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. The Chaos Toolkit projects require all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR. Develop \u00b6 If you wish to develop on this project, make sure to install the development dependencies. But first, create a virtual environment and then install those dependencies. $ pip install -r requirements-dev.txt -r requirements.txt Then, point your environment to this directory: $ python setup.py develop Now, you can edit the files and they will be automatically be seen by your environment, even when running from the chaos command locally. Test \u00b6 To run the tests for the project execute the following: $ pytest Add new AWS API Support \u00b6 Once you have setup your environment, you can start adding new AWS API support by adding new actions, probes and entire sub-packages for those. Services supported by boto \u00b6 This package relies on boto3 to wrap the API calls into a fluent Python API. Some newer AWS services are not yet available in boto3, in that case, you should read the next section. Let\u2019s say you want to support a new action in the EC2 sub-package. Start by creating a new function in ec2/actions.py : from chaoslib.types import Configuration , Secrets from chaosaws import aws_client from chaosaws.types import AWSResponse def reboot_instance ( instance_id : str , dry_run : bool = False , configuration : Configuration = None , secrets : Secrets = None ) -> AWSResponse : \"\"\" Reboot a given EC2 instance. \"\"\" client = aws_client ( 'ec2' , configuration , secrets ) return client . reboot_instances ( InstanceIds = [ instance_id ], DryRun = dry_run ) As you can see, the actual code is straightforward. You first create a EC2 client and simply call the appropriate method on that client with the expected arguments. We return the action as-is so that it can be logged by the chaostoolkit, or even be used as part of a steady-state hypothesis probe (if this was a probe, not action that is). You could decide to make more than one AWS API call but, it is better to keep it simple so that composition is easier from the experiment. Nonetheless, you may also compose those directly into a single action as well for specific use-cases. Please refer to the Chaos Toolkit documentation to learn more about the configuration and secrets objects. Once you have implemented that action, you must create at least one unit test for it in the tests/ec2/test_ec2_actions.py test module. For example: from chaosaws.ec2.actions import reboot_instancex @patch ( 'chaosaws.ec2.actions.aws_client' , autospec = True ) def test_reboot_instance ( aws_client ): client = MagicMock () aws_client . return_value = client inst_id = \"i-1234567890abcdef0\" response = reboot_instance ( inst_id ) client . reboot_instances . assert_called_with ( InstanceIds = [ inst_id ], DryRun = False ) By using the built-in Python module to mock objects , we can mock the EC2 client and assert that we do indeed call the appropriate method with the right arguments. You are encouraged to write more than a single test for various conditions. Finally, should you choose to add support for a new AWS API resource altogether, you should create the according sub-package. Services not supported by boto (new AWS features) \u00b6 If the support you want to provide is for a new AWS service that boto does not support yet, this requires direct call to the API endpoint via the requests package. Say we have a new service, not yet supported by boto3 from chaoslib.types import Configuration , Secrets from chaosaws import signed_api_call from chaosaws.types import AWSResponse def terminate_worker_node ( worker_node_id : str , configuration : Configuration = None , secrets : Secrets = None ) -> AWSResponse : \"\"\" Terminate a worker node. \"\"\" params = { \"DryRun\" : True , \"WorkerNodeId.1\" : worker_node_id } response = signed_api_call ( 'some-new-service-name' , path = '/2018-01-01/worker/terminate' , method = 'POST' , params = params , configuration = configuration , secrets = secrets ) return response . json () Here is an example on existing API call (as a more concrete snippet): from chaoslib.types import Configuration , Secrets from chaosaws import signed_api_call def stop_instance ( instance_id : str , configuration : Configuration = None , secrets : Secrets = None ) -> str : response = signed_api_call ( 'ec2' , configuration = configuration , secrets = secrets , params = { \"Action\" : \"StopInstances\" , \"InstanceId.1\" : instance_id , \"Version\" : \"2013-06-15\" } ) # this API returns XML, not JSON return response . text When using the signed_api_call , you are responsible for the right way of passing the parameters. Basically, look at the AWS documentation for each API call. WARNING: It should be noted that, whenever boto3 implements an API, this package should be updated accordingly, as boto3 is much more versatile and solid. Make your new sub-package discoverable \u00b6 Finally, if you have created a new sub-package entirely, you need to make its capability discoverable by the chaos toolkit. Simply amend the discover function in the chaosaws/__init__.py . For example, assuming a new eks sub-package, with actions and probes: activities . extend ( discover_actions ( \"chaosaws.eks.actions\" )) activities . extend ( discover_probes ( \"chaosaws.eks.probes\" )) Exported Activities \u00b6 asg \u00b6 attach_volume \u00b6 Type action Module chaosaws.asg.actions Name attach_volume Return list Attaches ebs volumes that have been previously detached by CTK : One of: asg_names: list: one or more asg names tags: list: key/value pairs to identify asgs by tags are expected as a list of dictionary objects: [ {\u2018Key\u2019: \u2018TagKey1\u2019, \u2018Value\u2019: \u2018TagValue1\u2019}, {\u2018Key\u2019: \u2018TagKey2\u2019, \u2018Value\u2019: \u2018TagValue2\u2019}, \u2026 ] Signature: def attach_volume ( asg_names : List [ str ] = None , tags : List [ Dict [ str , str ]] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required asg_names list null No tags list null No Usage: { \"name\" : \"attach-volume\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.asg.actions\" , \"func\" : \"attach_volume\" } } name : attach-volume provider : func : attach_volume module : chaosaws.asg.actions type : python type : action change_subnets \u00b6 Type action Module chaosaws.asg.actions Name change_subnets Return None Adds/removes subnets on autoscaling groups : One of: asg_names: a list of one or more asg names tags: a list of key/value pair to identify asg(s) by subnets: a list of subnet IDs to associate to the ASG tags are expected as a list of dictionary objects: [ {\u2018Key\u2019: \u2018TagKey1\u2019, \u2018Value\u2019: \u2018TagValue1\u2019}, {\u2018Key\u2019: \u2018TagKey2\u2019, \u2018Value\u2019: \u2018TagValue2\u2019}, \u2026 ] Signature: def change_subnets ( subnets : List [ str ], asg_names : List [ str ] = None , tags : List [ dict ] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required subnets list Yes asg_names list null No tags list null No Usage: { \"name\" : \"change-subnets\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.asg.actions\" , \"func\" : \"change_subnets\" , \"arguments\" : { \"subnets\" : [] } } } name : change-subnets provider : arguments : subnets : [] func : change_subnets module : chaosaws.asg.actions type : python type : action describe_auto_scaling_groups \u00b6 Type probe Module chaosaws.asg.probes Name describe_auto_scaling_groups Return mapping Returns AWS descriptions for provided ASG(s) Params: OneOf: - asg_names: a list of asg names to describe - tags: a list of key/value pairs to collect ASG(s) tags are expected as a list of dictionary objects: [ {\u2018Key\u2019: \u2018TagKey1\u2019, \u2018Value\u2019: \u2018TagValue1\u2019}, {\u2018Key\u2019: \u2018TagKey2\u2019, \u2018Value\u2019: \u2018TagValue2\u2019}, \u2026 ] Signature: def describe_auto_scaling_groups ( asg_names : List [ str ] = None , tags : List [ Dict [ str , Any ]] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required asg_names list null No tags list null No Usage: { \"name\" : \"describe-auto-scaling-groups\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.asg.probes\" , \"func\" : \"describe_auto_scaling_groups\" } } name : describe-auto-scaling-groups provider : func : describe_auto_scaling_groups module : chaosaws.asg.probes type : python type : probe desired_equals_healthy \u00b6 Type probe Module chaosaws.asg.probes Name desired_equals_healthy Return boolean If desired number matches the number of healthy instances for each of the auto-scaling groups Returns: bool Signature: def desired_equals_healthy ( asg_names : List [ str ], configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required asg_names list Yes Usage: { \"name\" : \"desired-equals-healthy\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.asg.probes\" , \"func\" : \"desired_equals_healthy\" , \"arguments\" : { \"asg_names\" : [] } } } name : desired-equals-healthy provider : arguments : asg_names : [] func : desired_equals_healthy module : chaosaws.asg.probes type : python type : probe desired_equals_healthy_tags \u00b6 Type probe Module chaosaws.asg.probes Name desired_equals_healthy_tags Return boolean If desired number matches the number of healthy instances for each of the auto-scaling groups matching tags provided tags are expected as: [{ \u2018Key\u2019: \u2018KeyName\u2019, \u2018Value\u2019: \u2018KeyValue\u2019 }, \u2026 ] Returns: bool Signature: def desired_equals_healthy_tags ( tags : List [ Dict [ str , str ]], configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required tags list Yes Usage: { \"name\" : \"desired-equals-healthy-tags\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.asg.probes\" , \"func\" : \"desired_equals_healthy_tags\" , \"arguments\" : { \"tags\" : [] } } } name : desired-equals-healthy-tags provider : arguments : tags : [] func : desired_equals_healthy_tags module : chaosaws.asg.probes type : python type : probe detach_random_instances \u00b6 Type action Module chaosaws.asg.actions Name detach_random_instances Return mapping Detaches one or more random instances from an autoscaling group : One of: asg_names: a list of one or more asg names tags: a list of key/value pair to identify asg(s) by One of: instance_count: integer value of number of instances to detach instance_percent: 1-100, percent of instances to detach decrement_capacity: boolean value to determine if the desired capacity of the autoscaling group should be decreased tags are expected as a list of dictionary objects: [ {\u2018Key\u2019: \u2018TagKey1\u2019, \u2018Value\u2019: \u2018TagValue1\u2019}, {\u2018Key\u2019: \u2018TagKey2\u2019, \u2018Value\u2019: \u2018TagValue2\u2019}, \u2026 ] Signature: def detach_random_instances ( asg_names : List [ str ] = None , tags : List [ dict ] = None , instance_count : int = None , instance_percent : int = None , decrement_capacity : bool = False , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required asg_names list null No tags list null No instance_count integer null No instance_percent integer null No decrement_capacity boolean false No Usage: { \"name\" : \"detach-random-instances\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.asg.actions\" , \"func\" : \"detach_random_instances\" } } name : detach-random-instances provider : func : detach_random_instances module : chaosaws.asg.actions type : python type : action detach_random_volume \u00b6 Type action Module chaosaws.asg.actions Name detach_random_volume Return list Detaches a random (non root) ebs volume from ec2 instances associated to an ASG : One of: asg_names: a list of one or more asg names tags: a list of key/value pair to identify asg(s) by force: force detach volume (default: true) tags are expected as a list of dictionary objects: [ {\u2018Key\u2019: \u2018TagKey1\u2019, \u2018Value\u2019: \u2018TagValue1\u2019}, {\u2018Key\u2019: \u2018TagKey2\u2019, \u2018Value\u2019: \u2018TagValue2\u2019}, \u2026 ] Signature: def detach_random_volume ( asg_names : List [ str ] = None , tags : List [ Dict [ str , str ]] = None , force : bool = True , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required asg_names list null No tags list null No force boolean true No Usage: { \"name\" : \"detach-random-volume\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.asg.actions\" , \"func\" : \"detach_random_volume\" } } name : detach-random-volume provider : func : detach_random_volume module : chaosaws.asg.actions type : python type : action has_subnets \u00b6 Type probe Module chaosaws.asg.probes Name has_subnets Return boolean Determines if the provided autoscaling groups are in the provided subnets :returns boolean Signature: def has_subnets ( subnets : List [ str ], asg_names : List [ str ] = None , tags : List [ Dict [ str , str ]] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required subnets list Yes asg_names list null No tags list null No Usage: { \"name\" : \"has-subnets\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.asg.probes\" , \"func\" : \"has_subnets\" , \"arguments\" : { \"subnets\" : [] } } } name : has-subnets provider : arguments : subnets : [] func : has_subnets module : chaosaws.asg.probes type : python type : probe instance_count_by_health \u00b6 Type probe Module chaosaws.asg.probes Name instance_count_by_health Return integer Reports the number of instances currently in the ASG by their health status Params: OneOf: - asg_names: a list of asg names to describe - tags: a list of key/value pairs to collect ASG(s) - count_healthy: boolean: true for healthy instance count, false for unhealthy instance count tags are expected as a list of dictionary objects: [ {\u2018Key\u2019: \u2018TagKey1\u2019, \u2018Value\u2019: \u2018TagValue1\u2019}, {\u2018Key\u2019: \u2018TagKey2\u2019, \u2018Value\u2019: \u2018TagValue2\u2019}, \u2026 ] Signature: def instance_count_by_health ( asg_names : List [ str ] = None , tags : List [ Dict [ str , str ]] = None , count_healthy : bool = True , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required asg_names list null No tags list null No count_healthy boolean true No Usage: { \"name\" : \"instance-count-by-health\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.asg.probes\" , \"func\" : \"instance_count_by_health\" } } name : instance-count-by-health provider : func : instance_count_by_health module : chaosaws.asg.probes type : python type : probe is_scaling_in_progress \u00b6 Type probe Module chaosaws.asg.probes Name is_scaling_in_progress Return boolean Check if there is any scaling activity in progress for ASG matching tags Returns: Boolean Signature: def is_scaling_in_progress ( tags : List [ Dict [ str , str ]], configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required tags list Yes Usage: { \"name\" : \"is-scaling-in-progress\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.asg.probes\" , \"func\" : \"is_scaling_in_progress\" , \"arguments\" : { \"tags\" : [] } } } name : is-scaling-in-progress provider : arguments : tags : [] func : is_scaling_in_progress module : chaosaws.asg.probes type : python type : probe process_is_suspended \u00b6 Type probe Module chaosaws.asg.probes Name process_is_suspended Return boolean Determines if one or more processes on an ASG are suspended. :returns Boolean Signature: def process_is_suspended ( asg_names : List [ str ] = None , tags : List [ Dict [ str , str ]] = None , process_names : List [ str ] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required asg_names list null No tags list null No process_names list null No Usage: { \"name\" : \"process-is-suspended\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.asg.probes\" , \"func\" : \"process_is_suspended\" } } name : process-is-suspended provider : func : process_is_suspended module : chaosaws.asg.probes type : python type : probe resume_processes \u00b6 Type action Module chaosaws.asg.actions Name resume_processes Return mapping Resumes 1 or more suspended processes on a list of auto scaling groups. If no process is specified, all suspended auto scaling processes will be resumed. For a list of valid processes that can be suspended, reference: https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-suspend-resume-processes.html : One of: - asg_names: a list of one or more asg names to target - tags: a list of key/value pairs to identify the asgs by tags are expected as a list of dictionary objects: [ {\u2018Key\u2019: \u2018TagKey1\u2019, \u2018Value\u2019: \u2018TagValue1\u2019}, {\u2018Key\u2019: \u2018TagKey2\u2019, \u2018Value\u2019: \u2018TagValue2\u2019}, \u2026 ] Signature: def resume_processes ( asg_names : List [ str ] = None , tags : List [ Dict [ str , str ]] = None , process_names : List [ str ] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required asg_names list null No tags list null No process_names list null No Usage: { \"name\" : \"resume-processes\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.asg.actions\" , \"func\" : \"resume_processes\" } } name : resume-processes provider : func : resume_processes module : chaosaws.asg.actions type : python type : action stop_random_instances \u00b6 Type action Module chaosaws.asg.actions Name stop_random_instances Return list Terminates one or more random healthy instances associated to an ALB A healthy instance is considered one with a status of \u2018InService\u2019 : - force: force stop the instances (default: False) One Of: asg_names: a list of one or more asg names to target tags: a list of key/value pairs to identify the asgs by One Of: - instance_count: the number of instances to terminate - instance_percent: the percentage of instances to terminate - az: the availability zone to terminate instances tags are expected as a list of dictionary objects: [ {\u2018Key\u2019: \u2018TagKey1\u2019, \u2018Value\u2019: \u2018TagValue1\u2019}, {\u2018Key\u2019: \u2018TagKey2\u2019, \u2018Value\u2019: \u2018TagValue2\u2019}, \u2026 ] Signature: def stop_random_instances ( asg_names : List [ str ] = None , tags : List [ Dict [ str , str ]] = None , instance_count : int = None , instance_percent : int = None , az : str = None , force : bool = False , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required asg_names list null No tags list null No instance_count integer null No instance_percent integer null No az string null No force boolean false No Usage: { \"name\" : \"stop-random-instances\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.asg.actions\" , \"func\" : \"stop_random_instances\" } } name : stop-random-instances provider : func : stop_random_instances module : chaosaws.asg.actions type : python type : action suspend_processes \u00b6 Type action Module chaosaws.asg.actions Name suspend_processes Return mapping Suspends 1 or more processes on a list of auto scaling groups. If no process is specified, all running auto scaling processes will be suspended. For a list of valid processes that can be suspended, reference: https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-suspend-resume-processes.html : One of: - asg_names: a list of one or more asg names to target - tags: a list of key/value pairs to identify the asgs by tags are expected as a list of dictionary objects: [ {\u2018Key\u2019: \u2018TagKey1\u2019, \u2018Value\u2019: \u2018TagValue1\u2019}, {\u2018Key\u2019: \u2018TagKey2\u2019, \u2018Value\u2019: \u2018TagValue2\u2019}, \u2026 ] Signature: def suspend_processes ( asg_names : List [ str ] = None , tags : List [ Dict [ str , str ]] = None , process_names : List [ str ] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required asg_names list null No tags list null No process_names list null No Usage: { \"name\" : \"suspend-processes\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.asg.actions\" , \"func\" : \"suspend_processes\" } } name : suspend-processes provider : func : suspend_processes module : chaosaws.asg.actions type : python type : action terminate_random_instances \u00b6 Type action Module chaosaws.asg.actions Name terminate_random_instances Return list Terminates one or more random healthy instances associated to an ALB A healthy instance is considered one with a status of \u2018InService\u2019 : One Of: - asg_names: a list of one or more asg names to target - tags: a list of key/value pairs to identify the asgs by One Of: - instance_count: the number of instances to terminate - instance_percent: the percentage of instances to terminate - az: the availability zone to terminate instances tags are expected as a list of dictionary objects: [ {\u2018Key\u2019: \u2018TagKey1\u2019, \u2018Value\u2019: \u2018TagValue1\u2019}, {\u2018Key\u2019: \u2018TagKey2\u2019, \u2018Value\u2019: \u2018TagValue2\u2019}, \u2026 ] Signature: def terminate_random_instances ( asg_names : List [ str ] = None , tags : List [ Dict [ str , str ]] = None , instance_count : int = None , instance_percent : int = None , az : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required asg_names list null No tags list null No instance_count integer null No instance_percent integer null No az string null No Usage: { \"name\" : \"terminate-random-instances\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.asg.actions\" , \"func\" : \"terminate_random_instances\" } } name : terminate-random-instances provider : func : terminate_random_instances module : chaosaws.asg.actions type : python type : action wait_desired_equals_healthy \u00b6 Type probe Module chaosaws.asg.probes Name wait_desired_equals_healthy Return integer Wait until desired number matches the number of healthy instances for each of the auto-scaling groups Returns: Integer (number of seconds it took to wait) or sys.maxsize in case of timeout Signature: def wait_desired_equals_healthy ( asg_names : List [ str ], configuration : Dict [ str , Dict [ str , str ]] = None , timeout : Union [ int , float ] = 300 , secrets : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required asg_names list Yes timeout object 300 No Usage: { \"name\" : \"wait-desired-equals-healthy\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.asg.probes\" , \"func\" : \"wait_desired_equals_healthy\" , \"arguments\" : { \"asg_names\" : [] } } } name : wait-desired-equals-healthy provider : arguments : asg_names : [] func : wait_desired_equals_healthy module : chaosaws.asg.probes type : python type : probe wait_desired_equals_healthy_tags \u00b6 Type probe Module chaosaws.asg.probes Name wait_desired_equals_healthy_tags Return integer Wait until desired number matches the number of healthy instances for each of the auto-scaling groups matching tags provided tags are expected as: [{ \u2018Key\u2019: \u2018KeyName\u2019, \u2018Value\u2019: \u2018KeyValue\u2019 }, \u2026 ] Returns: Integer (number of seconds it took to wait) or sys.maxsize in case of timeout Signature: def wait_desired_equals_healthy_tags ( tags : List [ Dict [ str , str ]], timeout : Union [ int , float ] = 300 , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required tags list Yes timeout object 300 No Usage: { \"name\" : \"wait-desired-equals-healthy-tags\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.asg.probes\" , \"func\" : \"wait_desired_equals_healthy_tags\" , \"arguments\" : { \"tags\" : [] } } } name : wait-desired-equals-healthy-tags provider : arguments : tags : [] func : wait_desired_equals_healthy_tags module : chaosaws.asg.probes type : python type : probe wait_desired_not_equals_healthy_tags \u00b6 Type probe Module chaosaws.asg.probes Name wait_desired_not_equals_healthy_tags Return integer Wait until desired number doesn\u2019t match the number of healthy instances for each of the auto-scaling groups matching tags provided tags are expected as: [{ \u2018Key\u2019: \u2018KeyName\u2019, \u2018Value\u2019: \u2018KeyValue\u2019 }, \u2026 ] Returns: Integer (number of seconds it took to wait) or sys.maxsize in case of timeout Signature: def wait_desired_not_equals_healthy_tags ( tags : List [ Dict [ str , str ]], timeout : Union [ int , float ] = 300 , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required tags list Yes timeout object 300 No Usage: { \"name\" : \"wait-desired-not-equals-healthy-tags\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.asg.probes\" , \"func\" : \"wait_desired_not_equals_healthy_tags\" , \"arguments\" : { \"tags\" : [] } } } name : wait-desired-not-equals-healthy-tags provider : arguments : tags : [] func : wait_desired_not_equals_healthy_tags module : chaosaws.asg.probes type : python type : probe awslambda \u00b6 delete_function_concurrency \u00b6 Type action Module chaosaws.awslambda.actions Name delete_function_concurrency Return mapping Removes concurrency limit applied to the specified Lambda Signature: def delete_function_concurrency ( function_name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required function_name string Yes Usage: { \"name\" : \"delete-function-concurrency\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.awslambda.actions\" , \"func\" : \"delete_function_concurrency\" , \"arguments\" : { \"function_name\" : \"\" } } } name : delete-function-concurrency provider : arguments : function_name : '' func : delete_function_concurrency module : chaosaws.awslambda.actions type : python type : action get_function_concurrency \u00b6 Type probe Module chaosaws.awslambda.probes Name get_function_concurrency Return boolean Get configuration information of lambda by its function name Signature: def get_function_concurrency ( function_name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required function_name string Yes Usage: { \"name\" : \"get-function-concurrency\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.awslambda.probes\" , \"func\" : \"get_function_concurrency\" , \"arguments\" : { \"function_name\" : \"\" } } } name : get-function-concurrency provider : arguments : function_name : '' func : get_function_concurrency module : chaosaws.awslambda.probes type : python type : probe get_function_memory_size \u00b6 Type probe Module chaosaws.awslambda.probes Name get_function_memory_size Return integer Get the configured memory size of a lambda function. The returned memory size is specified in megabytes. Signature: def get_function_memory_size ( function_name : str , qualifier : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required function_name string Yes qualifier string null No Usage: { \"name\" : \"get-function-memory-size\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.awslambda.probes\" , \"func\" : \"get_function_memory_size\" , \"arguments\" : { \"function_name\" : \"\" } } } name : get-function-memory-size provider : arguments : function_name : '' func : get_function_memory_size module : chaosaws.awslambda.probes type : python type : probe get_function_timeout \u00b6 Type probe Module chaosaws.awslambda.probes Name get_function_timeout Return integer Get the configured timeout of a lambda function. The returned timeout is specified in number of seconds. Signature: def get_function_timeout ( function_name : str , qualifier : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required function_name string Yes qualifier string null No Usage: { \"name\" : \"get-function-timeout\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.awslambda.probes\" , \"func\" : \"get_function_timeout\" , \"arguments\" : { \"function_name\" : \"\" } } } name : get-function-timeout provider : arguments : function_name : '' func : get_function_timeout module : chaosaws.awslambda.probes type : python type : probe invoke_function \u00b6 Type action Module chaosaws.awslambda.actions Name invoke_function Return mapping Invokes Lambda. More information about request arguments are available in the documentation https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/lambda.html#Lambda.Client.invoke Signature: def invoke_function ( function_name : str , function_arguments : Dict [ str , Any ] = None , invocation_type : str = 'RequestResponse' , client_context : Dict [ str , Any ] = None , qualifier : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required function_name string Yes function_arguments mapping null No invocation_type string \u201cRequestResponse\u201d No client_context mapping null No qualifier string null No Usage: { \"name\" : \"invoke-function\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.awslambda.actions\" , \"func\" : \"invoke_function\" , \"arguments\" : { \"function_name\" : \"\" } } } name : invoke-function provider : arguments : function_name : '' func : invoke_function module : chaosaws.awslambda.actions type : python type : action put_function_concurrency \u00b6 Type action Module chaosaws.awslambda.actions Name put_function_concurrency Return mapping Throttles Lambda by setting reserved concurrency amount. Signature: def put_function_concurrency ( function_name : str , concurrent_executions : int , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required function_name string Yes concurrent_executions integer Yes Usage: { \"name\" : \"put-function-concurrency\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.awslambda.actions\" , \"func\" : \"put_function_concurrency\" , \"arguments\" : { \"function_name\" : \"\" , \"concurrent_executions\" : 0 } } } name : put-function-concurrency provider : arguments : concurrent_executions : 0 function_name : '' func : put_function_concurrency module : chaosaws.awslambda.actions type : python type : action put_function_memory_size \u00b6 Type action Module chaosaws.awslambda.actions Name put_function_memory_size Return mapping Sets the function memory size. Input memory_size argument is specified in megabytes. Signature: def put_function_memory_size ( function_name : str , memory_size : int , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required function_name string Yes memory_size integer Yes Usage: { \"name\" : \"put-function-memory-size\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.awslambda.actions\" , \"func\" : \"put_function_memory_size\" , \"arguments\" : { \"function_name\" : \"\" , \"memory_size\" : 0 } } } name : put-function-memory-size provider : arguments : function_name : '' memory_size : 0 func : put_function_memory_size module : chaosaws.awslambda.actions type : python type : action put_function_timeout \u00b6 Type action Module chaosaws.awslambda.actions Name put_function_timeout Return mapping Sets the function timeout. Input timeout argument is specified in seconds. Signature: def put_function_timeout ( function_name : str , timeout : int , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required function_name string Yes timeout integer Yes Usage: { \"name\" : \"put-function-timeout\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.awslambda.actions\" , \"func\" : \"put_function_timeout\" , \"arguments\" : { \"function_name\" : \"\" , \"timeout\" : 0 } } } name : put-function-timeout provider : arguments : function_name : '' timeout : 0 func : put_function_timeout module : chaosaws.awslambda.actions type : python type : action cloudwatch \u00b6 delete_rule \u00b6 Type action Module chaosaws.cloudwatch.actions Name delete_rule Return mapping Deletes a CloudWatch rule. All rule targets must be removed before deleting the rule. Set input argument force to True to force all rule targets to be deleted. Signature: def delete_rule ( rule_name : str , force : bool = False , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required rule_name string Yes force boolean false No Usage: { \"name\" : \"delete-rule\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.cloudwatch.actions\" , \"func\" : \"delete_rule\" , \"arguments\" : { \"rule_name\" : \"\" } } } name : delete-rule provider : arguments : rule_name : '' func : delete_rule module : chaosaws.cloudwatch.actions type : python type : action disable_rule \u00b6 Type action Module chaosaws.cloudwatch.actions Name disable_rule Return mapping Disables a CloudWatch rule. Signature: def disable_rule ( rule_name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required rule_name string Yes Usage: { \"name\" : \"disable-rule\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.cloudwatch.actions\" , \"func\" : \"disable_rule\" , \"arguments\" : { \"rule_name\" : \"\" } } } name : disable-rule provider : arguments : rule_name : '' func : disable_rule module : chaosaws.cloudwatch.actions type : python type : action enable_rule \u00b6 Type action Module chaosaws.cloudwatch.actions Name enable_rule Return mapping Enables a CloudWatch rule. Signature: def enable_rule ( rule_name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required rule_name string Yes Usage: { \"name\" : \"enable-rule\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.cloudwatch.actions\" , \"func\" : \"enable_rule\" , \"arguments\" : { \"rule_name\" : \"\" } } } name : enable-rule provider : arguments : rule_name : '' func : enable_rule module : chaosaws.cloudwatch.actions type : python type : action get_alarm_state_value \u00b6 Type probe Module chaosaws.cloudwatch.probes Name get_alarm_state_value Return string Return the state value of an alarm. The possbile alarm state values are described in the documentation https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/cloudwatch.html#CloudWatch.Client.describe_alarms Signature: def get_alarm_state_value ( alarm_name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> str : pass Arguments: Name Type Default Required alarm_name string Yes Usage: { \"name\" : \"get-alarm-state-value\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.cloudwatch.probes\" , \"func\" : \"get_alarm_state_value\" , \"arguments\" : { \"alarm_name\" : \"\" } } } name : get-alarm-state-value provider : arguments : alarm_name : '' func : get_alarm_state_value module : chaosaws.cloudwatch.probes type : python type : probe get_metric_data \u00b6 Type probe Module chaosaws.cloudwatch.probes Name get_metric_data Return number Gets metric data for a given metric in a given time period. This method allows for more data to be retrieved than get_metric_statistics :params namespace: The AWS metric namespace metric_name: The name of the metric to pull data for dimension_name: The name of the dimension to search for dimension_value: The value to be used for searching the dimension unit: The type of unit desired to be collected statistic: The type of data to return. One of: Average, Sum, Minimum, Maximum, SampleCount period: The window in which to pull datapoints for offset: The time (seconds) to offset the endtime (from now) duration: The time (seconds) to set the start time (from now) Signature: def get_metric_data ( namespace : str , metric_name : str , dimension_name : str , dimension_value : str , statistic : str = None , duration : int = 300 , period : int = 60 , offset : int = 0 , unit : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> float : pass Arguments: Name Type Default Required namespace string Yes metric_name string Yes dimension_name string Yes dimension_value string Yes statistic string null No duration integer 300 No period integer 60 No offset integer 0 No unit string null No Usage: { \"name\" : \"get-metric-data\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.cloudwatch.probes\" , \"func\" : \"get_metric_data\" , \"arguments\" : { \"namespace\" : \"\" , \"metric_name\" : \"\" , \"dimension_name\" : \"\" , \"dimension_value\" : \"\" } } } name : get-metric-data provider : arguments : dimension_name : '' dimension_value : '' metric_name : '' namespace : '' func : get_metric_data module : chaosaws.cloudwatch.probes type : python type : probe get_metric_statistics \u00b6 Type probe Module chaosaws.cloudwatch.probes Name get_metric_statistics Return None Get the value of a statistical calculation for a given metric. The period for which the calculation will be performed is specified by a duration and an offset from the current time. Both are specified in seconds. Example: A duration of 60 seconds and an offset of 30 seconds will yield a statistical value based on the time interval between 30 and 90 seconds in the past. More information about input parameters are available in the documentation https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/cloudwatch.html#CloudWatch.Client.get_metric_statistics Signature: def get_metric_statistics ( namespace : str , metric_name : str , dimension_name : str , dimension_value : str , duration : int = 60 , offset : int = 0 , statistic : str = None , extended_statistic : str = None , unit : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required namespace string Yes metric_name string Yes dimension_name string Yes dimension_value string Yes duration integer 60 No offset integer 0 No statistic string null No extended_statistic string null No unit string null No Usage: { \"name\" : \"get-metric-statistics\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.cloudwatch.probes\" , \"func\" : \"get_metric_statistics\" , \"arguments\" : { \"namespace\" : \"\" , \"metric_name\" : \"\" , \"dimension_name\" : \"\" , \"dimension_value\" : \"\" } } } name : get-metric-statistics provider : arguments : dimension_name : '' dimension_value : '' metric_name : '' namespace : '' func : get_metric_statistics module : chaosaws.cloudwatch.probes type : python type : probe put_rule \u00b6 Type action Module chaosaws.cloudwatch.actions Name put_rule Return mapping Creates or updates a CloudWatch event rule. Please refer to https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/events.html#CloudWatchEvents.Client.put_rule for details on input arguments. Signature: def put_rule ( rule_name : str , schedule_expression : str = None , event_pattern : str = None , state : str = None , description : str = None , role_arn : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required rule_name string Yes schedule_expression string null No event_pattern string null No state string null No description string null No role_arn string null No Usage: { \"name\" : \"put-rule\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.cloudwatch.actions\" , \"func\" : \"put_rule\" , \"arguments\" : { \"rule_name\" : \"\" } } } name : put-rule provider : arguments : rule_name : '' func : put_rule module : chaosaws.cloudwatch.actions type : python type : action put_rule_targets \u00b6 Type action Module chaosaws.cloudwatch.actions Name put_rule_targets Return mapping Creates or update CloudWatch event rule targets. Please refer to https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/events.html#CloudWatchEvents.Client.put_targets for details on input arguments. Signature: def put_rule_targets ( rule_name : str , targets : List [ Dict [ str , Any ]], configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required rule_name string Yes targets list Yes Usage: { \"name\" : \"put-rule-targets\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.cloudwatch.actions\" , \"func\" : \"put_rule_targets\" , \"arguments\" : { \"rule_name\" : \"\" , \"targets\" : [] } } } name : put-rule-targets provider : arguments : rule_name : '' targets : [] func : put_rule_targets module : chaosaws.cloudwatch.actions type : python type : action remove_rule_targets \u00b6 Type action Module chaosaws.cloudwatch.actions Name remove_rule_targets Return mapping Removes CloudWatch rule targets. If no target ids are provided all targets will be removed. Signature: def remove_rule_targets ( rule_name : str , target_ids : List [ str ] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required rule_name string Yes target_ids list null No Usage: { \"name\" : \"remove-rule-targets\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.cloudwatch.actions\" , \"func\" : \"remove_rule_targets\" , \"arguments\" : { \"rule_name\" : \"\" } } } name : remove-rule-targets provider : arguments : rule_name : '' func : remove_rule_targets module : chaosaws.cloudwatch.actions type : python type : action ec2 \u00b6 attach_volume \u00b6 Type action Module chaosaws.ec2.actions Name attach_volume Return list Attaches a previously detached EBS volume to its associated EC2 instance. If neither \u2018instance_ids\u2019 or \u2018filters\u2019 are provided, all detached volumes will be reattached to their respective instances : One of: instance_ids: list: instance ids filters: list: key/value pairs to pull ec2 instances Signature: def attach_volume ( instance_ids : List [ str ] = None , filters : List [ Dict [ str , Any ]] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required instance_ids list null No filters list null No Usage: { \"name\" : \"attach-volume\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ec2.actions\" , \"func\" : \"attach_volume\" } } name : attach-volume provider : func : attach_volume module : chaosaws.ec2.actions type : python type : action count_instances \u00b6 Type probe Module chaosaws.ec2.probes Name count_instances Return integer Return count of instances matching the specified filters. Please refer to https://bit.ly/2Sv9lmU for details on said filters. Signature: def count_instances ( filters : List [ Dict [ str , Any ]], configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required filters list Yes Usage: { \"name\" : \"count-instances\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ec2.probes\" , \"func\" : \"count_instances\" , \"arguments\" : { \"filters\" : [] } } } name : count-instances provider : arguments : filters : [] func : count_instances module : chaosaws.ec2.probes type : python type : probe describe_instances \u00b6 Type probe Module chaosaws.ec2.probes Name describe_instances Return mapping Describe instances following the specified filters. Please refer to https://bit.ly/2Sv9lmU for details on said filters. Signature: def describe_instances ( filters : List [ Dict [ str , Any ]], configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required filters list Yes Usage: { \"name\" : \"describe-instances\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ec2.probes\" , \"func\" : \"describe_instances\" , \"arguments\" : { \"filters\" : [] } } } name : describe-instances provider : arguments : filters : [] func : describe_instances module : chaosaws.ec2.probes type : python type : probe detach_random_volume \u00b6 Type action Module chaosaws.ec2.actions Name detach_random_volume Return list Detaches a random ebs volume (non root) from one or more EC2 instances : One of: instance_ids: a list of one or more ec2 instance ids filters: a list of key/value pairs to pull ec2 instances force: force detach volume (default: true) Additional filters may be used to narrow the scope: https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ec2.html#EC2.Client.describe_instances Signature: def detach_random_volume ( instance_ids : List [ str ] = None , filters : List [ Dict [ str , Any ]] = None , force : bool = True , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required instance_ids list null No filters list null No force boolean true No Usage: { \"name\" : \"detach-random-volume\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ec2.actions\" , \"func\" : \"detach_random_volume\" } } name : detach-random-volume provider : func : detach_random_volume module : chaosaws.ec2.actions type : python type : action instance_state \u00b6 Type probe Module chaosaws.ec2.probes Name instance_state Return boolean Determines if EC2 instances match desired state For additional filter options, please refer to the documentation found: https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ec2.html#EC2.Client.describe_instances Signature: def instance_state ( state : str , instance_ids : List [ str ] = None , filters : List [ Dict [ str , Any ]] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required state string Yes instance_ids list null No filters list null No Usage: { \"name\" : \"instance-state\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ec2.probes\" , \"func\" : \"instance_state\" , \"arguments\" : { \"state\" : \"\" } } } name : instance-state provider : arguments : state : '' func : instance_state module : chaosaws.ec2.probes type : python type : probe restart_instances \u00b6 Type action Module chaosaws.ec2.actions Name restart_instances Return list Restarts one or more EC2 instances. WARNING: If only an Availability Zone is provided, all instances in the provided AZ will be restarted. Additional filters may be used to narrow the scope: https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ec2.html#EC2.Client.describe_instances Signature: def restart_instances ( instance_ids : List [ str ] = None , az : str = None , filters : List [ Dict [ str , Any ]] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required instance_ids list null No az string null No filters list null No Usage: { \"name\" : \"restart-instances\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ec2.actions\" , \"func\" : \"restart_instances\" } } name : restart-instances provider : func : restart_instances module : chaosaws.ec2.actions type : python type : action start_instances \u00b6 Type action Module chaosaws.ec2.actions Name start_instances Return list Starts one or more EC2 instances. WARNING: If only an Availability Zone is provided, all instances in the provided AZ will be started. Additional filters may be used to narrow the scope: https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ec2.html#EC2.Client.describe_instances Signature: def start_instances ( instance_ids : List [ str ] = None , az : str = None , filters : List [ Dict [ str , Any ]] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required instance_ids list null No az string null No filters list null No Usage: { \"name\" : \"start-instances\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ec2.actions\" , \"func\" : \"start_instances\" } } name : start-instances provider : func : start_instances module : chaosaws.ec2.actions type : python type : action stop_instance \u00b6 Type action Module chaosaws.ec2.actions Name stop_instance Return list Stop a single EC2 instance. You may provide an instance id explicitly or, if you only specify the AZ, a random instance will be selected. If you need more control, you can also provide a list of filters following the documentation https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ec2.html#EC2.Client.describe_instances Signature: def stop_instance ( instance_id : str = None , az : str = None , force : bool = False , filters : List [ Dict [ str , Any ]] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required instance_id string null No az string null No force boolean false No filters list null No Usage: { \"name\" : \"stop-instance\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ec2.actions\" , \"func\" : \"stop_instance\" } } name : stop-instance provider : func : stop_instance module : chaosaws.ec2.actions type : python type : action stop_instances \u00b6 Type action Module chaosaws.ec2.actions Name stop_instances Return list Stop the given EC2 instances or, if none is provided, all instances of the given availability zone. If you need more control, you can also provide a list of filters following the documentation https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ec2.html#EC2.Client.describe_instances Signature: def stop_instances ( instance_ids : List [ str ] = None , az : str = None , filters : List [ Dict [ str , Any ]] = None , force : bool = False , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required instance_ids list null No az string null No filters list null No force boolean false No Usage: { \"name\" : \"stop-instances\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ec2.actions\" , \"func\" : \"stop_instances\" } } name : stop-instances provider : func : stop_instances module : chaosaws.ec2.actions type : python type : action terminate_instance \u00b6 Type action Module chaosaws.ec2.actions Name terminate_instance Return list Terminates a single EC2 instance. An instance may be targeted by specifying it by instance-id. If only the availability-zone is provided, a random instances in that AZ will be selected and terminated. For more control, please reference the available filters found: https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ec2.html#EC2.Client.describe_instances Signature: def terminate_instance ( instance_id : str = None , az : str = None , filters : List [ Dict [ str , Any ]] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required instance_id string null No az string null No filters list null No Usage: { \"name\" : \"terminate-instance\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ec2.actions\" , \"func\" : \"terminate_instance\" } } name : terminate-instance provider : func : terminate_instance module : chaosaws.ec2.actions type : python type : action terminate_instances \u00b6 Type action Module chaosaws.ec2.actions Name terminate_instances Return list Terminates multiple EC2 instances A set of instances may be targeted by providing them as the instance-ids. WARNING: If only an Availability Zone is specified, all instances in that AZ will be terminated. Additional filters may be used to narrow the scope: https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ec2.html#EC2.Client.describe_instances Signature: def terminate_instances ( instance_ids : List [ str ] = None , az : str = None , filters : List [ Dict [ str , Any ]] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required instance_ids list null No az string null No filters list null No Usage: { \"name\" : \"terminate-instances\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ec2.actions\" , \"func\" : \"terminate_instances\" } } name : terminate-instances provider : func : terminate_instances module : chaosaws.ec2.actions type : python type : action ecs \u00b6 are_all_desired_tasks_running \u00b6 Type probe Module chaosaws.ecs.probes Name are_all_desired_tasks_running Return boolean Checks to make sure desired and running tasks counts are equal Signature: def are_all_desired_tasks_running ( cluster : str , service : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required cluster string Yes service string Yes Usage: { \"name\" : \"are-all-desired-tasks-running\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ecs.probes\" , \"func\" : \"are_all_desired_tasks_running\" , \"arguments\" : { \"cluster\" : \"\" , \"service\" : \"\" } } } name : are-all-desired-tasks-running provider : arguments : cluster : '' service : '' func : are_all_desired_tasks_running module : chaosaws.ecs.probes type : python type : probe delete_cluster \u00b6 Type action Module chaosaws.ecs.actions Name delete_cluster Return mapping Delete an ECS cluster :param cluster: The ECS cluster name or ARN :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :return: Dict[str, Any] Signature: def delete_cluster ( cluster : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster string Yes Usage: { \"name\" : \"delete-cluster\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ecs.actions\" , \"func\" : \"delete_cluster\" , \"arguments\" : { \"cluster\" : \"\" } } } name : delete-cluster provider : arguments : cluster : '' func : delete_cluster module : chaosaws.ecs.actions type : python type : action delete_service \u00b6 Type action Module chaosaws.ecs.actions Name delete_service Return mapping Update a given ECS service by updating it to set the desired count of tasks to 0 then delete it. If not provided, a random one will be picked up regarding service_pattern , if provided, so that only service names matching the pattern would be be used. This should be a valid regex. You can specify a cluster by its ARN identifier or, if not provided, the default cluster will be picked up. Signature: def delete_service ( service : str = None , cluster : str = None , service_pattern : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required service string null No cluster string null No service_pattern string null No Usage: { \"name\" : \"delete-service\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ecs.actions\" , \"func\" : \"delete_service\" } } name : delete-service provider : func : delete_service module : chaosaws.ecs.actions type : python type : action deregister_container_instance \u00b6 Type action Module chaosaws.ecs.actions Name deregister_container_instance Return mapping Deregister an ECS container Warning: If using \u201cforce\u201d, Any tasks not deleted before deregistration will remain orphaned :param cluster: The ECS cluster name or ARN or ARN :param instance_id: The container instance id or ARN :param force: Force deregistraion of container instance :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :return: Dict[str, Any] Signature: def deregister_container_instance ( cluster : str , instance_id : str , force : bool = False , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster string Yes instance_id string Yes force boolean false No Usage: { \"name\" : \"deregister-container-instance\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ecs.actions\" , \"func\" : \"deregister_container_instance\" , \"arguments\" : { \"cluster\" : \"\" , \"instance_id\" : \"\" } } } name : deregister-container-instance provider : arguments : cluster : '' instance_id : '' func : deregister_container_instance module : chaosaws.ecs.actions type : python type : action describe_cluster \u00b6 Type probe Module chaosaws.ecs.probes Name describe_cluster Return mapping Returns AWS response describing the specified cluster Probe example: \u201csteady-state-hypothesis\u201d: { \u201ctitle\u201d: \u201cMyCluster has 3 running tasks\u201d, \u201cprobes\u201d: [{ \u201ctype\u201d: \u201cprobe\u201d, \u201cname\u201d: \u201cCluster running task count\u201d, \u201ctolerance\u201d: { \u201ctype\u201d: \u201cjsonpath\u201d, \u201cpath\u201d: $.clusters[0].runningTasksCount, \u201cexpect\u201d: 3 }, \u201cprovider\u201d: { \u201ctype\u201d: \u201cpython\u201d, \u201cmodule\u201d: \u201cchaosaws.ecs.probes\u201d, \u201cfunc\u201d: \u201cdescribe_cluster\u201d, \u201carguments\u201d: { \u201ccluster\u201d: \u201cMyCluster\u201d } } } } Full list of possible paths can be found: https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ecs.html#ECS.Client.describe_clusters Signature: def describe_cluster ( cluster : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster string Yes Usage: { \"name\" : \"describe-cluster\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ecs.probes\" , \"func\" : \"describe_cluster\" , \"arguments\" : { \"cluster\" : \"\" } } } name : describe-cluster provider : arguments : cluster : '' func : describe_cluster module : chaosaws.ecs.probes type : python type : probe describe_service \u00b6 Type probe Module chaosaws.ecs.probes Name describe_service Return mapping Returns AWS response describing the specified cluster service Probe example: \u201csteady-state-hypothesis\u201d: { \u201ctitle\u201d: \u201cMyService pending count is 1\u201d, \u201cprobes\u201d: [{ \u201ctype\u201d: \u201cprobe\u201d, \u201cname\u201d: \u201cService pending count\u201d, \u201ctolerance\u201d: { \u201ctype\u201d: \u201cjsonpath\u201d, \u201cpath\u201d: $.services[0].pendingCount, \u201cexpect\u201d: 1 }, \u201cprovider\u201d: { \u201ctype\u201d: \u201cpython\u201d, \u201cmodule\u201d: \u201cchaosaws.ecs.probes\u201d, \u201cfunc\u201d: \u201cdescribe_service\u201d, \u201carguments\u201d: { \u201ccluster\u201d: \u201cMyCluster\u201d, \u201cservice\u201d: \u201cMyService\u201d } } }] } Full list of possible paths can be found: https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ecs.html#ECS.Client.describe_services Signature: def describe_service ( cluster : str , service : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster string Yes service string Yes Usage: { \"name\" : \"describe-service\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ecs.probes\" , \"func\" : \"describe_service\" , \"arguments\" : { \"cluster\" : \"\" , \"service\" : \"\" } } } name : describe-service provider : arguments : cluster : '' service : '' func : describe_service module : chaosaws.ecs.probes type : python type : probe describe_tasks \u00b6 Type probe Module chaosaws.ecs.probes Name describe_tasks Return mapping Returns AWS response describing the tasks for a provided cluster Probe example: \u201csteady-state-hypothesis\u201d: { \u201ctitle\u201d: \u201cMyCluster tasks are healthy\u201d, \u201cprobes\u201d: [{ \u201ctype\u201d: \u201cprobe\u201d, \u201cname\u201d: \u201cfirst task is healthy\u201d, \u201ctolerance\u201d: { \u201ctype\u201d: \u201cjsonpath\u201d, \u201cpath\u201d: $.tasks[0].healthStatus, \u201cexpect\u201d: \u201cHEALTHY\u201d }, \u201cprovider\u201d: { \u201ctype\u201d: \u201cpython\u201d, \u201cmodule\u201d: \u201cchaosaws.ecs.probes\u201d, \u201cfunc\u201d: \u201cdescribe_tasks\u201d, \u201carguments\u201d: { \u201ccluster\u201d: \u201cMyCluster\u201d } } }] } Full list of possible paths can be found: https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ecs.html#ECS.Client.describe_tasks Signature: def describe_tasks ( cluster : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster string Yes Usage: { \"name\" : \"describe-tasks\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ecs.probes\" , \"func\" : \"describe_tasks\" , \"arguments\" : { \"cluster\" : \"\" } } } name : describe-tasks provider : arguments : cluster : '' func : describe_tasks module : chaosaws.ecs.probes type : python type : probe service_is_deploying \u00b6 Type probe Module chaosaws.ecs.probes Name service_is_deploying Return boolean Checks to make sure there is not an in progress deployment Signature: def service_is_deploying ( cluster : str , service : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required cluster string Yes service string Yes Usage: { \"name\" : \"service-is-deploying\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ecs.probes\" , \"func\" : \"service_is_deploying\" , \"arguments\" : { \"cluster\" : \"\" , \"service\" : \"\" } } } name : service-is-deploying provider : arguments : cluster : '' service : '' func : service_is_deploying module : chaosaws.ecs.probes type : python type : probe set_service_deployment_configuration \u00b6 Type action Module chaosaws.ecs.actions Name set_service_deployment_configuration Return mapping Sets the maximum healthy count and minimum healthy percentage values for a services deployment configuration :param cluster: The ECS cluster name or ARN :param service: The ECS service name :param maximum_percent: The upper limit on the number of tasks a service is allowed to have in RUNNING or PENDING during deployment :param minimum_healthy_percent: The lower limit on the number of tasks a service must keep in RUNNING to be considered healthy during deployment :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :return: Dict[str, Any] Signature: def set_service_deployment_configuration ( cluster : str , service : str , maximum_percent : int = 200 , minimum_healthy_percent : int = 100 , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster string Yes service string Yes maximum_percent integer 200 No minimum_healthy_percent integer 100 No Usage: { \"name\" : \"set-service-deployment-configuration\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ecs.actions\" , \"func\" : \"set_service_deployment_configuration\" , \"arguments\" : { \"cluster\" : \"\" , \"service\" : \"\" } } } name : set-service-deployment-configuration provider : arguments : cluster : '' service : '' func : set_service_deployment_configuration module : chaosaws.ecs.actions type : python type : action set_service_placement_strategy \u00b6 Type action Module chaosaws.ecs.actions Name set_service_placement_strategy Return mapping Sets the service\u2019s instance placement strategy :param cluster: The ECS cluster name or ARN :param service: The ECS service name :param placement_type: The type of placement strategy to employ (random, spread, or binpack) :param placement_field: The field to apply the strategy against (eg: \u201cattribute:ecs.availability-zone\u201d) :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :return: Dict[str, Any] Signature: def set_service_placement_strategy ( cluster : str , service : str , placement_type : str , placement_field : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster string Yes service string Yes placement_type string Yes placement_field string null No Usage: { \"name\" : \"set-service-placement-strategy\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ecs.actions\" , \"func\" : \"set_service_placement_strategy\" , \"arguments\" : { \"cluster\" : \"\" , \"service\" : \"\" , \"placement_type\" : \"\" } } } name : set-service-placement-strategy provider : arguments : cluster : '' placement_type : '' service : '' func : set_service_placement_strategy module : chaosaws.ecs.actions type : python type : action stop_random_tasks \u00b6 Type action Module chaosaws.ecs.actions Name stop_random_tasks Return list Stop a random number of tasks based on given task_count or task_percent You can specify a cluster by its ARN identifier or, if not provided, the default cluster will be picked up. :param cluster: The ECS cluster Name :param task_count: The number of tasks to stop :param task_percent: The percentage of total tasks to stop :param service: The ECS service name :param reason: An explanation of why the service was stopped :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :return: List[Dict[str, Any]] Signature: def stop_random_tasks ( cluster : str , task_count : int = None , task_percent : int = None , service : str = None , reason : str = 'Chaos Testing' , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required cluster string Yes task_count integer null No task_percent integer null No service string null No reason string \u201cChaos Testing\u201d No Usage: { \"name\" : \"stop-random-tasks\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ecs.actions\" , \"func\" : \"stop_random_tasks\" , \"arguments\" : { \"cluster\" : \"\" } } } name : stop-random-tasks provider : arguments : cluster : '' func : stop_random_tasks module : chaosaws.ecs.actions type : python type : action stop_task \u00b6 Type action Module chaosaws.ecs.actions Name stop_task Return mapping Stop a given ECS task instance. If no task_id provided, a random task of the given service is stopped. You can specify a cluster by its ARN identifier or, if not provided, the default cluster will be picked up. Signature: def stop_task ( cluster : str = None , task_id : str = None , service : str = None , reason : str = 'Chaos Testing' , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster string null No task_id string null No service string null No reason string \u201cChaos Testing\u201d No Usage: { \"name\" : \"stop-task\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ecs.actions\" , \"func\" : \"stop_task\" } } name : stop-task provider : func : stop_task module : chaosaws.ecs.actions type : python type : action tag_resource \u00b6 Type action Module chaosaws.ecs.actions Name tag_resource Return None Tags the provided resource(s) with provided tags ** For ECS resources, the long form ARN must be used https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-account-settings.html#ecs-resource-arn-timeline Example: { \u201ctags\u201d: [ {\u201ckey\u201d: \u201cMyTagKey\u201d, \u201cvalue\u201d: \u201cMyTagValue\u201d}, {\u201ckey\u201d: \u201cMyOtherTagKey\u201d, \u201cvalue\u201d: \u201cMyOtherTagValue\u201d} ], \u201cresource_arn\u201d: \u201carn:aws:ecs:us-east-1:123456789012:cluster/name\u201d } :param tags: A list of key/value pairs :param resource_arn: The ARN of the resource to tag. Valid resources: capacity providers, tasks, services, task definitions, clusters, and container instances :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :return: Dict[str, Any] Signature: def tag_resource ( tags : List [ Dict [ str , str ]], resource_arn : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required tags list Yes resource_arn string Yes Usage: { \"name\" : \"tag-resource\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ecs.actions\" , \"func\" : \"tag_resource\" , \"arguments\" : { \"tags\" : [], \"resource_arn\" : \"\" } } } name : tag-resource provider : arguments : resource_arn : '' tags : [] func : tag_resource module : chaosaws.ecs.actions type : python type : action untag_resource \u00b6 Type action Module chaosaws.ecs.actions Name untag_resource Return None Removes the given tags from the provided resource ** For ECS resources, the long form ARN must be used https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-account-settings.html#ecs-resource-arn-timeline Example: { \u201ctag_keys\u201d: [\u201cMyTagKey\u201d, \u201cMyOtherTagKey\u201d], \u201cresource_arn\u201d: \u201carn:aws:ecs:\u2026:service/cluster-name/service-name\u201d } :param tag_keys: A list of tag keys to remove :param resource_arn: The ARN of the resource to tag. Valid resources: capacity providers, tasks, services, task definitions, clusters, and container instances :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :return: Dict[str, Any] Signature: def untag_resource ( tag_keys : List [ str ], resource_arn : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required tag_keys list Yes resource_arn string Yes Usage: { \"name\" : \"untag-resource\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ecs.actions\" , \"func\" : \"untag_resource\" , \"arguments\" : { \"tag_keys\" : [], \"resource_arn\" : \"\" } } } name : untag-resource provider : arguments : resource_arn : '' tag_keys : [] func : untag_resource module : chaosaws.ecs.actions type : python type : action update_container_instances_state \u00b6 Type action Module chaosaws.ecs.actions Name update_container_instances_state Return mapping Modify the status of an ACTIVE ECS container instance :param cluster: The ECS cluster name or ARN :param container_instances: A list of container instance ids for ARNs :param status: The desired instance state (Valid States: ACTIVE, DRAINING) :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :return: Dict[str, Any] Signature: def update_container_instances_state ( cluster : str , container_instances : List [ str ], status : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster string Yes container_instances list Yes status string Yes Usage: { \"name\" : \"update-container-instances-state\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ecs.actions\" , \"func\" : \"update_container_instances_state\" , \"arguments\" : { \"cluster\" : \"\" , \"container_instances\" : [], \"status\" : \"\" } } } name : update-container-instances-state provider : arguments : cluster : '' container_instances : [] status : '' func : update_container_instances_state module : chaosaws.ecs.actions type : python type : action update_desired_count \u00b6 Type action Module chaosaws.ecs.actions Name update_desired_count Return mapping Set the number of desired tasks for an ECS service :param cluster: The ECS cluster name or ARN or ARN :param service: The ECS service name :param desired_count: The number of instantiation of the tasks to run :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :return: Dict[str, Any] Example: \u201cmethod\u201d: { \u201ctype\u201d: \u201caction\u201d, \u201cname\u201d: \u201cupdate service\u201d, \u201cprovider\u201d: { \u201ctype\u201d: \u201cpython\u201d, \u201cmodule\u201d: \u201cchaosaws.ecs.actions\u201d, \u201cfunc\u201d: \u201cupdate_desired_count\u201d, \u201carguments\u201d: { \u201ccluster\u201d: \u201cmy_cluster_name\u201d, \u201cservice\u201d: \u201cmy_service_name\u201d, \u201cdesired_count\u201d: 6 } } } Signature: def update_desired_count ( cluster : str , service : str , desired_count : int , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster string Yes service string Yes desired_count integer Yes Usage: { \"name\" : \"update-desired-count\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ecs.actions\" , \"func\" : \"update_desired_count\" , \"arguments\" : { \"cluster\" : \"\" , \"service\" : \"\" , \"desired_count\" : 0 } } } name : update-desired-count provider : arguments : cluster : '' desired_count : 0 service : '' func : update_desired_count module : chaosaws.ecs.actions type : python type : action eks \u00b6 create_cluster \u00b6 Type action Module chaosaws.eks.actions Name create_cluster Return mapping Create a new EKS cluster. Signature: def create_cluster ( name : str , role_arn : str , vpc_config : Dict [ str , Any ], version : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required name string Yes role_arn string Yes vpc_config mapping Yes version string null No Usage: { \"name\" : \"create-cluster\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.eks.actions\" , \"func\" : \"create_cluster\" , \"arguments\" : { \"name\" : \"\" , \"role_arn\" : \"\" , \"vpc_config\" : {} } } } name : create-cluster provider : arguments : name : '' role_arn : '' vpc_config : {} func : create_cluster module : chaosaws.eks.actions type : python type : action delete_cluster \u00b6 Type action Module chaosaws.eks.actions Name delete_cluster Return mapping Delete the given EKS cluster. Signature: def delete_cluster ( name : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required name string null No Usage: { \"name\" : \"delete-cluster\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.eks.actions\" , \"func\" : \"delete_cluster\" } } name : delete-cluster provider : func : delete_cluster module : chaosaws.eks.actions type : python type : action describe_cluster \u00b6 Type probe Module chaosaws.eks.probes Name describe_cluster Return mapping Describe an EKS cluster. Signature: def describe_cluster ( name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required name string Yes Usage: { \"name\" : \"describe-cluster\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.eks.probes\" , \"func\" : \"describe_cluster\" , \"arguments\" : { \"name\" : \"\" } } } name : describe-cluster provider : arguments : name : '' func : describe_cluster module : chaosaws.eks.probes type : python type : probe list_clusters \u00b6 Type probe Module chaosaws.eks.probes Name list_clusters Return mapping List EKS clusters available to the authenticated account. Signature: def list_clusters ( configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required Usage: { \"name\" : \"list-clusters\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.eks.probes\" , \"func\" : \"list_clusters\" } } name : list-clusters provider : func : list_clusters module : chaosaws.eks.probes type : python type : probe elasticache \u00b6 delete_cache_clusters \u00b6 Type action Module chaosaws.elasticache.actions Name delete_cache_clusters Return list Deletes one or more cache clusters and creates a final snapshot : cluster_ids: list: a list of one or more cache cluster ids final_snapshot_id: str: an identifier to give the final snapshot Signature: def delete_cache_clusters ( cluster_ids : List [ str ], final_snapshot_id : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required cluster_ids list Yes final_snapshot_id string null No Usage: { \"name\" : \"delete-cache-clusters\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.elasticache.actions\" , \"func\" : \"delete_cache_clusters\" , \"arguments\" : { \"cluster_ids\" : [] } } } name : delete-cache-clusters provider : arguments : cluster_ids : [] func : delete_cache_clusters module : chaosaws.elasticache.actions type : python type : action delete_replication_groups \u00b6 Type action Module chaosaws.elasticache.actions Name delete_replication_groups Return list Deletes one or more replication groups and creates a final snapshot : group_ids: list: a list of one or more replication group ids final_snapshot_id: str: an identifier to give the final snapshot retain_primary_cluster: bool (default: True): delete only the read replicas associated to the replication group, not the primary Signature: def delete_replication_groups ( group_ids : List [ str ], final_snapshot_id : str = None , retain_primary_cluster : bool = True , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required group_ids list Yes final_snapshot_id string null No retain_primary_cluster boolean true No Usage: { \"name\" : \"delete-replication-groups\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.elasticache.actions\" , \"func\" : \"delete_replication_groups\" , \"arguments\" : { \"group_ids\" : [] } } } name : delete-replication-groups provider : arguments : group_ids : [] func : delete_replication_groups module : chaosaws.elasticache.actions type : python type : action describe_cache_cluster \u00b6 Type probe Module chaosaws.elasticache.probes Name describe_cache_cluster Return mapping Returns cache cluster data for given cluster :param cluster_id: str: the name of the cache cluster :param show_node_info: bool: show associated nodes (default: False) :param configuration: Configuration :param secrets: Secrets :example: { \u201ctype\u201d: \u201cprobe\u201d, \u201cname\u201d: \u201cvalidate cache cluster engine\u201d, \u201ctolerance\u201d: { \u201ctype\u201d: \u201cjsonpath\u201d, \u201cpath\u201d: $.CacheClusters[0].Engine, \u201cexpect\u201d: \u201cmemcached\u201d }, \u201cprovider\u201d: { \u201ctype\u201d: \u201cpython\u201d, \u201cmodule\u201d: \u201cchaosaws.elasticache.probes\u201d, \u201cfunc\u201d: \u201cdescribe_cache_cluster\u201d, \u201carguments\u201d: { \u201ccluster_id\u201d: \u201cMyTestCluster\u201d } } } Full list of possible paths can be found: https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/elasticache.html#ElastiCache.Client.describe_cache_clusters Signature: def describe_cache_cluster ( cluster_id : str , show_node_info : bool = False , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster_id string Yes show_node_info boolean false No Usage: { \"name\" : \"describe-cache-cluster\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.elasticache.probes\" , \"func\" : \"describe_cache_cluster\" , \"arguments\" : { \"cluster_id\" : \"\" } } } name : describe-cache-cluster provider : arguments : cluster_id : '' func : describe_cache_cluster module : chaosaws.elasticache.probes type : python type : probe get_cache_node_count \u00b6 Type probe Module chaosaws.elasticache.probes Name get_cache_node_count Return integer Returns the number of cache nodes associated to the cluster :param cluster_id: str: the name of the cache cluster :param configuration: Configuration :param secrets: Secrets :example: { \u201ctype\u201d: \u201cprobe\u201d, \u201cname\u201d: \u201cvalidate cache node count\u201d, \u201ctolerance\u201d: 3, \u201cprovider\u201d: { \u201ctype\u201d: \u201cpython\u201d, \u201cmodule\u201d: \u201cchaosaws.elasticache.probes\u201d, \u201cfunc\u201d: \u201cget_cache_node_count\u201d, \u201carguments\u201d: { \u201ccluster_id\u201d: \u201cMyTestCluster\u201d } } } Signature: def get_cache_node_count ( cluster_id : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required cluster_id string Yes Usage: { \"name\" : \"get-cache-node-count\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.elasticache.probes\" , \"func\" : \"get_cache_node_count\" , \"arguments\" : { \"cluster_id\" : \"\" } } } name : get-cache-node-count provider : arguments : cluster_id : '' func : get_cache_node_count module : chaosaws.elasticache.probes type : python type : probe get_cache_node_status \u00b6 Type probe Module chaosaws.elasticache.probes Name get_cache_node_status Return string Returns the status of the given cache cluster :param cluster_id: str: the name of the cache cluster :param configuration: Configuration :param secrets: Secrets :example: { \u201ctype\u201d: \u201cprobe\u201d, \u201cname\u201d: \u201cvalidate cache node status\u201d, \u201ctolerance\u201d: \u201cavailable\u201d, \u201cprovider\u201d: { \u201ctype\u201d: \u201cpython\u201d, \u201cmodule\u201d: \u201cchaosaws.elasticache.probes\u201d, \u201cfunc\u201d: \u201cget_cache_node_status\u201d, \u201carguments\u201d: { \u201ccluster_id\u201d: \u201cMyTestCluster\u201d } } } Signature: def get_cache_node_status ( cluster_id : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> str : pass Arguments: Name Type Default Required cluster_id string Yes Usage: { \"name\" : \"get-cache-node-status\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.elasticache.probes\" , \"func\" : \"get_cache_node_status\" , \"arguments\" : { \"cluster_id\" : \"\" } } } name : get-cache-node-status provider : arguments : cluster_id : '' func : get_cache_node_status module : chaosaws.elasticache.probes type : python type : probe reboot_cache_clusters \u00b6 Type action Module chaosaws.elasticache.actions Name reboot_cache_clusters Return list Reboots one or more nodes in a cache cluster. If no node ids are supplied, all nodes in the cluster will be rebooted : cluster_ids: list: a list of one or more cache cluster ids node_ids: list: a list of one or more node ids in to the cluster Signature: def reboot_cache_clusters ( cluster_ids : List [ str ], node_ids : List [ str ] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required cluster_ids list Yes node_ids list null No Usage: { \"name\" : \"reboot-cache-clusters\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.elasticache.actions\" , \"func\" : \"reboot_cache_clusters\" , \"arguments\" : { \"cluster_ids\" : [] } } } name : reboot-cache-clusters provider : arguments : cluster_ids : [] func : reboot_cache_clusters module : chaosaws.elasticache.actions type : python type : action elbv2 \u00b6 all_targets_healthy \u00b6 Type probe Module chaosaws.elbv2.probes Name all_targets_healthy Return mapping Return true/false based on if all targets for listed target groups are healthy Signature: def all_targets_healthy ( tg_names : List [ str ], configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required tg_names list Yes Usage: { \"name\" : \"all-targets-healthy\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.elbv2.probes\" , \"func\" : \"all_targets_healthy\" , \"arguments\" : { \"tg_names\" : [] } } } name : all-targets-healthy provider : arguments : tg_names : [] func : all_targets_healthy module : chaosaws.elbv2.probes type : python type : probe delete_load_balancer \u00b6 Type action Module chaosaws.elbv2.actions Name delete_load_balancer Return None Deletes the provided load balancer(s). : - load_balancer_names: a list of load balancer names Signature: def delete_load_balancer ( load_balancer_names : List [ str ], configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required load_balancer_names list Yes Usage: { \"name\" : \"delete-load-balancer\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.elbv2.actions\" , \"func\" : \"delete_load_balancer\" , \"arguments\" : { \"load_balancer_names\" : [] } } } name : delete-load-balancer provider : arguments : load_balancer_names : [] func : delete_load_balancer module : chaosaws.elbv2.actions type : python type : action deregister_target \u00b6 Type action Module chaosaws.elbv2.actions Name deregister_target Return mapping Deregisters one random target from target group Signature: def deregister_target ( tg_name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required tg_name string Yes Usage: { \"name\" : \"deregister-target\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.elbv2.actions\" , \"func\" : \"deregister_target\" , \"arguments\" : { \"tg_name\" : \"\" } } } name : deregister-target provider : arguments : tg_name : '' func : deregister_target module : chaosaws.elbv2.actions type : python type : action set_security_groups \u00b6 Type action Module chaosaws.elbv2.actions Name set_security_groups Return list Changes the security groups for the specified load balancer(s). This action will replace the existing security groups on an application load balancer with the specified security groups. : - load_balancer_names: a list of load balancer names - security_group_ids: a list of security group ids returns: [ { \u2018LoadBalancerArn\u2019: \u2018string\u2019, \u2018SecurityGroupIds\u2019: [\u2018sg-0000000\u2019, \u2018sg-0000001\u2019] }, \u2026 ] Signature: def set_security_groups ( load_balancer_names : List [ str ], security_group_ids : List [ str ], configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required load_balancer_names list Yes security_group_ids list Yes Usage: { \"name\" : \"set-security-groups\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.elbv2.actions\" , \"func\" : \"set_security_groups\" , \"arguments\" : { \"load_balancer_names\" : [], \"security_group_ids\" : [] } } } name : set-security-groups provider : arguments : load_balancer_names : [] security_group_ids : [] func : set_security_groups module : chaosaws.elbv2.actions type : python type : action set_subnets \u00b6 Type action Module chaosaws.elbv2.actions Name set_subnets Return list Changes the subnets for the specified application load balancer(s) This action will replace the existing security groups on an application load balancer with the specified security groups. : - load_balancer_names: a list of load balancer names - subnet_ids: a list of subnet ids returns: [ { \u2018LoadBalancerArn\u2019: \u2018string\u2019, \u2018AvailabilityZones\u2019: { \u2018ZoneName\u2019: \u2018string\u2019, \u2018SubnetId\u2019: \u2018string\u2019, \u2018LoadBalancerAddresses\u2019: [ { \u2018IpAddress\u2019: \u2018string\u2019, \u2018AllocationId\u2019: \u2018string\u2019 } ] } }, \u2026 ] Signature: def set_subnets ( load_balancer_names : List [ str ], subnet_ids : List [ str ], configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required load_balancer_names list Yes subnet_ids list Yes Usage: { \"name\" : \"set-subnets\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.elbv2.actions\" , \"func\" : \"set_subnets\" , \"arguments\" : { \"load_balancer_names\" : [], \"subnet_ids\" : [] } } } name : set-subnets provider : arguments : load_balancer_names : [] subnet_ids : [] func : set_subnets module : chaosaws.elbv2.actions type : python type : action targets_health_count \u00b6 Type probe Module chaosaws.elbv2.probes Name targets_health_count Return mapping Count of healthy/unhealthy targets per targetgroup Signature: def targets_health_count ( tg_names : List [ str ], configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required tg_names list Yes Usage: { \"name\" : \"targets-health-count\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.elbv2.probes\" , \"func\" : \"targets_health_count\" , \"arguments\" : { \"tg_names\" : [] } } } name : targets-health-count provider : arguments : tg_names : [] func : targets_health_count module : chaosaws.elbv2.probes type : python type : probe emr \u00b6 describe_cluster \u00b6 Type probe Module chaosaws.emr.probes Name describe_cluster Return mapping Describe a single EMR cluster :param cluster_id: The cluster id :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :return: Dict[str, Any] Signature: def describe_cluster ( cluster_id : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster_id string Yes Usage: { \"name\" : \"describe-cluster\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.emr.probes\" , \"func\" : \"describe_cluster\" , \"arguments\" : { \"cluster_id\" : \"\" } } } name : describe-cluster provider : arguments : cluster_id : '' func : describe_cluster module : chaosaws.emr.probes type : python type : probe describe_instance_fleet \u00b6 Type probe Module chaosaws.emr.probes Name describe_instance_fleet Return mapping Describe a single EMR instance fleet :param cluster_id: The cluster id :param fleet_id: The instance fleet id :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :return: Dict[str, Any] Signature: def describe_instance_fleet ( cluster_id : str , fleet_id : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster_id string Yes fleet_id string Yes Usage: { \"name\" : \"describe-instance-fleet\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.emr.probes\" , \"func\" : \"describe_instance_fleet\" , \"arguments\" : { \"cluster_id\" : \"\" , \"fleet_id\" : \"\" } } } name : describe-instance-fleet provider : arguments : cluster_id : '' fleet_id : '' func : describe_instance_fleet module : chaosaws.emr.probes type : python type : probe describe_instance_group \u00b6 Type probe Module chaosaws.emr.probes Name describe_instance_group Return mapping Describe a single EMR instance group :param cluster_id: The cluster id :param group_id: The instance group id :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :return: Dict[str, Any] Signature: def describe_instance_group ( cluster_id : str , group_id : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster_id string Yes group_id string Yes Usage: { \"name\" : \"describe-instance-group\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.emr.probes\" , \"func\" : \"describe_instance_group\" , \"arguments\" : { \"cluster_id\" : \"\" , \"group_id\" : \"\" } } } name : describe-instance-group provider : arguments : cluster_id : '' group_id : '' func : describe_instance_group module : chaosaws.emr.probes type : python type : probe list_cluster_fleet_instances \u00b6 Type probe Module chaosaws.emr.probes Name list_cluster_fleet_instances Return mapping Get a list of instance fleet instances associated to the EMR cluster :param cluster_id: The cluster id :param fleet_id: The instance fleet id :param fleet_type: The instance fleet type :param instance_states: A list of instance states to include :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :return: Dict[str, Any] Signature: def list_cluster_fleet_instances ( cluster_id : str , fleet_id : str , fleet_type : str = None , instance_states : List [ str ] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster_id string Yes fleet_id string Yes fleet_type string null No instance_states list null No Usage: { \"name\" : \"list-cluster-fleet-instances\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.emr.probes\" , \"func\" : \"list_cluster_fleet_instances\" , \"arguments\" : { \"cluster_id\" : \"\" , \"fleet_id\" : \"\" } } } name : list-cluster-fleet-instances provider : arguments : cluster_id : '' fleet_id : '' func : list_cluster_fleet_instances module : chaosaws.emr.probes type : python type : probe list_cluster_group_instances \u00b6 Type probe Module chaosaws.emr.probes Name list_cluster_group_instances Return mapping Get a list of instance group instances associated to the EMR cluster :param cluster_id: The cluster id :param group_id: The instance group id :param group_type: The instance group type :param instance_states: A list of instance states to include :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :return: Dict[str, Any] Signature: def list_cluster_group_instances ( cluster_id : str , group_id : str , group_type : str = None , instance_states : List [ str ] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster_id string Yes group_id string Yes group_type string null No instance_states list null No Usage: { \"name\" : \"list-cluster-group-instances\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.emr.probes\" , \"func\" : \"list_cluster_group_instances\" , \"arguments\" : { \"cluster_id\" : \"\" , \"group_id\" : \"\" } } } name : list-cluster-group-instances provider : arguments : cluster_id : '' group_id : '' func : list_cluster_group_instances module : chaosaws.emr.probes type : python type : probe modify_cluster \u00b6 Type action Module chaosaws.emr.actions Name modify_cluster Return mapping Set the step concurrency level on the provided cluster :param cluster_id: The cluster id :param concurrency: The number of steps to execute concurrently (1 - 256) :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :return: Dict[str, Any] Signature: def modify_cluster ( cluster_id : str , concurrency : int , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster_id string Yes concurrency integer Yes Usage: { \"name\" : \"modify-cluster\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.emr.actions\" , \"func\" : \"modify_cluster\" , \"arguments\" : { \"cluster_id\" : \"\" , \"concurrency\" : 0 } } } name : modify-cluster provider : arguments : cluster_id : '' concurrency : 0 func : modify_cluster module : chaosaws.emr.actions type : python type : action modify_instance_fleet \u00b6 Type action Module chaosaws.emr.actions Name modify_instance_fleet Return mapping Modify the on-demand and spot capacities for an instance fleet :param cluster_id: The cluster id :param fleet_id: The instance fleet id :param on_demand_capacity: Target capacity of on-demand units :param spot_capacity: Target capacity of spot units :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :return: Dict[str, Any] Signature: def modify_instance_fleet ( cluster_id : str , fleet_id : str , on_demand_capacity : int = None , spot_capacity : int = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster_id string Yes fleet_id string Yes on_demand_capacity integer null No spot_capacity integer null No Usage: { \"name\" : \"modify-instance-fleet\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.emr.actions\" , \"func\" : \"modify_instance_fleet\" , \"arguments\" : { \"cluster_id\" : \"\" , \"fleet_id\" : \"\" } } } name : modify-instance-fleet provider : arguments : cluster_id : '' fleet_id : '' func : modify_instance_fleet module : chaosaws.emr.actions type : python type : action modify_instance_groups_instance_count \u00b6 Type action Module chaosaws.emr.actions Name modify_instance_groups_instance_count Return mapping Modify the number of instances in an instance group :param cluster_id: The cluster id :param group_id: The instance group id :param instance_count: The target size for the instance group :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :return: Dict[str, Any] Signature: def modify_instance_groups_instance_count ( cluster_id : str , group_id : str , instance_count : int , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster_id string Yes group_id string Yes instance_count integer Yes Usage: { \"name\" : \"modify-instance-groups-instance-count\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.emr.actions\" , \"func\" : \"modify_instance_groups_instance_count\" , \"arguments\" : { \"cluster_id\" : \"\" , \"group_id\" : \"\" , \"instance_count\" : 0 } } } name : modify-instance-groups-instance-count provider : arguments : cluster_id : '' group_id : '' instance_count : 0 func : modify_instance_groups_instance_count module : chaosaws.emr.actions type : python type : action modify_instance_groups_shrink_policy \u00b6 Type action Module chaosaws.emr.actions Name modify_instance_groups_shrink_policy Return mapping Modify an instance groups shrink operations :param cluster_id: The cluster id :param group_id: The instance group id :param decommission_timeout: Timeout for decommissioning an instance :param terminate_instances: Instance id list to terminate when shrinking :param protect_instances: Instance id list to protect when shrinking :param termination_timeout: Override for list of instances to terminate :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :return: Dict[str, Any] Signature: def modify_instance_groups_shrink_policy ( cluster_id : str , group_id : str , decommission_timeout : int = None , terminate_instances : List [ str ] = None , protect_instances : List [ str ] = None , termination_timeout : int = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster_id string Yes group_id string Yes decommission_timeout integer null No terminate_instances list null No protect_instances list null No termination_timeout integer null No Usage: { \"name\" : \"modify-instance-groups-shrink-policy\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.emr.actions\" , \"func\" : \"modify_instance_groups_shrink_policy\" , \"arguments\" : { \"cluster_id\" : \"\" , \"group_id\" : \"\" } } } name : modify-instance-groups-shrink-policy provider : arguments : cluster_id : '' group_id : '' func : modify_instance_groups_shrink_policy module : chaosaws.emr.actions type : python type : action iam \u00b6 attach_role_policy \u00b6 Type action Module chaosaws.iam.actions Name attach_role_policy Return mapping Attach a role to a policy. Signature: def attach_role_policy ( arn : str , role_name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required arn string Yes role_name string Yes Usage: { \"name\" : \"attach-role-policy\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.iam.actions\" , \"func\" : \"attach_role_policy\" , \"arguments\" : { \"arn\" : \"\" , \"role_name\" : \"\" } } } name : attach-role-policy provider : arguments : arn : '' role_name : '' func : attach_role_policy module : chaosaws.iam.actions type : python type : action create_policy \u00b6 Type action Module chaosaws.iam.actions Name create_policy Return mapping Create a new IAM policy Signature: def create_policy ( name : str , policy : Dict [ str , Any ], path : str = '/' , description : str = '' , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required name string Yes policy mapping Yes path string \u201d/\u201d No description string \u201d\u201c No Usage: { \"name\" : \"create-policy\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.iam.actions\" , \"func\" : \"create_policy\" , \"arguments\" : { \"name\" : \"\" , \"policy\" : {} } } } name : create-policy provider : arguments : name : '' policy : {} func : create_policy module : chaosaws.iam.actions type : python type : action detach_role_policy \u00b6 Type action Module chaosaws.iam.actions Name detach_role_policy Return mapping Detach a role from a policy. Signature: def detach_role_policy ( arn : str , role_name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required arn string Yes role_name string Yes Usage: { \"name\" : \"detach-role-policy\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.iam.actions\" , \"func\" : \"detach_role_policy\" , \"arguments\" : { \"arn\" : \"\" , \"role_name\" : \"\" } } } name : detach-role-policy provider : arguments : arn : '' role_name : '' func : detach_role_policy module : chaosaws.iam.actions type : python type : action get_policy \u00b6 Type probe Module chaosaws.iam.probes Name get_policy Return boolean Get a policy by its ARN Signature: def get_policy ( arn : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required arn string Yes Usage: { \"name\" : \"get-policy\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.iam.probes\" , \"func\" : \"get_policy\" , \"arguments\" : { \"arn\" : \"\" } } } name : get-policy provider : arguments : arn : '' func : get_policy module : chaosaws.iam.probes type : python type : probe rds \u00b6 cluster_membership_count \u00b6 Type probe Module chaosaws.rds.probes Name cluster_membership_count Return integer Signature: def cluster_membership_count ( cluster_id : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required cluster_id string Yes Usage: { \"name\" : \"cluster-membership-count\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.rds.probes\" , \"func\" : \"cluster_membership_count\" , \"arguments\" : { \"cluster_id\" : \"\" } } } name : cluster-membership-count provider : arguments : cluster_id : '' func : cluster_membership_count module : chaosaws.rds.probes type : python type : probe cluster_status \u00b6 Type probe Module chaosaws.rds.probes Name cluster_status Return Union[str, List[str]] Signature: def cluster_status ( cluster_id : str = None , filters : List [ Dict [ str , Any ]] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Union [ str , List [ str ]]: pass Arguments: Name Type Default Required cluster_id string null No filters list null No Usage: { \"name\" : \"cluster-status\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.rds.probes\" , \"func\" : \"cluster_status\" } } name : cluster-status provider : func : cluster_status module : chaosaws.rds.probes type : python type : probe delete_db_cluster \u00b6 Type action Module chaosaws.rds.actions Name delete_db_cluster Return mapping Deletes an Aurora DB cluster db_cluster_identifier: the identifier of the cluster to delete skip_final_snapshot: boolean (true): determines whether or not to perform a final snapshot of the cluster before deletion db_snapshot_identifier: the identifier to give the final rds snapshot Signature: def delete_db_cluster ( db_cluster_identifier : str , skip_final_snapshot : bool = True , db_snapshot_identifier : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required db_cluster_identifier string Yes skip_final_snapshot boolean true No db_snapshot_identifier string null No Usage: { \"name\" : \"delete-db-cluster\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.rds.actions\" , \"func\" : \"delete_db_cluster\" , \"arguments\" : { \"db_cluster_identifier\" : \"\" } } } name : delete-db-cluster provider : arguments : db_cluster_identifier : '' func : delete_db_cluster module : chaosaws.rds.actions type : python type : action delete_db_cluster_endpoint \u00b6 Type action Module chaosaws.rds.actions Name delete_db_cluster_endpoint Return mapping Deletes the custom endpoint of an Aurora cluster db_cluster_identifier: the identifier of the cluster to delete the endpoint from Signature: def delete_db_cluster_endpoint ( db_cluster_identifier : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required db_cluster_identifier string Yes Usage: { \"name\" : \"delete-db-cluster-endpoint\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.rds.actions\" , \"func\" : \"delete_db_cluster_endpoint\" , \"arguments\" : { \"db_cluster_identifier\" : \"\" } } } name : delete-db-cluster-endpoint provider : arguments : db_cluster_identifier : '' func : delete_db_cluster_endpoint module : chaosaws.rds.actions type : python type : action delete_db_instance \u00b6 Type action Module chaosaws.rds.actions Name delete_db_instance Return mapping Deletes a RDS instance db_instance_identifier: the identifier of the RDS instance to delete skip_final_snapshot: boolean (true): determines whether or not to perform a final snapshot of the rds instance before deletion db_snapshot_identifier: the identifier to give the final rds snapshot delete_automated_backups: boolean (true): determines if the automated backups of the rds instance are deleted immediately Signature: def delete_db_instance ( db_instance_identifier : str , skip_final_snapshot : bool = True , db_snapshot_identifier : str = None , delete_automated_backups : bool = True , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required db_instance_identifier string Yes skip_final_snapshot boolean true No db_snapshot_identifier string null No delete_automated_backups boolean true No Usage: { \"name\" : \"delete-db-instance\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.rds.actions\" , \"func\" : \"delete_db_instance\" , \"arguments\" : { \"db_instance_identifier\" : \"\" } } } name : delete-db-instance provider : arguments : db_instance_identifier : '' func : delete_db_instance module : chaosaws.rds.actions type : python type : action failover_db_cluster \u00b6 Type action Module chaosaws.rds.actions Name failover_db_cluster Return mapping Forces a failover for a DB cluster. Signature: def failover_db_cluster ( db_cluster_identifier : str , target_db_instance_identifier : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required db_cluster_identifier string Yes target_db_instance_identifier string null No Usage: { \"name\" : \"failover-db-cluster\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.rds.actions\" , \"func\" : \"failover_db_cluster\" , \"arguments\" : { \"db_cluster_identifier\" : \"\" } } } name : failover-db-cluster provider : arguments : db_cluster_identifier : '' func : failover_db_cluster module : chaosaws.rds.actions type : python type : action instance_status \u00b6 Type probe Module chaosaws.rds.probes Name instance_status Return Union[str, List[str]] Signature: def instance_status ( instance_id : str = None , filters : List [ Dict [ str , Any ]] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Union [ str , List [ str ]]: pass Arguments: Name Type Default Required instance_id string null No filters list null No Usage: { \"name\" : \"instance-status\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.rds.probes\" , \"func\" : \"instance_status\" } } name : instance-status provider : func : instance_status module : chaosaws.rds.probes type : python type : probe reboot_db_instance \u00b6 Type action Module chaosaws.rds.actions Name reboot_db_instance Return mapping Forces a reboot of your DB instance. Signature: def reboot_db_instance ( db_instance_identifier : str , force_failover : bool = False , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required db_instance_identifier string Yes force_failover boolean false No Usage: { \"name\" : \"reboot-db-instance\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.rds.actions\" , \"func\" : \"reboot_db_instance\" , \"arguments\" : { \"db_instance_identifier\" : \"\" } } } name : reboot-db-instance provider : arguments : db_instance_identifier : '' func : reboot_db_instance module : chaosaws.rds.actions type : python type : action stop_db_cluster \u00b6 Type action Module chaosaws.rds.actions Name stop_db_cluster Return mapping Stop a RDS Cluster db_cluster_identifier: the identifier of the RDS cluster to stop Signature: def stop_db_cluster ( db_cluster_identifier : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required db_cluster_identifier string Yes Usage: { \"name\" : \"stop-db-cluster\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.rds.actions\" , \"func\" : \"stop_db_cluster\" , \"arguments\" : { \"db_cluster_identifier\" : \"\" } } } name : stop-db-cluster provider : arguments : db_cluster_identifier : '' func : stop_db_cluster module : chaosaws.rds.actions type : python type : action stop_db_instance \u00b6 Type action Module chaosaws.rds.actions Name stop_db_instance Return mapping Stops a RDS DB instance db_instance_identifier: the instance identifier of the RDS instance db_snapshot_identifier: the name of the DB snapshot made before stop Signature: def stop_db_instance ( db_instance_identifier : str , db_snapshot_identifier : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required db_instance_identifier string Yes db_snapshot_identifier string null No Usage: { \"name\" : \"stop-db-instance\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.rds.actions\" , \"func\" : \"stop_db_instance\" , \"arguments\" : { \"db_instance_identifier\" : \"\" } } } name : stop-db-instance provider : arguments : db_instance_identifier : '' func : stop_db_instance module : chaosaws.rds.actions type : python type : action route53 \u00b6 associate_vpc_with_zone \u00b6 Type action Module chaosaws.route53.actions Name associate_vpc_with_zone Return mapping Associate a VPC with a private hosted zone :param zone_id: The hosted zone id :param vpc_id: The id of the vpc :param vpc_region: The region of the vpc :param configuration: access values used by actions/probes :param comment: a comment regarding the request :param secrets: values that need to be passed on to actions/probes :returns: Dict[str, Any] Signature: def associate_vpc_with_zone ( zone_id : str , vpc_id : str , vpc_region : str , comment : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required zone_id string Yes vpc_id string Yes vpc_region string Yes comment string null No Usage: { \"name\" : \"associate-vpc-with-zone\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.route53.actions\" , \"func\" : \"associate_vpc_with_zone\" , \"arguments\" : { \"zone_id\" : \"\" , \"vpc_id\" : \"\" , \"vpc_region\" : \"\" } } } name : associate-vpc-with-zone provider : arguments : vpc_id : '' vpc_region : '' zone_id : '' func : associate_vpc_with_zone module : chaosaws.route53.actions type : python type : action disassociate_vpc_from_zone \u00b6 Type action Module chaosaws.route53.actions Name disassociate_vpc_from_zone Return mapping Remove an association between a VPC and a private hosted zone :param zone_id: The hosted zone id :param vpc_id: The id of the vpc :param vpc_region: The region of the vpc :param comment: A note regarding the disassociation request :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :returns: Dict[str, Any] Signature: def disassociate_vpc_from_zone ( zone_id : str , vpc_id : str , vpc_region : str , comment : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required zone_id string Yes vpc_id string Yes vpc_region string Yes comment string null No Usage: { \"name\" : \"disassociate-vpc-from-zone\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.route53.actions\" , \"func\" : \"disassociate_vpc_from_zone\" , \"arguments\" : { \"zone_id\" : \"\" , \"vpc_id\" : \"\" , \"vpc_region\" : \"\" } } } name : disassociate-vpc-from-zone provider : arguments : vpc_id : '' vpc_region : '' zone_id : '' func : disassociate_vpc_from_zone module : chaosaws.route53.actions type : python type : action ssm \u00b6 create_document \u00b6 Type action Module chaosaws.ssm.actions Name create_document Return mapping creates a Systems Manager (SSM) document. An SSM document defines the actions that SSM performs on your managed. For more information about SSM documents: https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-ssm-docs.html https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ssm.html#SSM.Client.create_document Signature: def create_document ( path_content : str , name : str , version_name : str = None , document_type : str = None , document_format : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required path_content string Yes name string Yes version_name string null No document_type string null No document_format string null No Usage: { \"name\" : \"create-document\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ssm.actions\" , \"func\" : \"create_document\" , \"arguments\" : { \"path_content\" : \"\" , \"name\" : \"\" } } } name : create-document provider : arguments : name : '' path_content : '' func : create_document module : chaosaws.ssm.actions type : python type : action delete_document \u00b6 Type action Module chaosaws.ssm.actions Name delete_document Return mapping creates a Systems Manager (SSM) document. An SSM document defines the actions that SSM performs on your managed. For more information about SSM documents: https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-ssm-docs.html https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ssm.html#SSM.Client.create_document Signature: def delete_document ( name : str , version_name : str = None , force : bool = True , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required name string Yes version_name string null No force boolean true No Usage: { \"name\" : \"delete-document\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ssm.actions\" , \"func\" : \"delete_document\" , \"arguments\" : { \"name\" : \"\" } } } name : delete-document provider : arguments : name : '' func : delete_document module : chaosaws.ssm.actions type : python type : action send_command \u00b6 Type action Module chaosaws.ssm.actions Name send_command Return mapping Runs commands on one or more managed instances. An SSM document defines the actions that SSM performs on your managed. For more information about SSM SendCommand: https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_SendCommand.html https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ssm.html#SSM.Client.send_command Signature: def send_command ( document_name : str , targets : List [ Dict [ str , Any ]] = None , document_version : str = None , parameters : Dict [ str , Any ] = None , timeout_seconds : int = None , max_concurrency : str = None , max_errors : str = None , region : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required document_name string Yes targets list null No document_version string null No parameters mapping null No timeout_seconds integer null No max_concurrency string null No max_errors string null No region string null No Usage: { \"name\" : \"send-command\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ssm.actions\" , \"func\" : \"send_command\" , \"arguments\" : { \"document_name\" : \"\" } } } name : send-command provider : arguments : document_name : '' func : send_command module : chaosaws.ssm.actions type : python type : action","title":"AWS"},{"location":"drivers/aws/#extension-chaosaws","text":"Version 0.16.0 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-aws This project is a collection of actions and probes , gathered as an extension to the Chaos Toolkit .","title":"Extension chaosaws"},{"location":"drivers/aws/#install","text":"This package requires Python 3.5+ To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install -U chaostoolkit-aws","title":"Install"},{"location":"drivers/aws/#usage","text":"To use the probes and actions from this package, add the following to your experiment file: { \"name\" : \"stop-an-ec2-instance\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ec2.actions\" , \"func\" : \"stop_instance\" , \"arguments\" : { \"instance_id\" : \"i-123456\" } } }, { \"name\" : \"create-a-new-policy\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.iam.actions\" , \"func\" : \"create_policy\" , \"arguments\" : { \"name\" : \"mypolicy\" , \"path\" : \"user/Jane\" , \"policy\" : { \"Version\" : \"2012-10-17\" , \"Statement\" : [ { \"Effect\" : \"Allow\" , \"Action\" : [ \"s3:ListAllMyBuckets\" , \"s3:GetBucketLocation\" ], \"Resource\" : \"arn:aws:s3:::*\" } ] } } } } Or select one at random from an AZ: { \"name\" : \"stop-an-ec2-instance-in-az-at-random\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ec2.actions\" , \"func\" : \"stop_instance\" , \"arguments\" : { \"az\" : \"us-west-1\" } } } That\u2019s it! Please explore the code to see existing probes and actions.","title":"Usage"},{"location":"drivers/aws/#configuration","text":"","title":"Configuration"},{"location":"drivers/aws/#credentials","text":"This extension uses the boto3 library under the hood. This library expects that you have properly configured your environment to connect and authenticate with the AWS services.","title":"Credentials"},{"location":"drivers/aws/#use-default-profile-from-awscredentials-or-awsconfig","text":"This is the most basic case, assuming your default profile is properly configured in ~/.aws/credentials (or ~/.aws/config ), then you do not need to pass any specific credentials to the experiment.","title":"Use default profile from ~/.aws/credentials or ~/.aws/config"},{"location":"drivers/aws/#use-a-non-default-profile-from-awscredentials-or-awsconfig","text":"Assuming you have configure a profile in your ~/.aws/credentials (or ~/.aws/config ) file, you may declare it in your experiment as follows: { \"configuration\" : { \"aws_profile_name\" : \"dev\" } } Your ~/.aws/credentials should look like this: [dev] aws_access_key_id = XYZ aws_secret_access_key = UIOPIY Or, your ~/.aws/config should look like this: [profile dev] output = json aws_access_key_id = XYZ aws_secret_access_key = UIOPIY","title":"Use a non-default profile from ~/.aws/credentials or ~/.aws/config"},{"location":"drivers/aws/#assume-an-arn-role-from-a-non-default-profile","text":"Assuming you have configure a profile in your ~/.aws/config file with a specific ARN role you want to assume during the run: { \"configuration\" : { \"aws_profile_name\" : \"dev\" } } Your ~/.aws/config should look like this: [default] output = json [profile dev] role_arn = arn:aws:iam::XXXXXXX:role/role-name source_profile = default","title":"Assume an ARN role from a non-default profile"},{"location":"drivers/aws/#assume-an-arn-role-from-within-the-experiment","text":"You mays also assume a role by declaring the role ARN in the experiment directly. In that case, the profile has no impact if you also set it. \"configuration\" : { \"aws_assume_role_arn\" : \"arn:aws:iam::XXXXXXX:role/role-name\" , \"aws_assume_role_session_name\" : \"my-chaos\" } The aws_assume_role_session_name key is optional and will be set to \"ChaosToolkit\" when not provided. When this approach is used, the extension performs a assume role call against the AWS STS service to fetch credentials dynamically.","title":"Assume an ARN role from within the experiment"},{"location":"drivers/aws/#pass-credentials-explicitely","text":"You can pass the credentials as a secret to the experiment definition as follows: { \"secrets\" : { \"aws\" : { \"aws_access_key_id\" : \"your key\" , \"aws_secret_access_key\" : \"access key\" , \"aws_session_token\" : \"token\" , } } } Note that the token is optional. Then, use it as follows: { \"name\" : \"stop-an-ec2-instance\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ec2.actions\" , \"func\" : \"stop_instance\" , \"secrets\" : [ \"aws\" ], \"arguments\" : { \"instance_id\" : \"i-123456\" } } }","title":"Pass credentials explicitely"},{"location":"drivers/aws/#setting-the-region","text":"In additon to the authentication credentials, you must configure the region against which you want to use. You can either declare it at the top level of the experiment, add: { \"configuration\" : { \"aws_region\" : \"us-east-1\" } } or { \"configuration\" : { \"aws_region\" : { \"env\" : \"type\" , \"key\" : \"AWS_REGION\" } } } But you can also simply set either AWS_REGION or AWS_DEFAULT_REGION in your terminal session without declaring anything in the experiment. If none of these are set, your experiment will likely fail.","title":"Setting the region"},{"location":"drivers/aws/#contribute","text":"If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. The Chaos Toolkit projects require all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR.","title":"Contribute"},{"location":"drivers/aws/#develop","text":"If you wish to develop on this project, make sure to install the development dependencies. But first, create a virtual environment and then install those dependencies. $ pip install -r requirements-dev.txt -r requirements.txt Then, point your environment to this directory: $ python setup.py develop Now, you can edit the files and they will be automatically be seen by your environment, even when running from the chaos command locally.","title":"Develop"},{"location":"drivers/aws/#test","text":"To run the tests for the project execute the following: $ pytest","title":"Test"},{"location":"drivers/aws/#add-new-aws-api-support","text":"Once you have setup your environment, you can start adding new AWS API support by adding new actions, probes and entire sub-packages for those.","title":"Add new AWS API Support"},{"location":"drivers/aws/#services-supported-by-boto","text":"This package relies on boto3 to wrap the API calls into a fluent Python API. Some newer AWS services are not yet available in boto3, in that case, you should read the next section. Let\u2019s say you want to support a new action in the EC2 sub-package. Start by creating a new function in ec2/actions.py : from chaoslib.types import Configuration , Secrets from chaosaws import aws_client from chaosaws.types import AWSResponse def reboot_instance ( instance_id : str , dry_run : bool = False , configuration : Configuration = None , secrets : Secrets = None ) -> AWSResponse : \"\"\" Reboot a given EC2 instance. \"\"\" client = aws_client ( 'ec2' , configuration , secrets ) return client . reboot_instances ( InstanceIds = [ instance_id ], DryRun = dry_run ) As you can see, the actual code is straightforward. You first create a EC2 client and simply call the appropriate method on that client with the expected arguments. We return the action as-is so that it can be logged by the chaostoolkit, or even be used as part of a steady-state hypothesis probe (if this was a probe, not action that is). You could decide to make more than one AWS API call but, it is better to keep it simple so that composition is easier from the experiment. Nonetheless, you may also compose those directly into a single action as well for specific use-cases. Please refer to the Chaos Toolkit documentation to learn more about the configuration and secrets objects. Once you have implemented that action, you must create at least one unit test for it in the tests/ec2/test_ec2_actions.py test module. For example: from chaosaws.ec2.actions import reboot_instancex @patch ( 'chaosaws.ec2.actions.aws_client' , autospec = True ) def test_reboot_instance ( aws_client ): client = MagicMock () aws_client . return_value = client inst_id = \"i-1234567890abcdef0\" response = reboot_instance ( inst_id ) client . reboot_instances . assert_called_with ( InstanceIds = [ inst_id ], DryRun = False ) By using the built-in Python module to mock objects , we can mock the EC2 client and assert that we do indeed call the appropriate method with the right arguments. You are encouraged to write more than a single test for various conditions. Finally, should you choose to add support for a new AWS API resource altogether, you should create the according sub-package.","title":"Services supported by boto"},{"location":"drivers/aws/#services-not-supported-by-boto-new-aws-features","text":"If the support you want to provide is for a new AWS service that boto does not support yet, this requires direct call to the API endpoint via the requests package. Say we have a new service, not yet supported by boto3 from chaoslib.types import Configuration , Secrets from chaosaws import signed_api_call from chaosaws.types import AWSResponse def terminate_worker_node ( worker_node_id : str , configuration : Configuration = None , secrets : Secrets = None ) -> AWSResponse : \"\"\" Terminate a worker node. \"\"\" params = { \"DryRun\" : True , \"WorkerNodeId.1\" : worker_node_id } response = signed_api_call ( 'some-new-service-name' , path = '/2018-01-01/worker/terminate' , method = 'POST' , params = params , configuration = configuration , secrets = secrets ) return response . json () Here is an example on existing API call (as a more concrete snippet): from chaoslib.types import Configuration , Secrets from chaosaws import signed_api_call def stop_instance ( instance_id : str , configuration : Configuration = None , secrets : Secrets = None ) -> str : response = signed_api_call ( 'ec2' , configuration = configuration , secrets = secrets , params = { \"Action\" : \"StopInstances\" , \"InstanceId.1\" : instance_id , \"Version\" : \"2013-06-15\" } ) # this API returns XML, not JSON return response . text When using the signed_api_call , you are responsible for the right way of passing the parameters. Basically, look at the AWS documentation for each API call. WARNING: It should be noted that, whenever boto3 implements an API, this package should be updated accordingly, as boto3 is much more versatile and solid.","title":"Services not supported by boto (new AWS features)"},{"location":"drivers/aws/#make-your-new-sub-package-discoverable","text":"Finally, if you have created a new sub-package entirely, you need to make its capability discoverable by the chaos toolkit. Simply amend the discover function in the chaosaws/__init__.py . For example, assuming a new eks sub-package, with actions and probes: activities . extend ( discover_actions ( \"chaosaws.eks.actions\" )) activities . extend ( discover_probes ( \"chaosaws.eks.probes\" ))","title":"Make your new sub-package discoverable"},{"location":"drivers/aws/#exported-activities","text":"","title":"Exported Activities"},{"location":"drivers/aws/#asg","text":"","title":"asg"},{"location":"drivers/aws/#attach_volume","text":"Type action Module chaosaws.asg.actions Name attach_volume Return list Attaches ebs volumes that have been previously detached by CTK : One of: asg_names: list: one or more asg names tags: list: key/value pairs to identify asgs by tags are expected as a list of dictionary objects: [ {\u2018Key\u2019: \u2018TagKey1\u2019, \u2018Value\u2019: \u2018TagValue1\u2019}, {\u2018Key\u2019: \u2018TagKey2\u2019, \u2018Value\u2019: \u2018TagValue2\u2019}, \u2026 ] Signature: def attach_volume ( asg_names : List [ str ] = None , tags : List [ Dict [ str , str ]] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required asg_names list null No tags list null No Usage: { \"name\" : \"attach-volume\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.asg.actions\" , \"func\" : \"attach_volume\" } } name : attach-volume provider : func : attach_volume module : chaosaws.asg.actions type : python type : action","title":"attach_volume"},{"location":"drivers/aws/#change_subnets","text":"Type action Module chaosaws.asg.actions Name change_subnets Return None Adds/removes subnets on autoscaling groups : One of: asg_names: a list of one or more asg names tags: a list of key/value pair to identify asg(s) by subnets: a list of subnet IDs to associate to the ASG tags are expected as a list of dictionary objects: [ {\u2018Key\u2019: \u2018TagKey1\u2019, \u2018Value\u2019: \u2018TagValue1\u2019}, {\u2018Key\u2019: \u2018TagKey2\u2019, \u2018Value\u2019: \u2018TagValue2\u2019}, \u2026 ] Signature: def change_subnets ( subnets : List [ str ], asg_names : List [ str ] = None , tags : List [ dict ] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required subnets list Yes asg_names list null No tags list null No Usage: { \"name\" : \"change-subnets\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.asg.actions\" , \"func\" : \"change_subnets\" , \"arguments\" : { \"subnets\" : [] } } } name : change-subnets provider : arguments : subnets : [] func : change_subnets module : chaosaws.asg.actions type : python type : action","title":"change_subnets"},{"location":"drivers/aws/#describe_auto_scaling_groups","text":"Type probe Module chaosaws.asg.probes Name describe_auto_scaling_groups Return mapping Returns AWS descriptions for provided ASG(s) Params: OneOf: - asg_names: a list of asg names to describe - tags: a list of key/value pairs to collect ASG(s) tags are expected as a list of dictionary objects: [ {\u2018Key\u2019: \u2018TagKey1\u2019, \u2018Value\u2019: \u2018TagValue1\u2019}, {\u2018Key\u2019: \u2018TagKey2\u2019, \u2018Value\u2019: \u2018TagValue2\u2019}, \u2026 ] Signature: def describe_auto_scaling_groups ( asg_names : List [ str ] = None , tags : List [ Dict [ str , Any ]] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required asg_names list null No tags list null No Usage: { \"name\" : \"describe-auto-scaling-groups\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.asg.probes\" , \"func\" : \"describe_auto_scaling_groups\" } } name : describe-auto-scaling-groups provider : func : describe_auto_scaling_groups module : chaosaws.asg.probes type : python type : probe","title":"describe_auto_scaling_groups"},{"location":"drivers/aws/#desired_equals_healthy","text":"Type probe Module chaosaws.asg.probes Name desired_equals_healthy Return boolean If desired number matches the number of healthy instances for each of the auto-scaling groups Returns: bool Signature: def desired_equals_healthy ( asg_names : List [ str ], configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required asg_names list Yes Usage: { \"name\" : \"desired-equals-healthy\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.asg.probes\" , \"func\" : \"desired_equals_healthy\" , \"arguments\" : { \"asg_names\" : [] } } } name : desired-equals-healthy provider : arguments : asg_names : [] func : desired_equals_healthy module : chaosaws.asg.probes type : python type : probe","title":"desired_equals_healthy"},{"location":"drivers/aws/#desired_equals_healthy_tags","text":"Type probe Module chaosaws.asg.probes Name desired_equals_healthy_tags Return boolean If desired number matches the number of healthy instances for each of the auto-scaling groups matching tags provided tags are expected as: [{ \u2018Key\u2019: \u2018KeyName\u2019, \u2018Value\u2019: \u2018KeyValue\u2019 }, \u2026 ] Returns: bool Signature: def desired_equals_healthy_tags ( tags : List [ Dict [ str , str ]], configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required tags list Yes Usage: { \"name\" : \"desired-equals-healthy-tags\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.asg.probes\" , \"func\" : \"desired_equals_healthy_tags\" , \"arguments\" : { \"tags\" : [] } } } name : desired-equals-healthy-tags provider : arguments : tags : [] func : desired_equals_healthy_tags module : chaosaws.asg.probes type : python type : probe","title":"desired_equals_healthy_tags"},{"location":"drivers/aws/#detach_random_instances","text":"Type action Module chaosaws.asg.actions Name detach_random_instances Return mapping Detaches one or more random instances from an autoscaling group : One of: asg_names: a list of one or more asg names tags: a list of key/value pair to identify asg(s) by One of: instance_count: integer value of number of instances to detach instance_percent: 1-100, percent of instances to detach decrement_capacity: boolean value to determine if the desired capacity of the autoscaling group should be decreased tags are expected as a list of dictionary objects: [ {\u2018Key\u2019: \u2018TagKey1\u2019, \u2018Value\u2019: \u2018TagValue1\u2019}, {\u2018Key\u2019: \u2018TagKey2\u2019, \u2018Value\u2019: \u2018TagValue2\u2019}, \u2026 ] Signature: def detach_random_instances ( asg_names : List [ str ] = None , tags : List [ dict ] = None , instance_count : int = None , instance_percent : int = None , decrement_capacity : bool = False , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required asg_names list null No tags list null No instance_count integer null No instance_percent integer null No decrement_capacity boolean false No Usage: { \"name\" : \"detach-random-instances\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.asg.actions\" , \"func\" : \"detach_random_instances\" } } name : detach-random-instances provider : func : detach_random_instances module : chaosaws.asg.actions type : python type : action","title":"detach_random_instances"},{"location":"drivers/aws/#detach_random_volume","text":"Type action Module chaosaws.asg.actions Name detach_random_volume Return list Detaches a random (non root) ebs volume from ec2 instances associated to an ASG : One of: asg_names: a list of one or more asg names tags: a list of key/value pair to identify asg(s) by force: force detach volume (default: true) tags are expected as a list of dictionary objects: [ {\u2018Key\u2019: \u2018TagKey1\u2019, \u2018Value\u2019: \u2018TagValue1\u2019}, {\u2018Key\u2019: \u2018TagKey2\u2019, \u2018Value\u2019: \u2018TagValue2\u2019}, \u2026 ] Signature: def detach_random_volume ( asg_names : List [ str ] = None , tags : List [ Dict [ str , str ]] = None , force : bool = True , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required asg_names list null No tags list null No force boolean true No Usage: { \"name\" : \"detach-random-volume\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.asg.actions\" , \"func\" : \"detach_random_volume\" } } name : detach-random-volume provider : func : detach_random_volume module : chaosaws.asg.actions type : python type : action","title":"detach_random_volume"},{"location":"drivers/aws/#has_subnets","text":"Type probe Module chaosaws.asg.probes Name has_subnets Return boolean Determines if the provided autoscaling groups are in the provided subnets :returns boolean Signature: def has_subnets ( subnets : List [ str ], asg_names : List [ str ] = None , tags : List [ Dict [ str , str ]] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required subnets list Yes asg_names list null No tags list null No Usage: { \"name\" : \"has-subnets\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.asg.probes\" , \"func\" : \"has_subnets\" , \"arguments\" : { \"subnets\" : [] } } } name : has-subnets provider : arguments : subnets : [] func : has_subnets module : chaosaws.asg.probes type : python type : probe","title":"has_subnets"},{"location":"drivers/aws/#instance_count_by_health","text":"Type probe Module chaosaws.asg.probes Name instance_count_by_health Return integer Reports the number of instances currently in the ASG by their health status Params: OneOf: - asg_names: a list of asg names to describe - tags: a list of key/value pairs to collect ASG(s) - count_healthy: boolean: true for healthy instance count, false for unhealthy instance count tags are expected as a list of dictionary objects: [ {\u2018Key\u2019: \u2018TagKey1\u2019, \u2018Value\u2019: \u2018TagValue1\u2019}, {\u2018Key\u2019: \u2018TagKey2\u2019, \u2018Value\u2019: \u2018TagValue2\u2019}, \u2026 ] Signature: def instance_count_by_health ( asg_names : List [ str ] = None , tags : List [ Dict [ str , str ]] = None , count_healthy : bool = True , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required asg_names list null No tags list null No count_healthy boolean true No Usage: { \"name\" : \"instance-count-by-health\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.asg.probes\" , \"func\" : \"instance_count_by_health\" } } name : instance-count-by-health provider : func : instance_count_by_health module : chaosaws.asg.probes type : python type : probe","title":"instance_count_by_health"},{"location":"drivers/aws/#is_scaling_in_progress","text":"Type probe Module chaosaws.asg.probes Name is_scaling_in_progress Return boolean Check if there is any scaling activity in progress for ASG matching tags Returns: Boolean Signature: def is_scaling_in_progress ( tags : List [ Dict [ str , str ]], configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required tags list Yes Usage: { \"name\" : \"is-scaling-in-progress\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.asg.probes\" , \"func\" : \"is_scaling_in_progress\" , \"arguments\" : { \"tags\" : [] } } } name : is-scaling-in-progress provider : arguments : tags : [] func : is_scaling_in_progress module : chaosaws.asg.probes type : python type : probe","title":"is_scaling_in_progress"},{"location":"drivers/aws/#process_is_suspended","text":"Type probe Module chaosaws.asg.probes Name process_is_suspended Return boolean Determines if one or more processes on an ASG are suspended. :returns Boolean Signature: def process_is_suspended ( asg_names : List [ str ] = None , tags : List [ Dict [ str , str ]] = None , process_names : List [ str ] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required asg_names list null No tags list null No process_names list null No Usage: { \"name\" : \"process-is-suspended\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.asg.probes\" , \"func\" : \"process_is_suspended\" } } name : process-is-suspended provider : func : process_is_suspended module : chaosaws.asg.probes type : python type : probe","title":"process_is_suspended"},{"location":"drivers/aws/#resume_processes","text":"Type action Module chaosaws.asg.actions Name resume_processes Return mapping Resumes 1 or more suspended processes on a list of auto scaling groups. If no process is specified, all suspended auto scaling processes will be resumed. For a list of valid processes that can be suspended, reference: https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-suspend-resume-processes.html : One of: - asg_names: a list of one or more asg names to target - tags: a list of key/value pairs to identify the asgs by tags are expected as a list of dictionary objects: [ {\u2018Key\u2019: \u2018TagKey1\u2019, \u2018Value\u2019: \u2018TagValue1\u2019}, {\u2018Key\u2019: \u2018TagKey2\u2019, \u2018Value\u2019: \u2018TagValue2\u2019}, \u2026 ] Signature: def resume_processes ( asg_names : List [ str ] = None , tags : List [ Dict [ str , str ]] = None , process_names : List [ str ] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required asg_names list null No tags list null No process_names list null No Usage: { \"name\" : \"resume-processes\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.asg.actions\" , \"func\" : \"resume_processes\" } } name : resume-processes provider : func : resume_processes module : chaosaws.asg.actions type : python type : action","title":"resume_processes"},{"location":"drivers/aws/#stop_random_instances","text":"Type action Module chaosaws.asg.actions Name stop_random_instances Return list Terminates one or more random healthy instances associated to an ALB A healthy instance is considered one with a status of \u2018InService\u2019 : - force: force stop the instances (default: False) One Of: asg_names: a list of one or more asg names to target tags: a list of key/value pairs to identify the asgs by One Of: - instance_count: the number of instances to terminate - instance_percent: the percentage of instances to terminate - az: the availability zone to terminate instances tags are expected as a list of dictionary objects: [ {\u2018Key\u2019: \u2018TagKey1\u2019, \u2018Value\u2019: \u2018TagValue1\u2019}, {\u2018Key\u2019: \u2018TagKey2\u2019, \u2018Value\u2019: \u2018TagValue2\u2019}, \u2026 ] Signature: def stop_random_instances ( asg_names : List [ str ] = None , tags : List [ Dict [ str , str ]] = None , instance_count : int = None , instance_percent : int = None , az : str = None , force : bool = False , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required asg_names list null No tags list null No instance_count integer null No instance_percent integer null No az string null No force boolean false No Usage: { \"name\" : \"stop-random-instances\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.asg.actions\" , \"func\" : \"stop_random_instances\" } } name : stop-random-instances provider : func : stop_random_instances module : chaosaws.asg.actions type : python type : action","title":"stop_random_instances"},{"location":"drivers/aws/#suspend_processes","text":"Type action Module chaosaws.asg.actions Name suspend_processes Return mapping Suspends 1 or more processes on a list of auto scaling groups. If no process is specified, all running auto scaling processes will be suspended. For a list of valid processes that can be suspended, reference: https://docs.aws.amazon.com/autoscaling/ec2/userguide/as-suspend-resume-processes.html : One of: - asg_names: a list of one or more asg names to target - tags: a list of key/value pairs to identify the asgs by tags are expected as a list of dictionary objects: [ {\u2018Key\u2019: \u2018TagKey1\u2019, \u2018Value\u2019: \u2018TagValue1\u2019}, {\u2018Key\u2019: \u2018TagKey2\u2019, \u2018Value\u2019: \u2018TagValue2\u2019}, \u2026 ] Signature: def suspend_processes ( asg_names : List [ str ] = None , tags : List [ Dict [ str , str ]] = None , process_names : List [ str ] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required asg_names list null No tags list null No process_names list null No Usage: { \"name\" : \"suspend-processes\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.asg.actions\" , \"func\" : \"suspend_processes\" } } name : suspend-processes provider : func : suspend_processes module : chaosaws.asg.actions type : python type : action","title":"suspend_processes"},{"location":"drivers/aws/#terminate_random_instances","text":"Type action Module chaosaws.asg.actions Name terminate_random_instances Return list Terminates one or more random healthy instances associated to an ALB A healthy instance is considered one with a status of \u2018InService\u2019 : One Of: - asg_names: a list of one or more asg names to target - tags: a list of key/value pairs to identify the asgs by One Of: - instance_count: the number of instances to terminate - instance_percent: the percentage of instances to terminate - az: the availability zone to terminate instances tags are expected as a list of dictionary objects: [ {\u2018Key\u2019: \u2018TagKey1\u2019, \u2018Value\u2019: \u2018TagValue1\u2019}, {\u2018Key\u2019: \u2018TagKey2\u2019, \u2018Value\u2019: \u2018TagValue2\u2019}, \u2026 ] Signature: def terminate_random_instances ( asg_names : List [ str ] = None , tags : List [ Dict [ str , str ]] = None , instance_count : int = None , instance_percent : int = None , az : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required asg_names list null No tags list null No instance_count integer null No instance_percent integer null No az string null No Usage: { \"name\" : \"terminate-random-instances\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.asg.actions\" , \"func\" : \"terminate_random_instances\" } } name : terminate-random-instances provider : func : terminate_random_instances module : chaosaws.asg.actions type : python type : action","title":"terminate_random_instances"},{"location":"drivers/aws/#wait_desired_equals_healthy","text":"Type probe Module chaosaws.asg.probes Name wait_desired_equals_healthy Return integer Wait until desired number matches the number of healthy instances for each of the auto-scaling groups Returns: Integer (number of seconds it took to wait) or sys.maxsize in case of timeout Signature: def wait_desired_equals_healthy ( asg_names : List [ str ], configuration : Dict [ str , Dict [ str , str ]] = None , timeout : Union [ int , float ] = 300 , secrets : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required asg_names list Yes timeout object 300 No Usage: { \"name\" : \"wait-desired-equals-healthy\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.asg.probes\" , \"func\" : \"wait_desired_equals_healthy\" , \"arguments\" : { \"asg_names\" : [] } } } name : wait-desired-equals-healthy provider : arguments : asg_names : [] func : wait_desired_equals_healthy module : chaosaws.asg.probes type : python type : probe","title":"wait_desired_equals_healthy"},{"location":"drivers/aws/#wait_desired_equals_healthy_tags","text":"Type probe Module chaosaws.asg.probes Name wait_desired_equals_healthy_tags Return integer Wait until desired number matches the number of healthy instances for each of the auto-scaling groups matching tags provided tags are expected as: [{ \u2018Key\u2019: \u2018KeyName\u2019, \u2018Value\u2019: \u2018KeyValue\u2019 }, \u2026 ] Returns: Integer (number of seconds it took to wait) or sys.maxsize in case of timeout Signature: def wait_desired_equals_healthy_tags ( tags : List [ Dict [ str , str ]], timeout : Union [ int , float ] = 300 , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required tags list Yes timeout object 300 No Usage: { \"name\" : \"wait-desired-equals-healthy-tags\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.asg.probes\" , \"func\" : \"wait_desired_equals_healthy_tags\" , \"arguments\" : { \"tags\" : [] } } } name : wait-desired-equals-healthy-tags provider : arguments : tags : [] func : wait_desired_equals_healthy_tags module : chaosaws.asg.probes type : python type : probe","title":"wait_desired_equals_healthy_tags"},{"location":"drivers/aws/#wait_desired_not_equals_healthy_tags","text":"Type probe Module chaosaws.asg.probes Name wait_desired_not_equals_healthy_tags Return integer Wait until desired number doesn\u2019t match the number of healthy instances for each of the auto-scaling groups matching tags provided tags are expected as: [{ \u2018Key\u2019: \u2018KeyName\u2019, \u2018Value\u2019: \u2018KeyValue\u2019 }, \u2026 ] Returns: Integer (number of seconds it took to wait) or sys.maxsize in case of timeout Signature: def wait_desired_not_equals_healthy_tags ( tags : List [ Dict [ str , str ]], timeout : Union [ int , float ] = 300 , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required tags list Yes timeout object 300 No Usage: { \"name\" : \"wait-desired-not-equals-healthy-tags\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.asg.probes\" , \"func\" : \"wait_desired_not_equals_healthy_tags\" , \"arguments\" : { \"tags\" : [] } } } name : wait-desired-not-equals-healthy-tags provider : arguments : tags : [] func : wait_desired_not_equals_healthy_tags module : chaosaws.asg.probes type : python type : probe","title":"wait_desired_not_equals_healthy_tags"},{"location":"drivers/aws/#awslambda","text":"","title":"awslambda"},{"location":"drivers/aws/#delete_function_concurrency","text":"Type action Module chaosaws.awslambda.actions Name delete_function_concurrency Return mapping Removes concurrency limit applied to the specified Lambda Signature: def delete_function_concurrency ( function_name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required function_name string Yes Usage: { \"name\" : \"delete-function-concurrency\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.awslambda.actions\" , \"func\" : \"delete_function_concurrency\" , \"arguments\" : { \"function_name\" : \"\" } } } name : delete-function-concurrency provider : arguments : function_name : '' func : delete_function_concurrency module : chaosaws.awslambda.actions type : python type : action","title":"delete_function_concurrency"},{"location":"drivers/aws/#get_function_concurrency","text":"Type probe Module chaosaws.awslambda.probes Name get_function_concurrency Return boolean Get configuration information of lambda by its function name Signature: def get_function_concurrency ( function_name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required function_name string Yes Usage: { \"name\" : \"get-function-concurrency\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.awslambda.probes\" , \"func\" : \"get_function_concurrency\" , \"arguments\" : { \"function_name\" : \"\" } } } name : get-function-concurrency provider : arguments : function_name : '' func : get_function_concurrency module : chaosaws.awslambda.probes type : python type : probe","title":"get_function_concurrency"},{"location":"drivers/aws/#get_function_memory_size","text":"Type probe Module chaosaws.awslambda.probes Name get_function_memory_size Return integer Get the configured memory size of a lambda function. The returned memory size is specified in megabytes. Signature: def get_function_memory_size ( function_name : str , qualifier : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required function_name string Yes qualifier string null No Usage: { \"name\" : \"get-function-memory-size\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.awslambda.probes\" , \"func\" : \"get_function_memory_size\" , \"arguments\" : { \"function_name\" : \"\" } } } name : get-function-memory-size provider : arguments : function_name : '' func : get_function_memory_size module : chaosaws.awslambda.probes type : python type : probe","title":"get_function_memory_size"},{"location":"drivers/aws/#get_function_timeout","text":"Type probe Module chaosaws.awslambda.probes Name get_function_timeout Return integer Get the configured timeout of a lambda function. The returned timeout is specified in number of seconds. Signature: def get_function_timeout ( function_name : str , qualifier : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required function_name string Yes qualifier string null No Usage: { \"name\" : \"get-function-timeout\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.awslambda.probes\" , \"func\" : \"get_function_timeout\" , \"arguments\" : { \"function_name\" : \"\" } } } name : get-function-timeout provider : arguments : function_name : '' func : get_function_timeout module : chaosaws.awslambda.probes type : python type : probe","title":"get_function_timeout"},{"location":"drivers/aws/#invoke_function","text":"Type action Module chaosaws.awslambda.actions Name invoke_function Return mapping Invokes Lambda. More information about request arguments are available in the documentation https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/lambda.html#Lambda.Client.invoke Signature: def invoke_function ( function_name : str , function_arguments : Dict [ str , Any ] = None , invocation_type : str = 'RequestResponse' , client_context : Dict [ str , Any ] = None , qualifier : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required function_name string Yes function_arguments mapping null No invocation_type string \u201cRequestResponse\u201d No client_context mapping null No qualifier string null No Usage: { \"name\" : \"invoke-function\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.awslambda.actions\" , \"func\" : \"invoke_function\" , \"arguments\" : { \"function_name\" : \"\" } } } name : invoke-function provider : arguments : function_name : '' func : invoke_function module : chaosaws.awslambda.actions type : python type : action","title":"invoke_function"},{"location":"drivers/aws/#put_function_concurrency","text":"Type action Module chaosaws.awslambda.actions Name put_function_concurrency Return mapping Throttles Lambda by setting reserved concurrency amount. Signature: def put_function_concurrency ( function_name : str , concurrent_executions : int , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required function_name string Yes concurrent_executions integer Yes Usage: { \"name\" : \"put-function-concurrency\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.awslambda.actions\" , \"func\" : \"put_function_concurrency\" , \"arguments\" : { \"function_name\" : \"\" , \"concurrent_executions\" : 0 } } } name : put-function-concurrency provider : arguments : concurrent_executions : 0 function_name : '' func : put_function_concurrency module : chaosaws.awslambda.actions type : python type : action","title":"put_function_concurrency"},{"location":"drivers/aws/#put_function_memory_size","text":"Type action Module chaosaws.awslambda.actions Name put_function_memory_size Return mapping Sets the function memory size. Input memory_size argument is specified in megabytes. Signature: def put_function_memory_size ( function_name : str , memory_size : int , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required function_name string Yes memory_size integer Yes Usage: { \"name\" : \"put-function-memory-size\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.awslambda.actions\" , \"func\" : \"put_function_memory_size\" , \"arguments\" : { \"function_name\" : \"\" , \"memory_size\" : 0 } } } name : put-function-memory-size provider : arguments : function_name : '' memory_size : 0 func : put_function_memory_size module : chaosaws.awslambda.actions type : python type : action","title":"put_function_memory_size"},{"location":"drivers/aws/#put_function_timeout","text":"Type action Module chaosaws.awslambda.actions Name put_function_timeout Return mapping Sets the function timeout. Input timeout argument is specified in seconds. Signature: def put_function_timeout ( function_name : str , timeout : int , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required function_name string Yes timeout integer Yes Usage: { \"name\" : \"put-function-timeout\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.awslambda.actions\" , \"func\" : \"put_function_timeout\" , \"arguments\" : { \"function_name\" : \"\" , \"timeout\" : 0 } } } name : put-function-timeout provider : arguments : function_name : '' timeout : 0 func : put_function_timeout module : chaosaws.awslambda.actions type : python type : action","title":"put_function_timeout"},{"location":"drivers/aws/#cloudwatch","text":"","title":"cloudwatch"},{"location":"drivers/aws/#delete_rule","text":"Type action Module chaosaws.cloudwatch.actions Name delete_rule Return mapping Deletes a CloudWatch rule. All rule targets must be removed before deleting the rule. Set input argument force to True to force all rule targets to be deleted. Signature: def delete_rule ( rule_name : str , force : bool = False , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required rule_name string Yes force boolean false No Usage: { \"name\" : \"delete-rule\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.cloudwatch.actions\" , \"func\" : \"delete_rule\" , \"arguments\" : { \"rule_name\" : \"\" } } } name : delete-rule provider : arguments : rule_name : '' func : delete_rule module : chaosaws.cloudwatch.actions type : python type : action","title":"delete_rule"},{"location":"drivers/aws/#disable_rule","text":"Type action Module chaosaws.cloudwatch.actions Name disable_rule Return mapping Disables a CloudWatch rule. Signature: def disable_rule ( rule_name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required rule_name string Yes Usage: { \"name\" : \"disable-rule\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.cloudwatch.actions\" , \"func\" : \"disable_rule\" , \"arguments\" : { \"rule_name\" : \"\" } } } name : disable-rule provider : arguments : rule_name : '' func : disable_rule module : chaosaws.cloudwatch.actions type : python type : action","title":"disable_rule"},{"location":"drivers/aws/#enable_rule","text":"Type action Module chaosaws.cloudwatch.actions Name enable_rule Return mapping Enables a CloudWatch rule. Signature: def enable_rule ( rule_name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required rule_name string Yes Usage: { \"name\" : \"enable-rule\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.cloudwatch.actions\" , \"func\" : \"enable_rule\" , \"arguments\" : { \"rule_name\" : \"\" } } } name : enable-rule provider : arguments : rule_name : '' func : enable_rule module : chaosaws.cloudwatch.actions type : python type : action","title":"enable_rule"},{"location":"drivers/aws/#get_alarm_state_value","text":"Type probe Module chaosaws.cloudwatch.probes Name get_alarm_state_value Return string Return the state value of an alarm. The possbile alarm state values are described in the documentation https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/cloudwatch.html#CloudWatch.Client.describe_alarms Signature: def get_alarm_state_value ( alarm_name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> str : pass Arguments: Name Type Default Required alarm_name string Yes Usage: { \"name\" : \"get-alarm-state-value\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.cloudwatch.probes\" , \"func\" : \"get_alarm_state_value\" , \"arguments\" : { \"alarm_name\" : \"\" } } } name : get-alarm-state-value provider : arguments : alarm_name : '' func : get_alarm_state_value module : chaosaws.cloudwatch.probes type : python type : probe","title":"get_alarm_state_value"},{"location":"drivers/aws/#get_metric_data","text":"Type probe Module chaosaws.cloudwatch.probes Name get_metric_data Return number Gets metric data for a given metric in a given time period. This method allows for more data to be retrieved than get_metric_statistics :params namespace: The AWS metric namespace metric_name: The name of the metric to pull data for dimension_name: The name of the dimension to search for dimension_value: The value to be used for searching the dimension unit: The type of unit desired to be collected statistic: The type of data to return. One of: Average, Sum, Minimum, Maximum, SampleCount period: The window in which to pull datapoints for offset: The time (seconds) to offset the endtime (from now) duration: The time (seconds) to set the start time (from now) Signature: def get_metric_data ( namespace : str , metric_name : str , dimension_name : str , dimension_value : str , statistic : str = None , duration : int = 300 , period : int = 60 , offset : int = 0 , unit : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> float : pass Arguments: Name Type Default Required namespace string Yes metric_name string Yes dimension_name string Yes dimension_value string Yes statistic string null No duration integer 300 No period integer 60 No offset integer 0 No unit string null No Usage: { \"name\" : \"get-metric-data\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.cloudwatch.probes\" , \"func\" : \"get_metric_data\" , \"arguments\" : { \"namespace\" : \"\" , \"metric_name\" : \"\" , \"dimension_name\" : \"\" , \"dimension_value\" : \"\" } } } name : get-metric-data provider : arguments : dimension_name : '' dimension_value : '' metric_name : '' namespace : '' func : get_metric_data module : chaosaws.cloudwatch.probes type : python type : probe","title":"get_metric_data"},{"location":"drivers/aws/#get_metric_statistics","text":"Type probe Module chaosaws.cloudwatch.probes Name get_metric_statistics Return None Get the value of a statistical calculation for a given metric. The period for which the calculation will be performed is specified by a duration and an offset from the current time. Both are specified in seconds. Example: A duration of 60 seconds and an offset of 30 seconds will yield a statistical value based on the time interval between 30 and 90 seconds in the past. More information about input parameters are available in the documentation https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/cloudwatch.html#CloudWatch.Client.get_metric_statistics Signature: def get_metric_statistics ( namespace : str , metric_name : str , dimension_name : str , dimension_value : str , duration : int = 60 , offset : int = 0 , statistic : str = None , extended_statistic : str = None , unit : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required namespace string Yes metric_name string Yes dimension_name string Yes dimension_value string Yes duration integer 60 No offset integer 0 No statistic string null No extended_statistic string null No unit string null No Usage: { \"name\" : \"get-metric-statistics\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.cloudwatch.probes\" , \"func\" : \"get_metric_statistics\" , \"arguments\" : { \"namespace\" : \"\" , \"metric_name\" : \"\" , \"dimension_name\" : \"\" , \"dimension_value\" : \"\" } } } name : get-metric-statistics provider : arguments : dimension_name : '' dimension_value : '' metric_name : '' namespace : '' func : get_metric_statistics module : chaosaws.cloudwatch.probes type : python type : probe","title":"get_metric_statistics"},{"location":"drivers/aws/#put_rule","text":"Type action Module chaosaws.cloudwatch.actions Name put_rule Return mapping Creates or updates a CloudWatch event rule. Please refer to https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/events.html#CloudWatchEvents.Client.put_rule for details on input arguments. Signature: def put_rule ( rule_name : str , schedule_expression : str = None , event_pattern : str = None , state : str = None , description : str = None , role_arn : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required rule_name string Yes schedule_expression string null No event_pattern string null No state string null No description string null No role_arn string null No Usage: { \"name\" : \"put-rule\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.cloudwatch.actions\" , \"func\" : \"put_rule\" , \"arguments\" : { \"rule_name\" : \"\" } } } name : put-rule provider : arguments : rule_name : '' func : put_rule module : chaosaws.cloudwatch.actions type : python type : action","title":"put_rule"},{"location":"drivers/aws/#put_rule_targets","text":"Type action Module chaosaws.cloudwatch.actions Name put_rule_targets Return mapping Creates or update CloudWatch event rule targets. Please refer to https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/events.html#CloudWatchEvents.Client.put_targets for details on input arguments. Signature: def put_rule_targets ( rule_name : str , targets : List [ Dict [ str , Any ]], configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required rule_name string Yes targets list Yes Usage: { \"name\" : \"put-rule-targets\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.cloudwatch.actions\" , \"func\" : \"put_rule_targets\" , \"arguments\" : { \"rule_name\" : \"\" , \"targets\" : [] } } } name : put-rule-targets provider : arguments : rule_name : '' targets : [] func : put_rule_targets module : chaosaws.cloudwatch.actions type : python type : action","title":"put_rule_targets"},{"location":"drivers/aws/#remove_rule_targets","text":"Type action Module chaosaws.cloudwatch.actions Name remove_rule_targets Return mapping Removes CloudWatch rule targets. If no target ids are provided all targets will be removed. Signature: def remove_rule_targets ( rule_name : str , target_ids : List [ str ] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required rule_name string Yes target_ids list null No Usage: { \"name\" : \"remove-rule-targets\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.cloudwatch.actions\" , \"func\" : \"remove_rule_targets\" , \"arguments\" : { \"rule_name\" : \"\" } } } name : remove-rule-targets provider : arguments : rule_name : '' func : remove_rule_targets module : chaosaws.cloudwatch.actions type : python type : action","title":"remove_rule_targets"},{"location":"drivers/aws/#ec2","text":"","title":"ec2"},{"location":"drivers/aws/#attach_volume_1","text":"Type action Module chaosaws.ec2.actions Name attach_volume Return list Attaches a previously detached EBS volume to its associated EC2 instance. If neither \u2018instance_ids\u2019 or \u2018filters\u2019 are provided, all detached volumes will be reattached to their respective instances : One of: instance_ids: list: instance ids filters: list: key/value pairs to pull ec2 instances Signature: def attach_volume ( instance_ids : List [ str ] = None , filters : List [ Dict [ str , Any ]] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required instance_ids list null No filters list null No Usage: { \"name\" : \"attach-volume\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ec2.actions\" , \"func\" : \"attach_volume\" } } name : attach-volume provider : func : attach_volume module : chaosaws.ec2.actions type : python type : action","title":"attach_volume"},{"location":"drivers/aws/#count_instances","text":"Type probe Module chaosaws.ec2.probes Name count_instances Return integer Return count of instances matching the specified filters. Please refer to https://bit.ly/2Sv9lmU for details on said filters. Signature: def count_instances ( filters : List [ Dict [ str , Any ]], configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required filters list Yes Usage: { \"name\" : \"count-instances\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ec2.probes\" , \"func\" : \"count_instances\" , \"arguments\" : { \"filters\" : [] } } } name : count-instances provider : arguments : filters : [] func : count_instances module : chaosaws.ec2.probes type : python type : probe","title":"count_instances"},{"location":"drivers/aws/#describe_instances","text":"Type probe Module chaosaws.ec2.probes Name describe_instances Return mapping Describe instances following the specified filters. Please refer to https://bit.ly/2Sv9lmU for details on said filters. Signature: def describe_instances ( filters : List [ Dict [ str , Any ]], configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required filters list Yes Usage: { \"name\" : \"describe-instances\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ec2.probes\" , \"func\" : \"describe_instances\" , \"arguments\" : { \"filters\" : [] } } } name : describe-instances provider : arguments : filters : [] func : describe_instances module : chaosaws.ec2.probes type : python type : probe","title":"describe_instances"},{"location":"drivers/aws/#detach_random_volume_1","text":"Type action Module chaosaws.ec2.actions Name detach_random_volume Return list Detaches a random ebs volume (non root) from one or more EC2 instances : One of: instance_ids: a list of one or more ec2 instance ids filters: a list of key/value pairs to pull ec2 instances force: force detach volume (default: true) Additional filters may be used to narrow the scope: https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ec2.html#EC2.Client.describe_instances Signature: def detach_random_volume ( instance_ids : List [ str ] = None , filters : List [ Dict [ str , Any ]] = None , force : bool = True , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required instance_ids list null No filters list null No force boolean true No Usage: { \"name\" : \"detach-random-volume\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ec2.actions\" , \"func\" : \"detach_random_volume\" } } name : detach-random-volume provider : func : detach_random_volume module : chaosaws.ec2.actions type : python type : action","title":"detach_random_volume"},{"location":"drivers/aws/#instance_state","text":"Type probe Module chaosaws.ec2.probes Name instance_state Return boolean Determines if EC2 instances match desired state For additional filter options, please refer to the documentation found: https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ec2.html#EC2.Client.describe_instances Signature: def instance_state ( state : str , instance_ids : List [ str ] = None , filters : List [ Dict [ str , Any ]] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required state string Yes instance_ids list null No filters list null No Usage: { \"name\" : \"instance-state\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ec2.probes\" , \"func\" : \"instance_state\" , \"arguments\" : { \"state\" : \"\" } } } name : instance-state provider : arguments : state : '' func : instance_state module : chaosaws.ec2.probes type : python type : probe","title":"instance_state"},{"location":"drivers/aws/#restart_instances","text":"Type action Module chaosaws.ec2.actions Name restart_instances Return list Restarts one or more EC2 instances. WARNING: If only an Availability Zone is provided, all instances in the provided AZ will be restarted. Additional filters may be used to narrow the scope: https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ec2.html#EC2.Client.describe_instances Signature: def restart_instances ( instance_ids : List [ str ] = None , az : str = None , filters : List [ Dict [ str , Any ]] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required instance_ids list null No az string null No filters list null No Usage: { \"name\" : \"restart-instances\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ec2.actions\" , \"func\" : \"restart_instances\" } } name : restart-instances provider : func : restart_instances module : chaosaws.ec2.actions type : python type : action","title":"restart_instances"},{"location":"drivers/aws/#start_instances","text":"Type action Module chaosaws.ec2.actions Name start_instances Return list Starts one or more EC2 instances. WARNING: If only an Availability Zone is provided, all instances in the provided AZ will be started. Additional filters may be used to narrow the scope: https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ec2.html#EC2.Client.describe_instances Signature: def start_instances ( instance_ids : List [ str ] = None , az : str = None , filters : List [ Dict [ str , Any ]] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required instance_ids list null No az string null No filters list null No Usage: { \"name\" : \"start-instances\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ec2.actions\" , \"func\" : \"start_instances\" } } name : start-instances provider : func : start_instances module : chaosaws.ec2.actions type : python type : action","title":"start_instances"},{"location":"drivers/aws/#stop_instance","text":"Type action Module chaosaws.ec2.actions Name stop_instance Return list Stop a single EC2 instance. You may provide an instance id explicitly or, if you only specify the AZ, a random instance will be selected. If you need more control, you can also provide a list of filters following the documentation https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ec2.html#EC2.Client.describe_instances Signature: def stop_instance ( instance_id : str = None , az : str = None , force : bool = False , filters : List [ Dict [ str , Any ]] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required instance_id string null No az string null No force boolean false No filters list null No Usage: { \"name\" : \"stop-instance\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ec2.actions\" , \"func\" : \"stop_instance\" } } name : stop-instance provider : func : stop_instance module : chaosaws.ec2.actions type : python type : action","title":"stop_instance"},{"location":"drivers/aws/#stop_instances","text":"Type action Module chaosaws.ec2.actions Name stop_instances Return list Stop the given EC2 instances or, if none is provided, all instances of the given availability zone. If you need more control, you can also provide a list of filters following the documentation https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ec2.html#EC2.Client.describe_instances Signature: def stop_instances ( instance_ids : List [ str ] = None , az : str = None , filters : List [ Dict [ str , Any ]] = None , force : bool = False , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required instance_ids list null No az string null No filters list null No force boolean false No Usage: { \"name\" : \"stop-instances\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ec2.actions\" , \"func\" : \"stop_instances\" } } name : stop-instances provider : func : stop_instances module : chaosaws.ec2.actions type : python type : action","title":"stop_instances"},{"location":"drivers/aws/#terminate_instance","text":"Type action Module chaosaws.ec2.actions Name terminate_instance Return list Terminates a single EC2 instance. An instance may be targeted by specifying it by instance-id. If only the availability-zone is provided, a random instances in that AZ will be selected and terminated. For more control, please reference the available filters found: https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ec2.html#EC2.Client.describe_instances Signature: def terminate_instance ( instance_id : str = None , az : str = None , filters : List [ Dict [ str , Any ]] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required instance_id string null No az string null No filters list null No Usage: { \"name\" : \"terminate-instance\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ec2.actions\" , \"func\" : \"terminate_instance\" } } name : terminate-instance provider : func : terminate_instance module : chaosaws.ec2.actions type : python type : action","title":"terminate_instance"},{"location":"drivers/aws/#terminate_instances","text":"Type action Module chaosaws.ec2.actions Name terminate_instances Return list Terminates multiple EC2 instances A set of instances may be targeted by providing them as the instance-ids. WARNING: If only an Availability Zone is specified, all instances in that AZ will be terminated. Additional filters may be used to narrow the scope: https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ec2.html#EC2.Client.describe_instances Signature: def terminate_instances ( instance_ids : List [ str ] = None , az : str = None , filters : List [ Dict [ str , Any ]] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required instance_ids list null No az string null No filters list null No Usage: { \"name\" : \"terminate-instances\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ec2.actions\" , \"func\" : \"terminate_instances\" } } name : terminate-instances provider : func : terminate_instances module : chaosaws.ec2.actions type : python type : action","title":"terminate_instances"},{"location":"drivers/aws/#ecs","text":"","title":"ecs"},{"location":"drivers/aws/#are_all_desired_tasks_running","text":"Type probe Module chaosaws.ecs.probes Name are_all_desired_tasks_running Return boolean Checks to make sure desired and running tasks counts are equal Signature: def are_all_desired_tasks_running ( cluster : str , service : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required cluster string Yes service string Yes Usage: { \"name\" : \"are-all-desired-tasks-running\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ecs.probes\" , \"func\" : \"are_all_desired_tasks_running\" , \"arguments\" : { \"cluster\" : \"\" , \"service\" : \"\" } } } name : are-all-desired-tasks-running provider : arguments : cluster : '' service : '' func : are_all_desired_tasks_running module : chaosaws.ecs.probes type : python type : probe","title":"are_all_desired_tasks_running"},{"location":"drivers/aws/#delete_cluster","text":"Type action Module chaosaws.ecs.actions Name delete_cluster Return mapping Delete an ECS cluster :param cluster: The ECS cluster name or ARN :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :return: Dict[str, Any] Signature: def delete_cluster ( cluster : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster string Yes Usage: { \"name\" : \"delete-cluster\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ecs.actions\" , \"func\" : \"delete_cluster\" , \"arguments\" : { \"cluster\" : \"\" } } } name : delete-cluster provider : arguments : cluster : '' func : delete_cluster module : chaosaws.ecs.actions type : python type : action","title":"delete_cluster"},{"location":"drivers/aws/#delete_service","text":"Type action Module chaosaws.ecs.actions Name delete_service Return mapping Update a given ECS service by updating it to set the desired count of tasks to 0 then delete it. If not provided, a random one will be picked up regarding service_pattern , if provided, so that only service names matching the pattern would be be used. This should be a valid regex. You can specify a cluster by its ARN identifier or, if not provided, the default cluster will be picked up. Signature: def delete_service ( service : str = None , cluster : str = None , service_pattern : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required service string null No cluster string null No service_pattern string null No Usage: { \"name\" : \"delete-service\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ecs.actions\" , \"func\" : \"delete_service\" } } name : delete-service provider : func : delete_service module : chaosaws.ecs.actions type : python type : action","title":"delete_service"},{"location":"drivers/aws/#deregister_container_instance","text":"Type action Module chaosaws.ecs.actions Name deregister_container_instance Return mapping Deregister an ECS container Warning: If using \u201cforce\u201d, Any tasks not deleted before deregistration will remain orphaned :param cluster: The ECS cluster name or ARN or ARN :param instance_id: The container instance id or ARN :param force: Force deregistraion of container instance :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :return: Dict[str, Any] Signature: def deregister_container_instance ( cluster : str , instance_id : str , force : bool = False , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster string Yes instance_id string Yes force boolean false No Usage: { \"name\" : \"deregister-container-instance\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ecs.actions\" , \"func\" : \"deregister_container_instance\" , \"arguments\" : { \"cluster\" : \"\" , \"instance_id\" : \"\" } } } name : deregister-container-instance provider : arguments : cluster : '' instance_id : '' func : deregister_container_instance module : chaosaws.ecs.actions type : python type : action","title":"deregister_container_instance"},{"location":"drivers/aws/#describe_cluster","text":"Type probe Module chaosaws.ecs.probes Name describe_cluster Return mapping Returns AWS response describing the specified cluster Probe example: \u201csteady-state-hypothesis\u201d: { \u201ctitle\u201d: \u201cMyCluster has 3 running tasks\u201d, \u201cprobes\u201d: [{ \u201ctype\u201d: \u201cprobe\u201d, \u201cname\u201d: \u201cCluster running task count\u201d, \u201ctolerance\u201d: { \u201ctype\u201d: \u201cjsonpath\u201d, \u201cpath\u201d: $.clusters[0].runningTasksCount, \u201cexpect\u201d: 3 }, \u201cprovider\u201d: { \u201ctype\u201d: \u201cpython\u201d, \u201cmodule\u201d: \u201cchaosaws.ecs.probes\u201d, \u201cfunc\u201d: \u201cdescribe_cluster\u201d, \u201carguments\u201d: { \u201ccluster\u201d: \u201cMyCluster\u201d } } } } Full list of possible paths can be found: https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ecs.html#ECS.Client.describe_clusters Signature: def describe_cluster ( cluster : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster string Yes Usage: { \"name\" : \"describe-cluster\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ecs.probes\" , \"func\" : \"describe_cluster\" , \"arguments\" : { \"cluster\" : \"\" } } } name : describe-cluster provider : arguments : cluster : '' func : describe_cluster module : chaosaws.ecs.probes type : python type : probe","title":"describe_cluster"},{"location":"drivers/aws/#describe_service","text":"Type probe Module chaosaws.ecs.probes Name describe_service Return mapping Returns AWS response describing the specified cluster service Probe example: \u201csteady-state-hypothesis\u201d: { \u201ctitle\u201d: \u201cMyService pending count is 1\u201d, \u201cprobes\u201d: [{ \u201ctype\u201d: \u201cprobe\u201d, \u201cname\u201d: \u201cService pending count\u201d, \u201ctolerance\u201d: { \u201ctype\u201d: \u201cjsonpath\u201d, \u201cpath\u201d: $.services[0].pendingCount, \u201cexpect\u201d: 1 }, \u201cprovider\u201d: { \u201ctype\u201d: \u201cpython\u201d, \u201cmodule\u201d: \u201cchaosaws.ecs.probes\u201d, \u201cfunc\u201d: \u201cdescribe_service\u201d, \u201carguments\u201d: { \u201ccluster\u201d: \u201cMyCluster\u201d, \u201cservice\u201d: \u201cMyService\u201d } } }] } Full list of possible paths can be found: https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ecs.html#ECS.Client.describe_services Signature: def describe_service ( cluster : str , service : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster string Yes service string Yes Usage: { \"name\" : \"describe-service\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ecs.probes\" , \"func\" : \"describe_service\" , \"arguments\" : { \"cluster\" : \"\" , \"service\" : \"\" } } } name : describe-service provider : arguments : cluster : '' service : '' func : describe_service module : chaosaws.ecs.probes type : python type : probe","title":"describe_service"},{"location":"drivers/aws/#describe_tasks","text":"Type probe Module chaosaws.ecs.probes Name describe_tasks Return mapping Returns AWS response describing the tasks for a provided cluster Probe example: \u201csteady-state-hypothesis\u201d: { \u201ctitle\u201d: \u201cMyCluster tasks are healthy\u201d, \u201cprobes\u201d: [{ \u201ctype\u201d: \u201cprobe\u201d, \u201cname\u201d: \u201cfirst task is healthy\u201d, \u201ctolerance\u201d: { \u201ctype\u201d: \u201cjsonpath\u201d, \u201cpath\u201d: $.tasks[0].healthStatus, \u201cexpect\u201d: \u201cHEALTHY\u201d }, \u201cprovider\u201d: { \u201ctype\u201d: \u201cpython\u201d, \u201cmodule\u201d: \u201cchaosaws.ecs.probes\u201d, \u201cfunc\u201d: \u201cdescribe_tasks\u201d, \u201carguments\u201d: { \u201ccluster\u201d: \u201cMyCluster\u201d } } }] } Full list of possible paths can be found: https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ecs.html#ECS.Client.describe_tasks Signature: def describe_tasks ( cluster : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster string Yes Usage: { \"name\" : \"describe-tasks\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ecs.probes\" , \"func\" : \"describe_tasks\" , \"arguments\" : { \"cluster\" : \"\" } } } name : describe-tasks provider : arguments : cluster : '' func : describe_tasks module : chaosaws.ecs.probes type : python type : probe","title":"describe_tasks"},{"location":"drivers/aws/#service_is_deploying","text":"Type probe Module chaosaws.ecs.probes Name service_is_deploying Return boolean Checks to make sure there is not an in progress deployment Signature: def service_is_deploying ( cluster : str , service : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required cluster string Yes service string Yes Usage: { \"name\" : \"service-is-deploying\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ecs.probes\" , \"func\" : \"service_is_deploying\" , \"arguments\" : { \"cluster\" : \"\" , \"service\" : \"\" } } } name : service-is-deploying provider : arguments : cluster : '' service : '' func : service_is_deploying module : chaosaws.ecs.probes type : python type : probe","title":"service_is_deploying"},{"location":"drivers/aws/#set_service_deployment_configuration","text":"Type action Module chaosaws.ecs.actions Name set_service_deployment_configuration Return mapping Sets the maximum healthy count and minimum healthy percentage values for a services deployment configuration :param cluster: The ECS cluster name or ARN :param service: The ECS service name :param maximum_percent: The upper limit on the number of tasks a service is allowed to have in RUNNING or PENDING during deployment :param minimum_healthy_percent: The lower limit on the number of tasks a service must keep in RUNNING to be considered healthy during deployment :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :return: Dict[str, Any] Signature: def set_service_deployment_configuration ( cluster : str , service : str , maximum_percent : int = 200 , minimum_healthy_percent : int = 100 , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster string Yes service string Yes maximum_percent integer 200 No minimum_healthy_percent integer 100 No Usage: { \"name\" : \"set-service-deployment-configuration\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ecs.actions\" , \"func\" : \"set_service_deployment_configuration\" , \"arguments\" : { \"cluster\" : \"\" , \"service\" : \"\" } } } name : set-service-deployment-configuration provider : arguments : cluster : '' service : '' func : set_service_deployment_configuration module : chaosaws.ecs.actions type : python type : action","title":"set_service_deployment_configuration"},{"location":"drivers/aws/#set_service_placement_strategy","text":"Type action Module chaosaws.ecs.actions Name set_service_placement_strategy Return mapping Sets the service\u2019s instance placement strategy :param cluster: The ECS cluster name or ARN :param service: The ECS service name :param placement_type: The type of placement strategy to employ (random, spread, or binpack) :param placement_field: The field to apply the strategy against (eg: \u201cattribute:ecs.availability-zone\u201d) :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :return: Dict[str, Any] Signature: def set_service_placement_strategy ( cluster : str , service : str , placement_type : str , placement_field : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster string Yes service string Yes placement_type string Yes placement_field string null No Usage: { \"name\" : \"set-service-placement-strategy\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ecs.actions\" , \"func\" : \"set_service_placement_strategy\" , \"arguments\" : { \"cluster\" : \"\" , \"service\" : \"\" , \"placement_type\" : \"\" } } } name : set-service-placement-strategy provider : arguments : cluster : '' placement_type : '' service : '' func : set_service_placement_strategy module : chaosaws.ecs.actions type : python type : action","title":"set_service_placement_strategy"},{"location":"drivers/aws/#stop_random_tasks","text":"Type action Module chaosaws.ecs.actions Name stop_random_tasks Return list Stop a random number of tasks based on given task_count or task_percent You can specify a cluster by its ARN identifier or, if not provided, the default cluster will be picked up. :param cluster: The ECS cluster Name :param task_count: The number of tasks to stop :param task_percent: The percentage of total tasks to stop :param service: The ECS service name :param reason: An explanation of why the service was stopped :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :return: List[Dict[str, Any]] Signature: def stop_random_tasks ( cluster : str , task_count : int = None , task_percent : int = None , service : str = None , reason : str = 'Chaos Testing' , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required cluster string Yes task_count integer null No task_percent integer null No service string null No reason string \u201cChaos Testing\u201d No Usage: { \"name\" : \"stop-random-tasks\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ecs.actions\" , \"func\" : \"stop_random_tasks\" , \"arguments\" : { \"cluster\" : \"\" } } } name : stop-random-tasks provider : arguments : cluster : '' func : stop_random_tasks module : chaosaws.ecs.actions type : python type : action","title":"stop_random_tasks"},{"location":"drivers/aws/#stop_task","text":"Type action Module chaosaws.ecs.actions Name stop_task Return mapping Stop a given ECS task instance. If no task_id provided, a random task of the given service is stopped. You can specify a cluster by its ARN identifier or, if not provided, the default cluster will be picked up. Signature: def stop_task ( cluster : str = None , task_id : str = None , service : str = None , reason : str = 'Chaos Testing' , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster string null No task_id string null No service string null No reason string \u201cChaos Testing\u201d No Usage: { \"name\" : \"stop-task\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ecs.actions\" , \"func\" : \"stop_task\" } } name : stop-task provider : func : stop_task module : chaosaws.ecs.actions type : python type : action","title":"stop_task"},{"location":"drivers/aws/#tag_resource","text":"Type action Module chaosaws.ecs.actions Name tag_resource Return None Tags the provided resource(s) with provided tags ** For ECS resources, the long form ARN must be used https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-account-settings.html#ecs-resource-arn-timeline Example: { \u201ctags\u201d: [ {\u201ckey\u201d: \u201cMyTagKey\u201d, \u201cvalue\u201d: \u201cMyTagValue\u201d}, {\u201ckey\u201d: \u201cMyOtherTagKey\u201d, \u201cvalue\u201d: \u201cMyOtherTagValue\u201d} ], \u201cresource_arn\u201d: \u201carn:aws:ecs:us-east-1:123456789012:cluster/name\u201d } :param tags: A list of key/value pairs :param resource_arn: The ARN of the resource to tag. Valid resources: capacity providers, tasks, services, task definitions, clusters, and container instances :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :return: Dict[str, Any] Signature: def tag_resource ( tags : List [ Dict [ str , str ]], resource_arn : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required tags list Yes resource_arn string Yes Usage: { \"name\" : \"tag-resource\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ecs.actions\" , \"func\" : \"tag_resource\" , \"arguments\" : { \"tags\" : [], \"resource_arn\" : \"\" } } } name : tag-resource provider : arguments : resource_arn : '' tags : [] func : tag_resource module : chaosaws.ecs.actions type : python type : action","title":"tag_resource"},{"location":"drivers/aws/#untag_resource","text":"Type action Module chaosaws.ecs.actions Name untag_resource Return None Removes the given tags from the provided resource ** For ECS resources, the long form ARN must be used https://docs.aws.amazon.com/AmazonECS/latest/developerguide/ecs-account-settings.html#ecs-resource-arn-timeline Example: { \u201ctag_keys\u201d: [\u201cMyTagKey\u201d, \u201cMyOtherTagKey\u201d], \u201cresource_arn\u201d: \u201carn:aws:ecs:\u2026:service/cluster-name/service-name\u201d } :param tag_keys: A list of tag keys to remove :param resource_arn: The ARN of the resource to tag. Valid resources: capacity providers, tasks, services, task definitions, clusters, and container instances :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :return: Dict[str, Any] Signature: def untag_resource ( tag_keys : List [ str ], resource_arn : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required tag_keys list Yes resource_arn string Yes Usage: { \"name\" : \"untag-resource\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ecs.actions\" , \"func\" : \"untag_resource\" , \"arguments\" : { \"tag_keys\" : [], \"resource_arn\" : \"\" } } } name : untag-resource provider : arguments : resource_arn : '' tag_keys : [] func : untag_resource module : chaosaws.ecs.actions type : python type : action","title":"untag_resource"},{"location":"drivers/aws/#update_container_instances_state","text":"Type action Module chaosaws.ecs.actions Name update_container_instances_state Return mapping Modify the status of an ACTIVE ECS container instance :param cluster: The ECS cluster name or ARN :param container_instances: A list of container instance ids for ARNs :param status: The desired instance state (Valid States: ACTIVE, DRAINING) :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :return: Dict[str, Any] Signature: def update_container_instances_state ( cluster : str , container_instances : List [ str ], status : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster string Yes container_instances list Yes status string Yes Usage: { \"name\" : \"update-container-instances-state\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ecs.actions\" , \"func\" : \"update_container_instances_state\" , \"arguments\" : { \"cluster\" : \"\" , \"container_instances\" : [], \"status\" : \"\" } } } name : update-container-instances-state provider : arguments : cluster : '' container_instances : [] status : '' func : update_container_instances_state module : chaosaws.ecs.actions type : python type : action","title":"update_container_instances_state"},{"location":"drivers/aws/#update_desired_count","text":"Type action Module chaosaws.ecs.actions Name update_desired_count Return mapping Set the number of desired tasks for an ECS service :param cluster: The ECS cluster name or ARN or ARN :param service: The ECS service name :param desired_count: The number of instantiation of the tasks to run :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :return: Dict[str, Any] Example: \u201cmethod\u201d: { \u201ctype\u201d: \u201caction\u201d, \u201cname\u201d: \u201cupdate service\u201d, \u201cprovider\u201d: { \u201ctype\u201d: \u201cpython\u201d, \u201cmodule\u201d: \u201cchaosaws.ecs.actions\u201d, \u201cfunc\u201d: \u201cupdate_desired_count\u201d, \u201carguments\u201d: { \u201ccluster\u201d: \u201cmy_cluster_name\u201d, \u201cservice\u201d: \u201cmy_service_name\u201d, \u201cdesired_count\u201d: 6 } } } Signature: def update_desired_count ( cluster : str , service : str , desired_count : int , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster string Yes service string Yes desired_count integer Yes Usage: { \"name\" : \"update-desired-count\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ecs.actions\" , \"func\" : \"update_desired_count\" , \"arguments\" : { \"cluster\" : \"\" , \"service\" : \"\" , \"desired_count\" : 0 } } } name : update-desired-count provider : arguments : cluster : '' desired_count : 0 service : '' func : update_desired_count module : chaosaws.ecs.actions type : python type : action","title":"update_desired_count"},{"location":"drivers/aws/#eks","text":"","title":"eks"},{"location":"drivers/aws/#create_cluster","text":"Type action Module chaosaws.eks.actions Name create_cluster Return mapping Create a new EKS cluster. Signature: def create_cluster ( name : str , role_arn : str , vpc_config : Dict [ str , Any ], version : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required name string Yes role_arn string Yes vpc_config mapping Yes version string null No Usage: { \"name\" : \"create-cluster\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.eks.actions\" , \"func\" : \"create_cluster\" , \"arguments\" : { \"name\" : \"\" , \"role_arn\" : \"\" , \"vpc_config\" : {} } } } name : create-cluster provider : arguments : name : '' role_arn : '' vpc_config : {} func : create_cluster module : chaosaws.eks.actions type : python type : action","title":"create_cluster"},{"location":"drivers/aws/#delete_cluster_1","text":"Type action Module chaosaws.eks.actions Name delete_cluster Return mapping Delete the given EKS cluster. Signature: def delete_cluster ( name : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required name string null No Usage: { \"name\" : \"delete-cluster\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.eks.actions\" , \"func\" : \"delete_cluster\" } } name : delete-cluster provider : func : delete_cluster module : chaosaws.eks.actions type : python type : action","title":"delete_cluster"},{"location":"drivers/aws/#describe_cluster_1","text":"Type probe Module chaosaws.eks.probes Name describe_cluster Return mapping Describe an EKS cluster. Signature: def describe_cluster ( name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required name string Yes Usage: { \"name\" : \"describe-cluster\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.eks.probes\" , \"func\" : \"describe_cluster\" , \"arguments\" : { \"name\" : \"\" } } } name : describe-cluster provider : arguments : name : '' func : describe_cluster module : chaosaws.eks.probes type : python type : probe","title":"describe_cluster"},{"location":"drivers/aws/#list_clusters","text":"Type probe Module chaosaws.eks.probes Name list_clusters Return mapping List EKS clusters available to the authenticated account. Signature: def list_clusters ( configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required Usage: { \"name\" : \"list-clusters\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.eks.probes\" , \"func\" : \"list_clusters\" } } name : list-clusters provider : func : list_clusters module : chaosaws.eks.probes type : python type : probe","title":"list_clusters"},{"location":"drivers/aws/#elasticache","text":"","title":"elasticache"},{"location":"drivers/aws/#delete_cache_clusters","text":"Type action Module chaosaws.elasticache.actions Name delete_cache_clusters Return list Deletes one or more cache clusters and creates a final snapshot : cluster_ids: list: a list of one or more cache cluster ids final_snapshot_id: str: an identifier to give the final snapshot Signature: def delete_cache_clusters ( cluster_ids : List [ str ], final_snapshot_id : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required cluster_ids list Yes final_snapshot_id string null No Usage: { \"name\" : \"delete-cache-clusters\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.elasticache.actions\" , \"func\" : \"delete_cache_clusters\" , \"arguments\" : { \"cluster_ids\" : [] } } } name : delete-cache-clusters provider : arguments : cluster_ids : [] func : delete_cache_clusters module : chaosaws.elasticache.actions type : python type : action","title":"delete_cache_clusters"},{"location":"drivers/aws/#delete_replication_groups","text":"Type action Module chaosaws.elasticache.actions Name delete_replication_groups Return list Deletes one or more replication groups and creates a final snapshot : group_ids: list: a list of one or more replication group ids final_snapshot_id: str: an identifier to give the final snapshot retain_primary_cluster: bool (default: True): delete only the read replicas associated to the replication group, not the primary Signature: def delete_replication_groups ( group_ids : List [ str ], final_snapshot_id : str = None , retain_primary_cluster : bool = True , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required group_ids list Yes final_snapshot_id string null No retain_primary_cluster boolean true No Usage: { \"name\" : \"delete-replication-groups\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.elasticache.actions\" , \"func\" : \"delete_replication_groups\" , \"arguments\" : { \"group_ids\" : [] } } } name : delete-replication-groups provider : arguments : group_ids : [] func : delete_replication_groups module : chaosaws.elasticache.actions type : python type : action","title":"delete_replication_groups"},{"location":"drivers/aws/#describe_cache_cluster","text":"Type probe Module chaosaws.elasticache.probes Name describe_cache_cluster Return mapping Returns cache cluster data for given cluster :param cluster_id: str: the name of the cache cluster :param show_node_info: bool: show associated nodes (default: False) :param configuration: Configuration :param secrets: Secrets :example: { \u201ctype\u201d: \u201cprobe\u201d, \u201cname\u201d: \u201cvalidate cache cluster engine\u201d, \u201ctolerance\u201d: { \u201ctype\u201d: \u201cjsonpath\u201d, \u201cpath\u201d: $.CacheClusters[0].Engine, \u201cexpect\u201d: \u201cmemcached\u201d }, \u201cprovider\u201d: { \u201ctype\u201d: \u201cpython\u201d, \u201cmodule\u201d: \u201cchaosaws.elasticache.probes\u201d, \u201cfunc\u201d: \u201cdescribe_cache_cluster\u201d, \u201carguments\u201d: { \u201ccluster_id\u201d: \u201cMyTestCluster\u201d } } } Full list of possible paths can be found: https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/elasticache.html#ElastiCache.Client.describe_cache_clusters Signature: def describe_cache_cluster ( cluster_id : str , show_node_info : bool = False , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster_id string Yes show_node_info boolean false No Usage: { \"name\" : \"describe-cache-cluster\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.elasticache.probes\" , \"func\" : \"describe_cache_cluster\" , \"arguments\" : { \"cluster_id\" : \"\" } } } name : describe-cache-cluster provider : arguments : cluster_id : '' func : describe_cache_cluster module : chaosaws.elasticache.probes type : python type : probe","title":"describe_cache_cluster"},{"location":"drivers/aws/#get_cache_node_count","text":"Type probe Module chaosaws.elasticache.probes Name get_cache_node_count Return integer Returns the number of cache nodes associated to the cluster :param cluster_id: str: the name of the cache cluster :param configuration: Configuration :param secrets: Secrets :example: { \u201ctype\u201d: \u201cprobe\u201d, \u201cname\u201d: \u201cvalidate cache node count\u201d, \u201ctolerance\u201d: 3, \u201cprovider\u201d: { \u201ctype\u201d: \u201cpython\u201d, \u201cmodule\u201d: \u201cchaosaws.elasticache.probes\u201d, \u201cfunc\u201d: \u201cget_cache_node_count\u201d, \u201carguments\u201d: { \u201ccluster_id\u201d: \u201cMyTestCluster\u201d } } } Signature: def get_cache_node_count ( cluster_id : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required cluster_id string Yes Usage: { \"name\" : \"get-cache-node-count\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.elasticache.probes\" , \"func\" : \"get_cache_node_count\" , \"arguments\" : { \"cluster_id\" : \"\" } } } name : get-cache-node-count provider : arguments : cluster_id : '' func : get_cache_node_count module : chaosaws.elasticache.probes type : python type : probe","title":"get_cache_node_count"},{"location":"drivers/aws/#get_cache_node_status","text":"Type probe Module chaosaws.elasticache.probes Name get_cache_node_status Return string Returns the status of the given cache cluster :param cluster_id: str: the name of the cache cluster :param configuration: Configuration :param secrets: Secrets :example: { \u201ctype\u201d: \u201cprobe\u201d, \u201cname\u201d: \u201cvalidate cache node status\u201d, \u201ctolerance\u201d: \u201cavailable\u201d, \u201cprovider\u201d: { \u201ctype\u201d: \u201cpython\u201d, \u201cmodule\u201d: \u201cchaosaws.elasticache.probes\u201d, \u201cfunc\u201d: \u201cget_cache_node_status\u201d, \u201carguments\u201d: { \u201ccluster_id\u201d: \u201cMyTestCluster\u201d } } } Signature: def get_cache_node_status ( cluster_id : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> str : pass Arguments: Name Type Default Required cluster_id string Yes Usage: { \"name\" : \"get-cache-node-status\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.elasticache.probes\" , \"func\" : \"get_cache_node_status\" , \"arguments\" : { \"cluster_id\" : \"\" } } } name : get-cache-node-status provider : arguments : cluster_id : '' func : get_cache_node_status module : chaosaws.elasticache.probes type : python type : probe","title":"get_cache_node_status"},{"location":"drivers/aws/#reboot_cache_clusters","text":"Type action Module chaosaws.elasticache.actions Name reboot_cache_clusters Return list Reboots one or more nodes in a cache cluster. If no node ids are supplied, all nodes in the cluster will be rebooted : cluster_ids: list: a list of one or more cache cluster ids node_ids: list: a list of one or more node ids in to the cluster Signature: def reboot_cache_clusters ( cluster_ids : List [ str ], node_ids : List [ str ] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required cluster_ids list Yes node_ids list null No Usage: { \"name\" : \"reboot-cache-clusters\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.elasticache.actions\" , \"func\" : \"reboot_cache_clusters\" , \"arguments\" : { \"cluster_ids\" : [] } } } name : reboot-cache-clusters provider : arguments : cluster_ids : [] func : reboot_cache_clusters module : chaosaws.elasticache.actions type : python type : action","title":"reboot_cache_clusters"},{"location":"drivers/aws/#elbv2","text":"","title":"elbv2"},{"location":"drivers/aws/#all_targets_healthy","text":"Type probe Module chaosaws.elbv2.probes Name all_targets_healthy Return mapping Return true/false based on if all targets for listed target groups are healthy Signature: def all_targets_healthy ( tg_names : List [ str ], configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required tg_names list Yes Usage: { \"name\" : \"all-targets-healthy\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.elbv2.probes\" , \"func\" : \"all_targets_healthy\" , \"arguments\" : { \"tg_names\" : [] } } } name : all-targets-healthy provider : arguments : tg_names : [] func : all_targets_healthy module : chaosaws.elbv2.probes type : python type : probe","title":"all_targets_healthy"},{"location":"drivers/aws/#delete_load_balancer","text":"Type action Module chaosaws.elbv2.actions Name delete_load_balancer Return None Deletes the provided load balancer(s). : - load_balancer_names: a list of load balancer names Signature: def delete_load_balancer ( load_balancer_names : List [ str ], configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required load_balancer_names list Yes Usage: { \"name\" : \"delete-load-balancer\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.elbv2.actions\" , \"func\" : \"delete_load_balancer\" , \"arguments\" : { \"load_balancer_names\" : [] } } } name : delete-load-balancer provider : arguments : load_balancer_names : [] func : delete_load_balancer module : chaosaws.elbv2.actions type : python type : action","title":"delete_load_balancer"},{"location":"drivers/aws/#deregister_target","text":"Type action Module chaosaws.elbv2.actions Name deregister_target Return mapping Deregisters one random target from target group Signature: def deregister_target ( tg_name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required tg_name string Yes Usage: { \"name\" : \"deregister-target\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.elbv2.actions\" , \"func\" : \"deregister_target\" , \"arguments\" : { \"tg_name\" : \"\" } } } name : deregister-target provider : arguments : tg_name : '' func : deregister_target module : chaosaws.elbv2.actions type : python type : action","title":"deregister_target"},{"location":"drivers/aws/#set_security_groups","text":"Type action Module chaosaws.elbv2.actions Name set_security_groups Return list Changes the security groups for the specified load balancer(s). This action will replace the existing security groups on an application load balancer with the specified security groups. : - load_balancer_names: a list of load balancer names - security_group_ids: a list of security group ids returns: [ { \u2018LoadBalancerArn\u2019: \u2018string\u2019, \u2018SecurityGroupIds\u2019: [\u2018sg-0000000\u2019, \u2018sg-0000001\u2019] }, \u2026 ] Signature: def set_security_groups ( load_balancer_names : List [ str ], security_group_ids : List [ str ], configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required load_balancer_names list Yes security_group_ids list Yes Usage: { \"name\" : \"set-security-groups\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.elbv2.actions\" , \"func\" : \"set_security_groups\" , \"arguments\" : { \"load_balancer_names\" : [], \"security_group_ids\" : [] } } } name : set-security-groups provider : arguments : load_balancer_names : [] security_group_ids : [] func : set_security_groups module : chaosaws.elbv2.actions type : python type : action","title":"set_security_groups"},{"location":"drivers/aws/#set_subnets","text":"Type action Module chaosaws.elbv2.actions Name set_subnets Return list Changes the subnets for the specified application load balancer(s) This action will replace the existing security groups on an application load balancer with the specified security groups. : - load_balancer_names: a list of load balancer names - subnet_ids: a list of subnet ids returns: [ { \u2018LoadBalancerArn\u2019: \u2018string\u2019, \u2018AvailabilityZones\u2019: { \u2018ZoneName\u2019: \u2018string\u2019, \u2018SubnetId\u2019: \u2018string\u2019, \u2018LoadBalancerAddresses\u2019: [ { \u2018IpAddress\u2019: \u2018string\u2019, \u2018AllocationId\u2019: \u2018string\u2019 } ] } }, \u2026 ] Signature: def set_subnets ( load_balancer_names : List [ str ], subnet_ids : List [ str ], configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required load_balancer_names list Yes subnet_ids list Yes Usage: { \"name\" : \"set-subnets\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.elbv2.actions\" , \"func\" : \"set_subnets\" , \"arguments\" : { \"load_balancer_names\" : [], \"subnet_ids\" : [] } } } name : set-subnets provider : arguments : load_balancer_names : [] subnet_ids : [] func : set_subnets module : chaosaws.elbv2.actions type : python type : action","title":"set_subnets"},{"location":"drivers/aws/#targets_health_count","text":"Type probe Module chaosaws.elbv2.probes Name targets_health_count Return mapping Count of healthy/unhealthy targets per targetgroup Signature: def targets_health_count ( tg_names : List [ str ], configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required tg_names list Yes Usage: { \"name\" : \"targets-health-count\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.elbv2.probes\" , \"func\" : \"targets_health_count\" , \"arguments\" : { \"tg_names\" : [] } } } name : targets-health-count provider : arguments : tg_names : [] func : targets_health_count module : chaosaws.elbv2.probes type : python type : probe","title":"targets_health_count"},{"location":"drivers/aws/#emr","text":"","title":"emr"},{"location":"drivers/aws/#describe_cluster_2","text":"Type probe Module chaosaws.emr.probes Name describe_cluster Return mapping Describe a single EMR cluster :param cluster_id: The cluster id :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :return: Dict[str, Any] Signature: def describe_cluster ( cluster_id : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster_id string Yes Usage: { \"name\" : \"describe-cluster\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.emr.probes\" , \"func\" : \"describe_cluster\" , \"arguments\" : { \"cluster_id\" : \"\" } } } name : describe-cluster provider : arguments : cluster_id : '' func : describe_cluster module : chaosaws.emr.probes type : python type : probe","title":"describe_cluster"},{"location":"drivers/aws/#describe_instance_fleet","text":"Type probe Module chaosaws.emr.probes Name describe_instance_fleet Return mapping Describe a single EMR instance fleet :param cluster_id: The cluster id :param fleet_id: The instance fleet id :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :return: Dict[str, Any] Signature: def describe_instance_fleet ( cluster_id : str , fleet_id : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster_id string Yes fleet_id string Yes Usage: { \"name\" : \"describe-instance-fleet\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.emr.probes\" , \"func\" : \"describe_instance_fleet\" , \"arguments\" : { \"cluster_id\" : \"\" , \"fleet_id\" : \"\" } } } name : describe-instance-fleet provider : arguments : cluster_id : '' fleet_id : '' func : describe_instance_fleet module : chaosaws.emr.probes type : python type : probe","title":"describe_instance_fleet"},{"location":"drivers/aws/#describe_instance_group","text":"Type probe Module chaosaws.emr.probes Name describe_instance_group Return mapping Describe a single EMR instance group :param cluster_id: The cluster id :param group_id: The instance group id :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :return: Dict[str, Any] Signature: def describe_instance_group ( cluster_id : str , group_id : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster_id string Yes group_id string Yes Usage: { \"name\" : \"describe-instance-group\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.emr.probes\" , \"func\" : \"describe_instance_group\" , \"arguments\" : { \"cluster_id\" : \"\" , \"group_id\" : \"\" } } } name : describe-instance-group provider : arguments : cluster_id : '' group_id : '' func : describe_instance_group module : chaosaws.emr.probes type : python type : probe","title":"describe_instance_group"},{"location":"drivers/aws/#list_cluster_fleet_instances","text":"Type probe Module chaosaws.emr.probes Name list_cluster_fleet_instances Return mapping Get a list of instance fleet instances associated to the EMR cluster :param cluster_id: The cluster id :param fleet_id: The instance fleet id :param fleet_type: The instance fleet type :param instance_states: A list of instance states to include :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :return: Dict[str, Any] Signature: def list_cluster_fleet_instances ( cluster_id : str , fleet_id : str , fleet_type : str = None , instance_states : List [ str ] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster_id string Yes fleet_id string Yes fleet_type string null No instance_states list null No Usage: { \"name\" : \"list-cluster-fleet-instances\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.emr.probes\" , \"func\" : \"list_cluster_fleet_instances\" , \"arguments\" : { \"cluster_id\" : \"\" , \"fleet_id\" : \"\" } } } name : list-cluster-fleet-instances provider : arguments : cluster_id : '' fleet_id : '' func : list_cluster_fleet_instances module : chaosaws.emr.probes type : python type : probe","title":"list_cluster_fleet_instances"},{"location":"drivers/aws/#list_cluster_group_instances","text":"Type probe Module chaosaws.emr.probes Name list_cluster_group_instances Return mapping Get a list of instance group instances associated to the EMR cluster :param cluster_id: The cluster id :param group_id: The instance group id :param group_type: The instance group type :param instance_states: A list of instance states to include :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :return: Dict[str, Any] Signature: def list_cluster_group_instances ( cluster_id : str , group_id : str , group_type : str = None , instance_states : List [ str ] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster_id string Yes group_id string Yes group_type string null No instance_states list null No Usage: { \"name\" : \"list-cluster-group-instances\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.emr.probes\" , \"func\" : \"list_cluster_group_instances\" , \"arguments\" : { \"cluster_id\" : \"\" , \"group_id\" : \"\" } } } name : list-cluster-group-instances provider : arguments : cluster_id : '' group_id : '' func : list_cluster_group_instances module : chaosaws.emr.probes type : python type : probe","title":"list_cluster_group_instances"},{"location":"drivers/aws/#modify_cluster","text":"Type action Module chaosaws.emr.actions Name modify_cluster Return mapping Set the step concurrency level on the provided cluster :param cluster_id: The cluster id :param concurrency: The number of steps to execute concurrently (1 - 256) :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :return: Dict[str, Any] Signature: def modify_cluster ( cluster_id : str , concurrency : int , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster_id string Yes concurrency integer Yes Usage: { \"name\" : \"modify-cluster\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.emr.actions\" , \"func\" : \"modify_cluster\" , \"arguments\" : { \"cluster_id\" : \"\" , \"concurrency\" : 0 } } } name : modify-cluster provider : arguments : cluster_id : '' concurrency : 0 func : modify_cluster module : chaosaws.emr.actions type : python type : action","title":"modify_cluster"},{"location":"drivers/aws/#modify_instance_fleet","text":"Type action Module chaosaws.emr.actions Name modify_instance_fleet Return mapping Modify the on-demand and spot capacities for an instance fleet :param cluster_id: The cluster id :param fleet_id: The instance fleet id :param on_demand_capacity: Target capacity of on-demand units :param spot_capacity: Target capacity of spot units :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :return: Dict[str, Any] Signature: def modify_instance_fleet ( cluster_id : str , fleet_id : str , on_demand_capacity : int = None , spot_capacity : int = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster_id string Yes fleet_id string Yes on_demand_capacity integer null No spot_capacity integer null No Usage: { \"name\" : \"modify-instance-fleet\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.emr.actions\" , \"func\" : \"modify_instance_fleet\" , \"arguments\" : { \"cluster_id\" : \"\" , \"fleet_id\" : \"\" } } } name : modify-instance-fleet provider : arguments : cluster_id : '' fleet_id : '' func : modify_instance_fleet module : chaosaws.emr.actions type : python type : action","title":"modify_instance_fleet"},{"location":"drivers/aws/#modify_instance_groups_instance_count","text":"Type action Module chaosaws.emr.actions Name modify_instance_groups_instance_count Return mapping Modify the number of instances in an instance group :param cluster_id: The cluster id :param group_id: The instance group id :param instance_count: The target size for the instance group :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :return: Dict[str, Any] Signature: def modify_instance_groups_instance_count ( cluster_id : str , group_id : str , instance_count : int , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster_id string Yes group_id string Yes instance_count integer Yes Usage: { \"name\" : \"modify-instance-groups-instance-count\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.emr.actions\" , \"func\" : \"modify_instance_groups_instance_count\" , \"arguments\" : { \"cluster_id\" : \"\" , \"group_id\" : \"\" , \"instance_count\" : 0 } } } name : modify-instance-groups-instance-count provider : arguments : cluster_id : '' group_id : '' instance_count : 0 func : modify_instance_groups_instance_count module : chaosaws.emr.actions type : python type : action","title":"modify_instance_groups_instance_count"},{"location":"drivers/aws/#modify_instance_groups_shrink_policy","text":"Type action Module chaosaws.emr.actions Name modify_instance_groups_shrink_policy Return mapping Modify an instance groups shrink operations :param cluster_id: The cluster id :param group_id: The instance group id :param decommission_timeout: Timeout for decommissioning an instance :param terminate_instances: Instance id list to terminate when shrinking :param protect_instances: Instance id list to protect when shrinking :param termination_timeout: Override for list of instances to terminate :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :return: Dict[str, Any] Signature: def modify_instance_groups_shrink_policy ( cluster_id : str , group_id : str , decommission_timeout : int = None , terminate_instances : List [ str ] = None , protect_instances : List [ str ] = None , termination_timeout : int = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required cluster_id string Yes group_id string Yes decommission_timeout integer null No terminate_instances list null No protect_instances list null No termination_timeout integer null No Usage: { \"name\" : \"modify-instance-groups-shrink-policy\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.emr.actions\" , \"func\" : \"modify_instance_groups_shrink_policy\" , \"arguments\" : { \"cluster_id\" : \"\" , \"group_id\" : \"\" } } } name : modify-instance-groups-shrink-policy provider : arguments : cluster_id : '' group_id : '' func : modify_instance_groups_shrink_policy module : chaosaws.emr.actions type : python type : action","title":"modify_instance_groups_shrink_policy"},{"location":"drivers/aws/#iam","text":"","title":"iam"},{"location":"drivers/aws/#attach_role_policy","text":"Type action Module chaosaws.iam.actions Name attach_role_policy Return mapping Attach a role to a policy. Signature: def attach_role_policy ( arn : str , role_name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required arn string Yes role_name string Yes Usage: { \"name\" : \"attach-role-policy\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.iam.actions\" , \"func\" : \"attach_role_policy\" , \"arguments\" : { \"arn\" : \"\" , \"role_name\" : \"\" } } } name : attach-role-policy provider : arguments : arn : '' role_name : '' func : attach_role_policy module : chaosaws.iam.actions type : python type : action","title":"attach_role_policy"},{"location":"drivers/aws/#create_policy","text":"Type action Module chaosaws.iam.actions Name create_policy Return mapping Create a new IAM policy Signature: def create_policy ( name : str , policy : Dict [ str , Any ], path : str = '/' , description : str = '' , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required name string Yes policy mapping Yes path string \u201d/\u201d No description string \u201d\u201c No Usage: { \"name\" : \"create-policy\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.iam.actions\" , \"func\" : \"create_policy\" , \"arguments\" : { \"name\" : \"\" , \"policy\" : {} } } } name : create-policy provider : arguments : name : '' policy : {} func : create_policy module : chaosaws.iam.actions type : python type : action","title":"create_policy"},{"location":"drivers/aws/#detach_role_policy","text":"Type action Module chaosaws.iam.actions Name detach_role_policy Return mapping Detach a role from a policy. Signature: def detach_role_policy ( arn : str , role_name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required arn string Yes role_name string Yes Usage: { \"name\" : \"detach-role-policy\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.iam.actions\" , \"func\" : \"detach_role_policy\" , \"arguments\" : { \"arn\" : \"\" , \"role_name\" : \"\" } } } name : detach-role-policy provider : arguments : arn : '' role_name : '' func : detach_role_policy module : chaosaws.iam.actions type : python type : action","title":"detach_role_policy"},{"location":"drivers/aws/#get_policy","text":"Type probe Module chaosaws.iam.probes Name get_policy Return boolean Get a policy by its ARN Signature: def get_policy ( arn : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required arn string Yes Usage: { \"name\" : \"get-policy\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.iam.probes\" , \"func\" : \"get_policy\" , \"arguments\" : { \"arn\" : \"\" } } } name : get-policy provider : arguments : arn : '' func : get_policy module : chaosaws.iam.probes type : python type : probe","title":"get_policy"},{"location":"drivers/aws/#rds","text":"","title":"rds"},{"location":"drivers/aws/#cluster_membership_count","text":"Type probe Module chaosaws.rds.probes Name cluster_membership_count Return integer Signature: def cluster_membership_count ( cluster_id : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required cluster_id string Yes Usage: { \"name\" : \"cluster-membership-count\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.rds.probes\" , \"func\" : \"cluster_membership_count\" , \"arguments\" : { \"cluster_id\" : \"\" } } } name : cluster-membership-count provider : arguments : cluster_id : '' func : cluster_membership_count module : chaosaws.rds.probes type : python type : probe","title":"cluster_membership_count"},{"location":"drivers/aws/#cluster_status","text":"Type probe Module chaosaws.rds.probes Name cluster_status Return Union[str, List[str]] Signature: def cluster_status ( cluster_id : str = None , filters : List [ Dict [ str , Any ]] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Union [ str , List [ str ]]: pass Arguments: Name Type Default Required cluster_id string null No filters list null No Usage: { \"name\" : \"cluster-status\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.rds.probes\" , \"func\" : \"cluster_status\" } } name : cluster-status provider : func : cluster_status module : chaosaws.rds.probes type : python type : probe","title":"cluster_status"},{"location":"drivers/aws/#delete_db_cluster","text":"Type action Module chaosaws.rds.actions Name delete_db_cluster Return mapping Deletes an Aurora DB cluster db_cluster_identifier: the identifier of the cluster to delete skip_final_snapshot: boolean (true): determines whether or not to perform a final snapshot of the cluster before deletion db_snapshot_identifier: the identifier to give the final rds snapshot Signature: def delete_db_cluster ( db_cluster_identifier : str , skip_final_snapshot : bool = True , db_snapshot_identifier : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required db_cluster_identifier string Yes skip_final_snapshot boolean true No db_snapshot_identifier string null No Usage: { \"name\" : \"delete-db-cluster\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.rds.actions\" , \"func\" : \"delete_db_cluster\" , \"arguments\" : { \"db_cluster_identifier\" : \"\" } } } name : delete-db-cluster provider : arguments : db_cluster_identifier : '' func : delete_db_cluster module : chaosaws.rds.actions type : python type : action","title":"delete_db_cluster"},{"location":"drivers/aws/#delete_db_cluster_endpoint","text":"Type action Module chaosaws.rds.actions Name delete_db_cluster_endpoint Return mapping Deletes the custom endpoint of an Aurora cluster db_cluster_identifier: the identifier of the cluster to delete the endpoint from Signature: def delete_db_cluster_endpoint ( db_cluster_identifier : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required db_cluster_identifier string Yes Usage: { \"name\" : \"delete-db-cluster-endpoint\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.rds.actions\" , \"func\" : \"delete_db_cluster_endpoint\" , \"arguments\" : { \"db_cluster_identifier\" : \"\" } } } name : delete-db-cluster-endpoint provider : arguments : db_cluster_identifier : '' func : delete_db_cluster_endpoint module : chaosaws.rds.actions type : python type : action","title":"delete_db_cluster_endpoint"},{"location":"drivers/aws/#delete_db_instance","text":"Type action Module chaosaws.rds.actions Name delete_db_instance Return mapping Deletes a RDS instance db_instance_identifier: the identifier of the RDS instance to delete skip_final_snapshot: boolean (true): determines whether or not to perform a final snapshot of the rds instance before deletion db_snapshot_identifier: the identifier to give the final rds snapshot delete_automated_backups: boolean (true): determines if the automated backups of the rds instance are deleted immediately Signature: def delete_db_instance ( db_instance_identifier : str , skip_final_snapshot : bool = True , db_snapshot_identifier : str = None , delete_automated_backups : bool = True , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required db_instance_identifier string Yes skip_final_snapshot boolean true No db_snapshot_identifier string null No delete_automated_backups boolean true No Usage: { \"name\" : \"delete-db-instance\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.rds.actions\" , \"func\" : \"delete_db_instance\" , \"arguments\" : { \"db_instance_identifier\" : \"\" } } } name : delete-db-instance provider : arguments : db_instance_identifier : '' func : delete_db_instance module : chaosaws.rds.actions type : python type : action","title":"delete_db_instance"},{"location":"drivers/aws/#failover_db_cluster","text":"Type action Module chaosaws.rds.actions Name failover_db_cluster Return mapping Forces a failover for a DB cluster. Signature: def failover_db_cluster ( db_cluster_identifier : str , target_db_instance_identifier : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required db_cluster_identifier string Yes target_db_instance_identifier string null No Usage: { \"name\" : \"failover-db-cluster\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.rds.actions\" , \"func\" : \"failover_db_cluster\" , \"arguments\" : { \"db_cluster_identifier\" : \"\" } } } name : failover-db-cluster provider : arguments : db_cluster_identifier : '' func : failover_db_cluster module : chaosaws.rds.actions type : python type : action","title":"failover_db_cluster"},{"location":"drivers/aws/#instance_status","text":"Type probe Module chaosaws.rds.probes Name instance_status Return Union[str, List[str]] Signature: def instance_status ( instance_id : str = None , filters : List [ Dict [ str , Any ]] = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Union [ str , List [ str ]]: pass Arguments: Name Type Default Required instance_id string null No filters list null No Usage: { \"name\" : \"instance-status\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.rds.probes\" , \"func\" : \"instance_status\" } } name : instance-status provider : func : instance_status module : chaosaws.rds.probes type : python type : probe","title":"instance_status"},{"location":"drivers/aws/#reboot_db_instance","text":"Type action Module chaosaws.rds.actions Name reboot_db_instance Return mapping Forces a reboot of your DB instance. Signature: def reboot_db_instance ( db_instance_identifier : str , force_failover : bool = False , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required db_instance_identifier string Yes force_failover boolean false No Usage: { \"name\" : \"reboot-db-instance\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.rds.actions\" , \"func\" : \"reboot_db_instance\" , \"arguments\" : { \"db_instance_identifier\" : \"\" } } } name : reboot-db-instance provider : arguments : db_instance_identifier : '' func : reboot_db_instance module : chaosaws.rds.actions type : python type : action","title":"reboot_db_instance"},{"location":"drivers/aws/#stop_db_cluster","text":"Type action Module chaosaws.rds.actions Name stop_db_cluster Return mapping Stop a RDS Cluster db_cluster_identifier: the identifier of the RDS cluster to stop Signature: def stop_db_cluster ( db_cluster_identifier : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required db_cluster_identifier string Yes Usage: { \"name\" : \"stop-db-cluster\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.rds.actions\" , \"func\" : \"stop_db_cluster\" , \"arguments\" : { \"db_cluster_identifier\" : \"\" } } } name : stop-db-cluster provider : arguments : db_cluster_identifier : '' func : stop_db_cluster module : chaosaws.rds.actions type : python type : action","title":"stop_db_cluster"},{"location":"drivers/aws/#stop_db_instance","text":"Type action Module chaosaws.rds.actions Name stop_db_instance Return mapping Stops a RDS DB instance db_instance_identifier: the instance identifier of the RDS instance db_snapshot_identifier: the name of the DB snapshot made before stop Signature: def stop_db_instance ( db_instance_identifier : str , db_snapshot_identifier : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required db_instance_identifier string Yes db_snapshot_identifier string null No Usage: { \"name\" : \"stop-db-instance\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.rds.actions\" , \"func\" : \"stop_db_instance\" , \"arguments\" : { \"db_instance_identifier\" : \"\" } } } name : stop-db-instance provider : arguments : db_instance_identifier : '' func : stop_db_instance module : chaosaws.rds.actions type : python type : action","title":"stop_db_instance"},{"location":"drivers/aws/#route53","text":"","title":"route53"},{"location":"drivers/aws/#associate_vpc_with_zone","text":"Type action Module chaosaws.route53.actions Name associate_vpc_with_zone Return mapping Associate a VPC with a private hosted zone :param zone_id: The hosted zone id :param vpc_id: The id of the vpc :param vpc_region: The region of the vpc :param configuration: access values used by actions/probes :param comment: a comment regarding the request :param secrets: values that need to be passed on to actions/probes :returns: Dict[str, Any] Signature: def associate_vpc_with_zone ( zone_id : str , vpc_id : str , vpc_region : str , comment : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required zone_id string Yes vpc_id string Yes vpc_region string Yes comment string null No Usage: { \"name\" : \"associate-vpc-with-zone\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.route53.actions\" , \"func\" : \"associate_vpc_with_zone\" , \"arguments\" : { \"zone_id\" : \"\" , \"vpc_id\" : \"\" , \"vpc_region\" : \"\" } } } name : associate-vpc-with-zone provider : arguments : vpc_id : '' vpc_region : '' zone_id : '' func : associate_vpc_with_zone module : chaosaws.route53.actions type : python type : action","title":"associate_vpc_with_zone"},{"location":"drivers/aws/#disassociate_vpc_from_zone","text":"Type action Module chaosaws.route53.actions Name disassociate_vpc_from_zone Return mapping Remove an association between a VPC and a private hosted zone :param zone_id: The hosted zone id :param vpc_id: The id of the vpc :param vpc_region: The region of the vpc :param comment: A note regarding the disassociation request :param configuration: access values used by actions/probes :param secrets: values that need to be passed on to actions/probes :returns: Dict[str, Any] Signature: def disassociate_vpc_from_zone ( zone_id : str , vpc_id : str , vpc_region : str , comment : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required zone_id string Yes vpc_id string Yes vpc_region string Yes comment string null No Usage: { \"name\" : \"disassociate-vpc-from-zone\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.route53.actions\" , \"func\" : \"disassociate_vpc_from_zone\" , \"arguments\" : { \"zone_id\" : \"\" , \"vpc_id\" : \"\" , \"vpc_region\" : \"\" } } } name : disassociate-vpc-from-zone provider : arguments : vpc_id : '' vpc_region : '' zone_id : '' func : disassociate_vpc_from_zone module : chaosaws.route53.actions type : python type : action","title":"disassociate_vpc_from_zone"},{"location":"drivers/aws/#ssm","text":"","title":"ssm"},{"location":"drivers/aws/#create_document","text":"Type action Module chaosaws.ssm.actions Name create_document Return mapping creates a Systems Manager (SSM) document. An SSM document defines the actions that SSM performs on your managed. For more information about SSM documents: https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-ssm-docs.html https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ssm.html#SSM.Client.create_document Signature: def create_document ( path_content : str , name : str , version_name : str = None , document_type : str = None , document_format : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required path_content string Yes name string Yes version_name string null No document_type string null No document_format string null No Usage: { \"name\" : \"create-document\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ssm.actions\" , \"func\" : \"create_document\" , \"arguments\" : { \"path_content\" : \"\" , \"name\" : \"\" } } } name : create-document provider : arguments : name : '' path_content : '' func : create_document module : chaosaws.ssm.actions type : python type : action","title":"create_document"},{"location":"drivers/aws/#delete_document","text":"Type action Module chaosaws.ssm.actions Name delete_document Return mapping creates a Systems Manager (SSM) document. An SSM document defines the actions that SSM performs on your managed. For more information about SSM documents: https://docs.aws.amazon.com/systems-manager/latest/userguide/sysman-ssm-docs.html https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ssm.html#SSM.Client.create_document Signature: def delete_document ( name : str , version_name : str = None , force : bool = True , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required name string Yes version_name string null No force boolean true No Usage: { \"name\" : \"delete-document\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ssm.actions\" , \"func\" : \"delete_document\" , \"arguments\" : { \"name\" : \"\" } } } name : delete-document provider : arguments : name : '' func : delete_document module : chaosaws.ssm.actions type : python type : action","title":"delete_document"},{"location":"drivers/aws/#send_command","text":"Type action Module chaosaws.ssm.actions Name send_command Return mapping Runs commands on one or more managed instances. An SSM document defines the actions that SSM performs on your managed. For more information about SSM SendCommand: https://docs.aws.amazon.com/systems-manager/latest/APIReference/API_SendCommand.html https://boto3.amazonaws.com/v1/documentation/api/latest/reference/services/ssm.html#SSM.Client.send_command Signature: def send_command ( document_name : str , targets : List [ Dict [ str , Any ]] = None , document_version : str = None , parameters : Dict [ str , Any ] = None , timeout_seconds : int = None , max_concurrency : str = None , max_errors : str = None , region : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required document_name string Yes targets list null No document_version string null No parameters mapping null No timeout_seconds integer null No max_concurrency string null No max_errors string null No region string null No Usage: { \"name\" : \"send-command\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaws.ssm.actions\" , \"func\" : \"send_command\" , \"arguments\" : { \"document_name\" : \"\" } } } name : send-command provider : arguments : document_name : '' func : send_command module : chaosaws.ssm.actions type : python type : action","title":"send_command"},{"location":"drivers/azure/","text":"Extension chaosazure \u00b6 Version 0.10.0 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-azure This project is a collection of actions and probes , gathered as an extension to the Chaos Toolkit . It targets the Microsoft Azure platform. Install \u00b6 This package requires Python 3.5+ To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install -U chaostoolkit-azure Usage \u00b6 To use the probes and actions from this package, add the following to your experiment file: { \"type\" : \"action\" , \"name\" : \"start-service-factory-chaos\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.vm.actions\" , \"func\" : \"stop_machines\" , \"secrets\" : [ \"azure\" ], \"arguments\" : { \"parameters\" : { \"TimeToRunInSeconds\" : 45 } } } } That\u2019s it! Please explore the code to see existing probes and actions. Configuration \u00b6 This extension uses the Azure SDK libraries under the hood. The Azure SDK library expects that you have a tenant and client identifier, as well as a client secret and subscription, that allows you to authenticate with the Azure resource management API. Configuration values for the Chaos Toolkit Extension for Azure can come from several sources: Experiment file Azure credential file The extension will first try to load the configuration from the experiment file . If configuration is not provided in the experiment file , it will try to load it from the Azure credential file . Credentials \u00b6 Secrets in the Experiment file { \"secrets\" : { \"azure\" : { \"client_id\" : \"your-super-secret-client-id\" , \"client_secret\" : \"your-even-more-super-secret-client-secret\" , \"tenant_id\" : \"your-tenant-id\" } } } You can retrieve secretes as well from environment or HashiCorp vault . If you are not working with Public Global Azure, e.g. China Cloud You can set the cloud environment. { \"client_id\" : \"your-super-secret-client-id\" , \"client_secret\" : \"your-even-more-super-secret-client-secret\" , \"tenant_id\" : \"your-tenant-id\" , \"azure_cloud\" : \"AZURE_CHINA_CLOUD\" } Available cloud names: AZURE_CHINA_CLOUD AZURE_GERMAN_CLOUD AZURE_PUBLIC_CLOUD AZURE_US_GOV_CLOUD Secrets in the Azure credential file You can retrieve a credentials file with your subscription ID already in place by signing in to Azure using the az login command followed by the az ad sp create-for-rbac command az login az ad sp create-for-rbac --sdk-auth > credentials.json credentials.json: { \"subscriptionId\" : \"<azure_aubscription_id>\" , \"tenantId\" : \"<tenant_id>\" , \"clientId\" : \"<application_id>\" , \"clientSecret\" : \"<application_secret>\" , \"activeDirectoryEndpointUrl\" : \"https://login.microsoftonline.com\" , \"resourceManagerEndpointUrl\" : \"https://management.azure.com/\" , \"activeDirectoryGraphResourceId\" : \"https://graph.windows.net/\" , \"sqlManagementEndpointUrl\" : \"https://management.core.windows.net:8443/\" , \"galleryEndpointUrl\" : \"https://gallery.azure.com/\" , \"managementEndpointUrl\" : \"https://management.core.windows.net/\" } Store the path to the file in an environment variable called AZURE_AUTH_LOCATION and make sure that your experiment does NOT contain secrets section. Subscription \u00b6 Additionally you need to provide the Azure subscription id. Subscription id in the experiment file { \"configuration\" : { \"azure_subscription_id\" : \"your-azure-subscription-id\" } } Configuration may be as well retrieved from an environment . An old, but deprecated way of doing it was as follows, this still works but should not be favoured over the previous approaches as it\u2019s not the Chaos Toolkit way to pass structured configurations. { \"configuration\" : { \"azure\" : { \"subscription_id\" : \"your-azure-subscription-id\" } } } Subscription id in the Azure credential file Credential file described in the previous \u201cCredential\u201d section contains as well subscription id. If AZURE_AUTH_LOCATION is set and subscription id is NOT set in the experiment definition, extension will try to load it from the credential file. Putting it all together \u00b6 Here is a full example for an experiment containing secrets and configuration: { \"version\" : \"1.0.0\" , \"title\" : \"...\" , \"description\" : \"...\" , \"tags\" : [ \"azure\" , \"kubernetes\" , \"aks\" , \"node\" ], \"configuration\" : { \"azure_subscription_id\" : \"xxx\" }, \"secrets\" : { \"azure\" : { \"client_id\" : \"xxx\" , \"client_secret\" : \"xxx\" , \"tenant_id\" : \"xxx\" } }, \"steady-state-hypothesis\" : { \"title\" : \"Services are all available and healthy\" , \"probes\" : [ { \"type\" : \"probe\" , \"name\" : \"consumer-service-must-still-respond\" , \"tolerance\" : 200 , \"provider\" : { \"type\" : \"http\" , \"url\" : \"https://some-url/\" } } ] }, \"method\" : [ { \"type\" : \"action\" , \"name\" : \"restart-node-at-random\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.machine.actions\" , \"func\" : \"restart_machines\" , \"secrets\" : [ \"azure\" ], \"config\" : [ \"azure_subscription_id\" ] } } ], \"rollbacks\" : [] } Contribute \u00b6 If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. The Chaos Toolkit projects require all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR. Develop \u00b6 If you wish to develop on this project, make sure to install the development dependencies. But first, create a virtual environment and then install those dependencies. $ pip install -r requirements-dev.txt -r requirements.txt Then, point your environment to this directory: $ python setup.py develop Now, you can edit the files and they will be automatically be seen by your environment, even when running from the chaos command locally. Test \u00b6 To run the tests for the project execute the following: $ pytest Exported Activities \u00b6 aks \u00b6 delete_node \u00b6 Type action Module chaosazure.aks.actions Name delete_node Return None Delete a node at random from a managed Azure Kubernetes Service. Be aware : Deleting a node is an invasive action. You will not be able to recover the node once you deleted it. \u2013 filter : str Filter the managed AKS. If the filter is omitted all AKS in the subscription will be selected as potential chaos candidates. Filtering example: \u2018where resourceGroup==\u201dmyresourcegroup\u201d and name=\u201dmyresourcename\u201d\u2019 Signature: def delete_node ( filter : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required filter string null No Usage: { \"name\" : \"delete-node\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.aks.actions\" , \"func\" : \"delete_node\" } } name : delete-node provider : func : delete_node module : chaosazure.aks.actions type : python type : action restart_node \u00b6 Type action Module chaosazure.aks.actions Name restart_node Return None Restart a node at random from a managed Azure Kubernetes Service. \u2013 filter : str Filter the managed AKS. If the filter is omitted all AKS in the subscription will be selected as potential chaos candidates. Filtering example: \u2018where resourceGroup==\u201dmyresourcegroup\u201d and name=\u201dmyresourcename\u201d\u2019 Signature: def restart_node ( filter : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required filter string null No Usage: { \"name\" : \"restart-node\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.aks.actions\" , \"func\" : \"restart_node\" } } name : restart-node provider : func : restart_node module : chaosazure.aks.actions type : python type : action stop_node \u00b6 Type action Module chaosazure.aks.actions Name stop_node Return None Stop a node at random from a managed Azure Kubernetes Service. \u2013 filter : str Filter the managed AKS. If the filter is omitted all AKS in the subscription will be selected as potential chaos candidates. Filtering example: \u2018where resourceGroup==\u201dmyresourcegroup\u201d and name=\u201dmyresourcename\u201d\u2019 Signature: def stop_node ( filter : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required filter string null No Usage: { \"name\" : \"stop-node\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.aks.actions\" , \"func\" : \"stop_node\" } } name : stop-node provider : func : stop_node module : chaosazure.aks.actions type : python type : action machine \u00b6 burn_io \u00b6 Type action Module chaosazure.machine.actions Name burn_io Return None Increases the Disk I/O operations per second of the virtual machine. \u2013 filter : str, optional Filter the virtual machines. If the filter is omitted all machines in the subscription will be selected as potential chaos candidates. duration : int, optional How long the burn lasts. Defaults to 60 seconds. timeout : int Additional wait time (in seconds) for filling operation to be completed Getting and sending data from/to Azure may take some time so it\u2019s not recommended to set this value to less than 30s. Defaults to 60 seconds. Some calling examples. Deep dive into the filter syntax: https://docs.microsoft.com/en-us/azure/kusto/query/ burn_io(\u201cwhere resourceGroup==\u2019rg\u2019\u201c, configuration=c, secrets=s) Increase the I/O operations per second of all machines from the group \u2018rg\u2019 burn_io(\u201cwhere resourceGroup==\u2019rg\u2019 and name=\u2019name\u2019\u201c, configuration=c, secrets=s) Increase the I/O operations per second of the machine from the group \u2018rg\u2019 having the name \u2018name\u2019 burn_io(\u201cwhere resourceGroup==\u2019rg\u2019 | sample 2\u201d, configuration=c, secrets=s) Increase the I/O operations per second of two machines at random from the group \u2018rg\u2019 Signature: def burn_io ( filter : str = None , duration : int = 60 , timeout : int = 60 , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required filter string null No duration integer 60 No timeout integer 60 No Usage: { \"name\" : \"burn-io\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.machine.actions\" , \"func\" : \"burn_io\" } } name : burn-io provider : func : burn_io module : chaosazure.machine.actions type : python type : action count_machines \u00b6 Type probe Module chaosazure.machine.probes Name count_machines Return integer Return count of Azure virtual machines. \u2013 filter : str Filter the virtual machines. If the filter is omitted all machines in the subscription will be selected for the probe. Filtering example: \u2018where resourceGroup==\u201dmyresourcegroup\u201d and name=\u201dmyresourcename\u201d\u2019 Signature: def count_machines ( filter : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required filter string null No Usage: { \"name\" : \"count-machines\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.machine.probes\" , \"func\" : \"count_machines\" } } name : count-machines provider : func : count_machines module : chaosazure.machine.probes type : python type : probe delete_machines \u00b6 Type action Module chaosazure.machine.actions Name delete_machines Return None Delete virtual machines at random. Be aware : Deleting a machine is an invasive action. You will not be able to recover the machine once you deleted it. \u2013 filter : str, optional Filter the virtual machines. If the filter is omitted all machines in the subscription will be selected as potential chaos candidates. Some calling examples. Deep dive into the filter syntax: https://docs.microsoft.com/en-us/azure/kusto/query/ delete_machines(\u201cwhere resourceGroup==\u2019rg\u2019\u201c, c, s) Delete all machines from the group \u2018rg\u2019 delete_machines(\u201cwhere resourceGroup==\u2019rg\u2019 and name=\u2019name\u2019\u201c, c, s) Delete the machine from the group \u2018rg\u2019 having the name \u2018name\u2019 delete_machines(\u201cwhere resourceGroup==\u2019rg\u2019 | sample 2\u201d, c, s) Delete two machines at random from the group \u2018rg\u2019 Signature: def delete_machines ( filter : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required filter string null No Usage: { \"name\" : \"delete-machines\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.machine.actions\" , \"func\" : \"delete_machines\" } } name : delete-machines provider : func : delete_machines module : chaosazure.machine.actions type : python type : action describe_machines \u00b6 Type probe Module chaosazure.machine.probes Name describe_machines Return None Describe Azure virtual machines. \u2013 filter : str Filter the virtual machines. If the filter is omitted all machines in the subscription will be selected for the probe. Filtering example: \u2018where resourceGroup==\u201dmyresourcegroup\u201d and name=\u201dmyresourcename\u201d\u2019 Signature: def describe_machines ( filter : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required filter string null No Usage: { \"name\" : \"describe-machines\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.machine.probes\" , \"func\" : \"describe_machines\" } } name : describe-machines provider : func : describe_machines module : chaosazure.machine.probes type : python type : probe fill_disk \u00b6 Type action Module chaosazure.machine.actions Name fill_disk Return None Fill the disk with random data. \u2013 filter : str, optional Filter the virtual machines. If the filter is omitted all machines in the subscription will be selected as potential chaos candidates. duration : int, optional Lifetime of the file created. Defaults to 120 seconds. timeout : int Additional wait time (in seconds) for filling operation to be completed. Getting and sending data from/to Azure may take some time so it\u2019s not recommended to set this value to less than 30s. Defaults to 60 seconds. size : int Size of the file created on the disk. Defaults to 1GB. path : str, optional The absolute path to write the fill file into. Defaults: C:/burn for Windows clients, /root/burn for Linux clients. Some calling examples. Deep dive into the filter syntax: https://docs.microsoft.com/en-us/azure/kusto/query/ fill_disk(\u201cwhere resourceGroup==\u2019rg\u2019\u201c, configuration=c, secrets=s) Fill all machines from the group \u2018rg\u2019 fill_disk(\u201cwhere resourceGroup==\u2019rg\u2019 and name=\u2019name\u2019\u201c, configuration=c, secrets=s) Fill the machine from the group \u2018rg\u2019 having the name \u2018name\u2019 fill_disk(\u201cwhere resourceGroup==\u2019rg\u2019 | sample 2\u201d, configuration=c, secrets=s) Fill two machines at random from the group \u2018rg\u2019 Signature: def fill_disk ( filter : str = None , duration : int = 120 , timeout : int = 60 , size : int = 1000 , path : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required filter string null No duration integer 120 No timeout integer 60 No size integer 1000 No path string null No Usage: { \"name\" : \"fill-disk\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.machine.actions\" , \"func\" : \"fill_disk\" } } name : fill-disk provider : func : fill_disk module : chaosazure.machine.actions type : python type : action network_latency \u00b6 Type action Module chaosazure.machine.actions Name network_latency Return None Increases the response time of the virtual machine. \u2013 filter : str, optional Filter the virtual machines. If the filter is omitted all machines in the subscription will be selected as potential chaos candidates. duration : int, optional How long the latency lasts. Defaults to 60 seconds. timeout : int Additional wait time (in seconds) for filling operation to be completed Getting and sending data from/to Azure may take some time so it\u2019s not recommended to set this value to less than 30s. Defaults to 60 seconds. delay : int Added delay in ms. Defaults to 200. jitter : int Variance of the delay in ms. Defaults to 50. Some calling examples. Deep dive into the filter syntax: https://docs.microsoft.com/en-us/azure/kusto/query/ network_latency(\u201cwhere resourceGroup==\u2019rg\u2019\u201c, configuration=c, secrets=s) Increase the latency of all machines from the group \u2018rg\u2019 network_latency(\u201cwhere resourceGroup==\u2019rg\u2019 and name=\u2019name\u2019\u201c, configuration=c, secrets=s) Increase the latecy of the machine from the group \u2018rg\u2019 having the name \u2018name\u2019 network_latency(\u201cwhere resourceGroup==\u2019rg\u2019 | sample 2\u201d, configuration=c, secrets=s) Increase the latency of two machines at random from the group \u2018rg\u2019 Signature: def network_latency ( filter : str = None , duration : int = 60 , delay : int = 200 , jitter : int = 50 , timeout : int = 60 , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required filter string null No duration integer 60 No delay integer 200 No jitter integer 50 No timeout integer 60 No Usage: { \"name\" : \"network-latency\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.machine.actions\" , \"func\" : \"network_latency\" } } name : network-latency provider : func : network_latency module : chaosazure.machine.actions type : python type : action restart_machines \u00b6 Type action Module chaosazure.machine.actions Name restart_machines Return None Restart virtual machines at random. \u2013 filter : str, optional Filter the virtual machines. If the filter is omitted all machines in the subscription will be selected as potential chaos candidates. Some calling examples. Deep dive into the filter syntax: https://docs.microsoft.com/en-us/azure/kusto/query/ restart_machines(\u201cwhere resourceGroup==\u2019rg\u2019\u201c, c, s) Restart all machines from the group \u2018rg\u2019 restart_machines(\u201cwhere resourceGroup==\u2019rg\u2019 and name=\u2019name\u2019\u201c, c, s) Restart the machine from the group \u2018rg\u2019 having the name \u2018name\u2019 restart_machines(\u201cwhere resourceGroup==\u2019rg\u2019 | sample 2\u201d, c, s) Restart two machines at random from the group \u2018rg\u2019 Signature: def restart_machines ( filter : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required filter string null No Usage: { \"name\" : \"restart-machines\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.machine.actions\" , \"func\" : \"restart_machines\" } } name : restart-machines provider : func : restart_machines module : chaosazure.machine.actions type : python type : action start_machines \u00b6 Type action Module chaosazure.machine.actions Name start_machines Return None Start virtual machines at random. Thought as a rollback action. \u2013 filter : str, optional Filter the virtual machines. If the filter is omitted all machines in the subscription will be selected as potential chaos candidates. Some calling examples. Deep dive into the filter syntax: https://docs.microsoft.com/en-us/azure/kusto/query/ start_machines(\u201cwhere resourceGroup==\u2019rg\u2019\u201c, c, s) Start all stopped machines from the group \u2018rg\u2019 start_machines(\u201cwhere resourceGroup==\u2019rg\u2019 and name=\u2019name\u2019\u201c, c, s) Start the stopped machine from the group \u2018rg\u2019 having the name \u2018name\u2019 start_machines(\u201cwhere resourceGroup==\u2019rg\u2019 | sample 2\u201d, c, s) Start two stopped machines at random from the group \u2018rg\u2019 Signature: def start_machines ( filter : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required filter string null No Usage: { \"name\" : \"start-machines\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.machine.actions\" , \"func\" : \"start_machines\" } } name : start-machines provider : func : start_machines module : chaosazure.machine.actions type : python type : action stop_machines \u00b6 Type action Module chaosazure.machine.actions Name stop_machines Return None Stop virtual machines at random. \u2013 filter : str, optional Filter the virtual machines. If the filter is omitted all machines in the subscription will be selected as potential chaos candidates. Some calling examples. Deep dive into the filter syntax: https://docs.microsoft.com/en-us/azure/kusto/query/ stop_machines(\u201cwhere resourceGroup==\u2019rg\u2019\u201c, c, s) Stop all machines from the group \u2018rg\u2019 stop_machines(\u201cwhere resourceGroup==\u2019mygroup\u2019 and name=\u2019myname\u2019\u201c, c, s) Stop the machine from the group \u2018mygroup\u2019 having the name \u2018myname\u2019 stop_machines(\u201cwhere resourceGroup==\u2019mygroup\u2019 | sample 2\u201d, c, s) Stop two machines at random from the group \u2018mygroup\u2019 Signature: def stop_machines ( filter : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required filter string null No Usage: { \"name\" : \"stop-machines\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.machine.actions\" , \"func\" : \"stop_machines\" } } name : stop-machines provider : func : stop_machines module : chaosazure.machine.actions type : python type : action stress_cpu \u00b6 Type action Module chaosazure.machine.actions Name stress_cpu Return None Stress CPU up to 100% at virtual machines. \u2013 filter : str, optional Filter the virtual machines. If the filter is omitted all machines in the subscription will be selected as potential chaos candidates. duration : int, optional Duration of the stress test (in seconds) that generates high CPU usage. Defaults to 120 seconds. timeout : int Additional wait time (in seconds) for stress operation to be completed. Getting and sending data from/to Azure may take some time so it\u2019s not recommended to set this value to less than 30s. Defaults to 60 seconds. Some calling examples. Deep dive into the filter syntax: https://docs.microsoft.com/en-us/azure/kusto/query/ stress_cpu(\u201cwhere resourceGroup==\u2019rg\u2019\u201c, configuration=c, secrets=s) Stress all machines from the group \u2018rg\u2019 stress_cpu(\u201cwhere resourceGroup==\u2019rg\u2019 and name=\u2019name\u2019\u201c, configuration=c, secrets=s) Stress the machine from the group \u2018rg\u2019 having the name \u2018name\u2019 stress_cpu(\u201cwhere resourceGroup==\u2019rg\u2019 | sample 2\u201d, configuration=c, secrets=s) Stress two machines at random from the group \u2018rg\u2019 Signature: def stress_cpu ( filter : str = None , duration : int = 120 , timeout : int = 60 , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required filter string null No duration integer 120 No timeout integer 60 No Usage: { \"name\" : \"stress-cpu\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.machine.actions\" , \"func\" : \"stress_cpu\" } } name : stress-cpu provider : func : stress_cpu module : chaosazure.machine.actions type : python type : action vmss \u00b6 burn_io \u00b6 Type action Module chaosazure.vmss.actions Name burn_io Return None Increases the Disk I/O operations per second of the VMSS machine. Similar to the burn_io action of the machine.actions module. Signature: Arguments: Name Type Default Required filter string null No duration integer 60 No timeout integer 60 No instance_criteria object null No Usage: { \"name\" : \"burn-io\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.vmss.actions\" , \"func\" : \"burn_io\" } } name : burn-io provider : func : burn_io module : chaosazure.vmss.actions type : python type : action count_instances \u00b6 Type probe Module chaosazure.vmss.probes Name count_instances Return integer Return count of VMSS instances. \u2013 filter : str Filter the VMSS instance. If the filter is omitted all machines in the subscription will be selected for the probe. Filtering example: \u2018where resourceGroup==\u201dmyresourcegroup\u201d and name=\u201dmyresourcename\u201d\u2019 Signature: def count_instances ( filter : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required filter string null No Usage: { \"name\" : \"count-instances\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.vmss.probes\" , \"func\" : \"count_instances\" } } name : count-instances provider : func : count_instances module : chaosazure.vmss.probes type : python type : probe deallocate_vmss \u00b6 Type action Module chaosazure.vmss.actions Name deallocate_vmss Return None Deallocate a virtual machine scale set instance at random. \u2013 filter : str Filter the virtual machine scale set. If the filter is omitted all virtual machine scale sets in the subscription will be selected as potential chaos candidates. Filtering example: \u2018where resourceGroup==\u201dmyresourcegroup\u201d and name=\u201dmyresourcename\u201d\u2019 Signature: Arguments: Name Type Default Required filter string null No instance_criteria object null No Usage: { \"name\" : \"deallocate-vmss\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.vmss.actions\" , \"func\" : \"deallocate_vmss\" } } name : deallocate-vmss provider : func : deallocate_vmss module : chaosazure.vmss.actions type : python type : action delete_vmss \u00b6 Type action Module chaosazure.vmss.actions Name delete_vmss Return None Delete a virtual machine scale set instance at random. Be aware : Deleting a VMSS instance is an invasive action. You will not be able to recover the VMSS instance once you deleted it. \u2013 filter : str Filter the virtual machine scale set. If the filter is omitted all virtual machine scale sets in the subscription will be selected as potential chaos candidates. Filtering example: \u2018where resourceGroup==\u201dmyresourcegroup\u201d and name=\u201dmyresourcename\u201d\u2019 Signature: Arguments: Name Type Default Required filter string null No instance_criteria object null No Usage: { \"name\" : \"delete-vmss\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.vmss.actions\" , \"func\" : \"delete_vmss\" } } name : delete-vmss provider : func : delete_vmss module : chaosazure.vmss.actions type : python type : action fill_disk \u00b6 Type action Module chaosazure.vmss.actions Name fill_disk Return None Fill the VMSS machine disk with random data. Similar to the fill_disk action of the machine.actions module. Signature: Arguments: Name Type Default Required filter string null No duration integer 120 No timeout integer 60 No size integer 1000 No path string null No instance_criteria object null No Usage: { \"name\" : \"fill-disk\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.vmss.actions\" , \"func\" : \"fill_disk\" } } name : fill-disk provider : func : fill_disk module : chaosazure.vmss.actions type : python type : action network_latency \u00b6 Type action Module chaosazure.vmss.actions Name network_latency Return None Increases the response time of the virtual machine. Similar to the network_latency action of the machine.actions module. Signature: Arguments: Name Type Default Required filter string null No duration integer 60 No delay integer 200 No jitter integer 50 No timeout integer 60 No instance_criteria object null No Usage: { \"name\" : \"network-latency\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.vmss.actions\" , \"func\" : \"network_latency\" } } name : network-latency provider : func : network_latency module : chaosazure.vmss.actions type : python type : action restart_vmss \u00b6 Type action Module chaosazure.vmss.actions Name restart_vmss Return None Restart a virtual machine scale set instance at random. \u2013 filter : str Filter the virtual machine scale set. If the filter is omitted all virtual machine scale sets in the subscription will be selected as potential chaos candidates. Filtering example: \u2018where resourceGroup==\u201dmyresourcegroup\u201d and name=\u201dmyresourcename\u201d\u2019 Signature: Arguments: Name Type Default Required filter string null No instance_criteria object null No Usage: { \"name\" : \"restart-vmss\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.vmss.actions\" , \"func\" : \"restart_vmss\" } } name : restart-vmss provider : func : restart_vmss module : chaosazure.vmss.actions type : python type : action stop_vmss \u00b6 Type action Module chaosazure.vmss.actions Name stop_vmss Return None Stops instances from the filtered scale set either at random or by a defined instance criteria. \u2013 filter : str Filter the virtual machine scale set. If the filter is omitted all virtual machine scale sets in the subscription will be selected as potential chaos candidates. Filtering example: \u2018where resourceGroup==\u201dmyresourcegroup\u201d and name=\u201dmyresourcename\u201d\u2019 instance_criteria : Iterable[Mapping[str, any]] Allows specification of criteria for selection of a given virtual machine scale set instance. If the instance_criteria is omitted, an instance will be chosen at random. All of the criteria within each item of the Iterable must match, i.e. AND logic is applied. The first item with all matching criterion will be used to select the instance. Criteria example: [ {\u201cname\u201d: \u201cmyVMSSInstance1\u201d}, { \u201cname\u201d: \u201cmyVMSSInstance2\u201d, \u201cinstanceId\u201d: \u201c2\u201d } {\u201cinstanceId\u201d: \u201c3\u201d}, ] If the instances include two items. One with name = myVMSSInstance4 and instanceId = 2. The other with name = myVMSSInstance2 and instanceId = 3. The criteria {\u201cinstanceId\u201d: \u201c3\u201d} will be the first match since both the name and the instanceId did not match on the first criteria. Signature: Arguments: Name Type Default Required filter string null No instance_criteria object null No Usage: { \"name\" : \"stop-vmss\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.vmss.actions\" , \"func\" : \"stop_vmss\" } } name : stop-vmss provider : func : stop_vmss module : chaosazure.vmss.actions type : python type : action stress_vmss_instance_cpu \u00b6 Type action Module chaosazure.vmss.actions Name stress_vmss_instance_cpu Return None Signature: Arguments: Name Type Default Required filter string null No duration integer 120 No timeout integer 60 No instance_criteria object null No Usage: { \"name\" : \"stress-vmss-instance-cpu\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.vmss.actions\" , \"func\" : \"stress_vmss_instance_cpu\" } } name : stress-vmss-instance-cpu provider : func : stress_vmss_instance_cpu module : chaosazure.vmss.actions type : python type : action webapp \u00b6 delete_webapp \u00b6 Type action Module chaosazure.webapp.actions Name delete_webapp Return None Delete a web app at random. ***Be aware**: Deleting a web app is an invasive action. You will not be able to recover the web app once you deleted it. \u2013 filter : str Filter the web apps. If the filter is omitted all web apps in the subscription will be selected as potential chaos candidates. Filtering example: \u2018where resourceGroup==\u201dmyresourcegroup\u201d and name=\u201dmyresourcename\u201d\u2019 Signature: def delete_webapp ( filter : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required filter string null No Usage: { \"name\" : \"delete-webapp\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.webapp.actions\" , \"func\" : \"delete_webapp\" } } name : delete-webapp provider : func : delete_webapp module : chaosazure.webapp.actions type : python type : action restart_webapp \u00b6 Type action Module chaosazure.webapp.actions Name restart_webapp Return None Restart a web app at random. \u2013 filter : str Filter the web apps. If the filter is omitted all web apps in the subscription will be selected as potential chaos candidates. Filtering example: \u2018where resourceGroup==\u201dmyresourcegroup\u201d and name=\u201dmyresourcename\u201d\u2019 Signature: def restart_webapp ( filter : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required filter string null No Usage: { \"name\" : \"restart-webapp\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.webapp.actions\" , \"func\" : \"restart_webapp\" } } name : restart-webapp provider : func : restart_webapp module : chaosazure.webapp.actions type : python type : action start_webapp \u00b6 Type action Module chaosazure.webapp.actions Name start_webapp Return None Start a web app at random. \u2013 filter : str Filter the web apps. If the filter is omitted all web apps in the subscription will be selected as potential chaos candidates. Filtering example: \u2018where resourceGroup==\u201dmyresourcegroup\u201d and name=\u201dmyresourcename\u201d\u2019 Signature: def start_webapp ( filter : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required filter string null No Usage: { \"name\" : \"start-webapp\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.webapp.actions\" , \"func\" : \"start_webapp\" } } name : start-webapp provider : func : start_webapp module : chaosazure.webapp.actions type : python type : action stop_webapp \u00b6 Type action Module chaosazure.webapp.actions Name stop_webapp Return None Stop a web app at random. \u2013 filter : str Filter the web apps. If the filter is omitted all web apps in the subscription will be selected as potential chaos candidates. Filtering example: \u2018where resourceGroup==\u201dmyresourcegroup\u201d and name=\u201dmyresourcename\u201d\u2019 Signature: def stop_webapp ( filter : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required filter string null No Usage: { \"name\" : \"stop-webapp\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.webapp.actions\" , \"func\" : \"stop_webapp\" } } name : stop-webapp provider : func : stop_webapp module : chaosazure.webapp.actions type : python type : action","title":"Azure"},{"location":"drivers/azure/#extension-chaosazure","text":"Version 0.10.0 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-azure This project is a collection of actions and probes , gathered as an extension to the Chaos Toolkit . It targets the Microsoft Azure platform.","title":"Extension chaosazure"},{"location":"drivers/azure/#install","text":"This package requires Python 3.5+ To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install -U chaostoolkit-azure","title":"Install"},{"location":"drivers/azure/#usage","text":"To use the probes and actions from this package, add the following to your experiment file: { \"type\" : \"action\" , \"name\" : \"start-service-factory-chaos\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.vm.actions\" , \"func\" : \"stop_machines\" , \"secrets\" : [ \"azure\" ], \"arguments\" : { \"parameters\" : { \"TimeToRunInSeconds\" : 45 } } } } That\u2019s it! Please explore the code to see existing probes and actions.","title":"Usage"},{"location":"drivers/azure/#configuration","text":"This extension uses the Azure SDK libraries under the hood. The Azure SDK library expects that you have a tenant and client identifier, as well as a client secret and subscription, that allows you to authenticate with the Azure resource management API. Configuration values for the Chaos Toolkit Extension for Azure can come from several sources: Experiment file Azure credential file The extension will first try to load the configuration from the experiment file . If configuration is not provided in the experiment file , it will try to load it from the Azure credential file .","title":"Configuration"},{"location":"drivers/azure/#credentials","text":"Secrets in the Experiment file { \"secrets\" : { \"azure\" : { \"client_id\" : \"your-super-secret-client-id\" , \"client_secret\" : \"your-even-more-super-secret-client-secret\" , \"tenant_id\" : \"your-tenant-id\" } } } You can retrieve secretes as well from environment or HashiCorp vault . If you are not working with Public Global Azure, e.g. China Cloud You can set the cloud environment. { \"client_id\" : \"your-super-secret-client-id\" , \"client_secret\" : \"your-even-more-super-secret-client-secret\" , \"tenant_id\" : \"your-tenant-id\" , \"azure_cloud\" : \"AZURE_CHINA_CLOUD\" } Available cloud names: AZURE_CHINA_CLOUD AZURE_GERMAN_CLOUD AZURE_PUBLIC_CLOUD AZURE_US_GOV_CLOUD Secrets in the Azure credential file You can retrieve a credentials file with your subscription ID already in place by signing in to Azure using the az login command followed by the az ad sp create-for-rbac command az login az ad sp create-for-rbac --sdk-auth > credentials.json credentials.json: { \"subscriptionId\" : \"<azure_aubscription_id>\" , \"tenantId\" : \"<tenant_id>\" , \"clientId\" : \"<application_id>\" , \"clientSecret\" : \"<application_secret>\" , \"activeDirectoryEndpointUrl\" : \"https://login.microsoftonline.com\" , \"resourceManagerEndpointUrl\" : \"https://management.azure.com/\" , \"activeDirectoryGraphResourceId\" : \"https://graph.windows.net/\" , \"sqlManagementEndpointUrl\" : \"https://management.core.windows.net:8443/\" , \"galleryEndpointUrl\" : \"https://gallery.azure.com/\" , \"managementEndpointUrl\" : \"https://management.core.windows.net/\" } Store the path to the file in an environment variable called AZURE_AUTH_LOCATION and make sure that your experiment does NOT contain secrets section.","title":"Credentials"},{"location":"drivers/azure/#subscription","text":"Additionally you need to provide the Azure subscription id. Subscription id in the experiment file { \"configuration\" : { \"azure_subscription_id\" : \"your-azure-subscription-id\" } } Configuration may be as well retrieved from an environment . An old, but deprecated way of doing it was as follows, this still works but should not be favoured over the previous approaches as it\u2019s not the Chaos Toolkit way to pass structured configurations. { \"configuration\" : { \"azure\" : { \"subscription_id\" : \"your-azure-subscription-id\" } } } Subscription id in the Azure credential file Credential file described in the previous \u201cCredential\u201d section contains as well subscription id. If AZURE_AUTH_LOCATION is set and subscription id is NOT set in the experiment definition, extension will try to load it from the credential file.","title":"Subscription"},{"location":"drivers/azure/#putting-it-all-together","text":"Here is a full example for an experiment containing secrets and configuration: { \"version\" : \"1.0.0\" , \"title\" : \"...\" , \"description\" : \"...\" , \"tags\" : [ \"azure\" , \"kubernetes\" , \"aks\" , \"node\" ], \"configuration\" : { \"azure_subscription_id\" : \"xxx\" }, \"secrets\" : { \"azure\" : { \"client_id\" : \"xxx\" , \"client_secret\" : \"xxx\" , \"tenant_id\" : \"xxx\" } }, \"steady-state-hypothesis\" : { \"title\" : \"Services are all available and healthy\" , \"probes\" : [ { \"type\" : \"probe\" , \"name\" : \"consumer-service-must-still-respond\" , \"tolerance\" : 200 , \"provider\" : { \"type\" : \"http\" , \"url\" : \"https://some-url/\" } } ] }, \"method\" : [ { \"type\" : \"action\" , \"name\" : \"restart-node-at-random\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.machine.actions\" , \"func\" : \"restart_machines\" , \"secrets\" : [ \"azure\" ], \"config\" : [ \"azure_subscription_id\" ] } } ], \"rollbacks\" : [] }","title":"Putting it all together"},{"location":"drivers/azure/#contribute","text":"If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. The Chaos Toolkit projects require all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR.","title":"Contribute"},{"location":"drivers/azure/#develop","text":"If you wish to develop on this project, make sure to install the development dependencies. But first, create a virtual environment and then install those dependencies. $ pip install -r requirements-dev.txt -r requirements.txt Then, point your environment to this directory: $ python setup.py develop Now, you can edit the files and they will be automatically be seen by your environment, even when running from the chaos command locally.","title":"Develop"},{"location":"drivers/azure/#test","text":"To run the tests for the project execute the following: $ pytest","title":"Test"},{"location":"drivers/azure/#exported-activities","text":"","title":"Exported Activities"},{"location":"drivers/azure/#aks","text":"","title":"aks"},{"location":"drivers/azure/#delete_node","text":"Type action Module chaosazure.aks.actions Name delete_node Return None Delete a node at random from a managed Azure Kubernetes Service. Be aware : Deleting a node is an invasive action. You will not be able to recover the node once you deleted it. \u2013 filter : str Filter the managed AKS. If the filter is omitted all AKS in the subscription will be selected as potential chaos candidates. Filtering example: \u2018where resourceGroup==\u201dmyresourcegroup\u201d and name=\u201dmyresourcename\u201d\u2019 Signature: def delete_node ( filter : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required filter string null No Usage: { \"name\" : \"delete-node\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.aks.actions\" , \"func\" : \"delete_node\" } } name : delete-node provider : func : delete_node module : chaosazure.aks.actions type : python type : action","title":"delete_node"},{"location":"drivers/azure/#restart_node","text":"Type action Module chaosazure.aks.actions Name restart_node Return None Restart a node at random from a managed Azure Kubernetes Service. \u2013 filter : str Filter the managed AKS. If the filter is omitted all AKS in the subscription will be selected as potential chaos candidates. Filtering example: \u2018where resourceGroup==\u201dmyresourcegroup\u201d and name=\u201dmyresourcename\u201d\u2019 Signature: def restart_node ( filter : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required filter string null No Usage: { \"name\" : \"restart-node\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.aks.actions\" , \"func\" : \"restart_node\" } } name : restart-node provider : func : restart_node module : chaosazure.aks.actions type : python type : action","title":"restart_node"},{"location":"drivers/azure/#stop_node","text":"Type action Module chaosazure.aks.actions Name stop_node Return None Stop a node at random from a managed Azure Kubernetes Service. \u2013 filter : str Filter the managed AKS. If the filter is omitted all AKS in the subscription will be selected as potential chaos candidates. Filtering example: \u2018where resourceGroup==\u201dmyresourcegroup\u201d and name=\u201dmyresourcename\u201d\u2019 Signature: def stop_node ( filter : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required filter string null No Usage: { \"name\" : \"stop-node\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.aks.actions\" , \"func\" : \"stop_node\" } } name : stop-node provider : func : stop_node module : chaosazure.aks.actions type : python type : action","title":"stop_node"},{"location":"drivers/azure/#machine","text":"","title":"machine"},{"location":"drivers/azure/#burn_io","text":"Type action Module chaosazure.machine.actions Name burn_io Return None Increases the Disk I/O operations per second of the virtual machine. \u2013 filter : str, optional Filter the virtual machines. If the filter is omitted all machines in the subscription will be selected as potential chaos candidates. duration : int, optional How long the burn lasts. Defaults to 60 seconds. timeout : int Additional wait time (in seconds) for filling operation to be completed Getting and sending data from/to Azure may take some time so it\u2019s not recommended to set this value to less than 30s. Defaults to 60 seconds. Some calling examples. Deep dive into the filter syntax: https://docs.microsoft.com/en-us/azure/kusto/query/ burn_io(\u201cwhere resourceGroup==\u2019rg\u2019\u201c, configuration=c, secrets=s) Increase the I/O operations per second of all machines from the group \u2018rg\u2019 burn_io(\u201cwhere resourceGroup==\u2019rg\u2019 and name=\u2019name\u2019\u201c, configuration=c, secrets=s) Increase the I/O operations per second of the machine from the group \u2018rg\u2019 having the name \u2018name\u2019 burn_io(\u201cwhere resourceGroup==\u2019rg\u2019 | sample 2\u201d, configuration=c, secrets=s) Increase the I/O operations per second of two machines at random from the group \u2018rg\u2019 Signature: def burn_io ( filter : str = None , duration : int = 60 , timeout : int = 60 , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required filter string null No duration integer 60 No timeout integer 60 No Usage: { \"name\" : \"burn-io\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.machine.actions\" , \"func\" : \"burn_io\" } } name : burn-io provider : func : burn_io module : chaosazure.machine.actions type : python type : action","title":"burn_io"},{"location":"drivers/azure/#count_machines","text":"Type probe Module chaosazure.machine.probes Name count_machines Return integer Return count of Azure virtual machines. \u2013 filter : str Filter the virtual machines. If the filter is omitted all machines in the subscription will be selected for the probe. Filtering example: \u2018where resourceGroup==\u201dmyresourcegroup\u201d and name=\u201dmyresourcename\u201d\u2019 Signature: def count_machines ( filter : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required filter string null No Usage: { \"name\" : \"count-machines\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.machine.probes\" , \"func\" : \"count_machines\" } } name : count-machines provider : func : count_machines module : chaosazure.machine.probes type : python type : probe","title":"count_machines"},{"location":"drivers/azure/#delete_machines","text":"Type action Module chaosazure.machine.actions Name delete_machines Return None Delete virtual machines at random. Be aware : Deleting a machine is an invasive action. You will not be able to recover the machine once you deleted it. \u2013 filter : str, optional Filter the virtual machines. If the filter is omitted all machines in the subscription will be selected as potential chaos candidates. Some calling examples. Deep dive into the filter syntax: https://docs.microsoft.com/en-us/azure/kusto/query/ delete_machines(\u201cwhere resourceGroup==\u2019rg\u2019\u201c, c, s) Delete all machines from the group \u2018rg\u2019 delete_machines(\u201cwhere resourceGroup==\u2019rg\u2019 and name=\u2019name\u2019\u201c, c, s) Delete the machine from the group \u2018rg\u2019 having the name \u2018name\u2019 delete_machines(\u201cwhere resourceGroup==\u2019rg\u2019 | sample 2\u201d, c, s) Delete two machines at random from the group \u2018rg\u2019 Signature: def delete_machines ( filter : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required filter string null No Usage: { \"name\" : \"delete-machines\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.machine.actions\" , \"func\" : \"delete_machines\" } } name : delete-machines provider : func : delete_machines module : chaosazure.machine.actions type : python type : action","title":"delete_machines"},{"location":"drivers/azure/#describe_machines","text":"Type probe Module chaosazure.machine.probes Name describe_machines Return None Describe Azure virtual machines. \u2013 filter : str Filter the virtual machines. If the filter is omitted all machines in the subscription will be selected for the probe. Filtering example: \u2018where resourceGroup==\u201dmyresourcegroup\u201d and name=\u201dmyresourcename\u201d\u2019 Signature: def describe_machines ( filter : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required filter string null No Usage: { \"name\" : \"describe-machines\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.machine.probes\" , \"func\" : \"describe_machines\" } } name : describe-machines provider : func : describe_machines module : chaosazure.machine.probes type : python type : probe","title":"describe_machines"},{"location":"drivers/azure/#fill_disk","text":"Type action Module chaosazure.machine.actions Name fill_disk Return None Fill the disk with random data. \u2013 filter : str, optional Filter the virtual machines. If the filter is omitted all machines in the subscription will be selected as potential chaos candidates. duration : int, optional Lifetime of the file created. Defaults to 120 seconds. timeout : int Additional wait time (in seconds) for filling operation to be completed. Getting and sending data from/to Azure may take some time so it\u2019s not recommended to set this value to less than 30s. Defaults to 60 seconds. size : int Size of the file created on the disk. Defaults to 1GB. path : str, optional The absolute path to write the fill file into. Defaults: C:/burn for Windows clients, /root/burn for Linux clients. Some calling examples. Deep dive into the filter syntax: https://docs.microsoft.com/en-us/azure/kusto/query/ fill_disk(\u201cwhere resourceGroup==\u2019rg\u2019\u201c, configuration=c, secrets=s) Fill all machines from the group \u2018rg\u2019 fill_disk(\u201cwhere resourceGroup==\u2019rg\u2019 and name=\u2019name\u2019\u201c, configuration=c, secrets=s) Fill the machine from the group \u2018rg\u2019 having the name \u2018name\u2019 fill_disk(\u201cwhere resourceGroup==\u2019rg\u2019 | sample 2\u201d, configuration=c, secrets=s) Fill two machines at random from the group \u2018rg\u2019 Signature: def fill_disk ( filter : str = None , duration : int = 120 , timeout : int = 60 , size : int = 1000 , path : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required filter string null No duration integer 120 No timeout integer 60 No size integer 1000 No path string null No Usage: { \"name\" : \"fill-disk\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.machine.actions\" , \"func\" : \"fill_disk\" } } name : fill-disk provider : func : fill_disk module : chaosazure.machine.actions type : python type : action","title":"fill_disk"},{"location":"drivers/azure/#network_latency","text":"Type action Module chaosazure.machine.actions Name network_latency Return None Increases the response time of the virtual machine. \u2013 filter : str, optional Filter the virtual machines. If the filter is omitted all machines in the subscription will be selected as potential chaos candidates. duration : int, optional How long the latency lasts. Defaults to 60 seconds. timeout : int Additional wait time (in seconds) for filling operation to be completed Getting and sending data from/to Azure may take some time so it\u2019s not recommended to set this value to less than 30s. Defaults to 60 seconds. delay : int Added delay in ms. Defaults to 200. jitter : int Variance of the delay in ms. Defaults to 50. Some calling examples. Deep dive into the filter syntax: https://docs.microsoft.com/en-us/azure/kusto/query/ network_latency(\u201cwhere resourceGroup==\u2019rg\u2019\u201c, configuration=c, secrets=s) Increase the latency of all machines from the group \u2018rg\u2019 network_latency(\u201cwhere resourceGroup==\u2019rg\u2019 and name=\u2019name\u2019\u201c, configuration=c, secrets=s) Increase the latecy of the machine from the group \u2018rg\u2019 having the name \u2018name\u2019 network_latency(\u201cwhere resourceGroup==\u2019rg\u2019 | sample 2\u201d, configuration=c, secrets=s) Increase the latency of two machines at random from the group \u2018rg\u2019 Signature: def network_latency ( filter : str = None , duration : int = 60 , delay : int = 200 , jitter : int = 50 , timeout : int = 60 , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required filter string null No duration integer 60 No delay integer 200 No jitter integer 50 No timeout integer 60 No Usage: { \"name\" : \"network-latency\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.machine.actions\" , \"func\" : \"network_latency\" } } name : network-latency provider : func : network_latency module : chaosazure.machine.actions type : python type : action","title":"network_latency"},{"location":"drivers/azure/#restart_machines","text":"Type action Module chaosazure.machine.actions Name restart_machines Return None Restart virtual machines at random. \u2013 filter : str, optional Filter the virtual machines. If the filter is omitted all machines in the subscription will be selected as potential chaos candidates. Some calling examples. Deep dive into the filter syntax: https://docs.microsoft.com/en-us/azure/kusto/query/ restart_machines(\u201cwhere resourceGroup==\u2019rg\u2019\u201c, c, s) Restart all machines from the group \u2018rg\u2019 restart_machines(\u201cwhere resourceGroup==\u2019rg\u2019 and name=\u2019name\u2019\u201c, c, s) Restart the machine from the group \u2018rg\u2019 having the name \u2018name\u2019 restart_machines(\u201cwhere resourceGroup==\u2019rg\u2019 | sample 2\u201d, c, s) Restart two machines at random from the group \u2018rg\u2019 Signature: def restart_machines ( filter : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required filter string null No Usage: { \"name\" : \"restart-machines\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.machine.actions\" , \"func\" : \"restart_machines\" } } name : restart-machines provider : func : restart_machines module : chaosazure.machine.actions type : python type : action","title":"restart_machines"},{"location":"drivers/azure/#start_machines","text":"Type action Module chaosazure.machine.actions Name start_machines Return None Start virtual machines at random. Thought as a rollback action. \u2013 filter : str, optional Filter the virtual machines. If the filter is omitted all machines in the subscription will be selected as potential chaos candidates. Some calling examples. Deep dive into the filter syntax: https://docs.microsoft.com/en-us/azure/kusto/query/ start_machines(\u201cwhere resourceGroup==\u2019rg\u2019\u201c, c, s) Start all stopped machines from the group \u2018rg\u2019 start_machines(\u201cwhere resourceGroup==\u2019rg\u2019 and name=\u2019name\u2019\u201c, c, s) Start the stopped machine from the group \u2018rg\u2019 having the name \u2018name\u2019 start_machines(\u201cwhere resourceGroup==\u2019rg\u2019 | sample 2\u201d, c, s) Start two stopped machines at random from the group \u2018rg\u2019 Signature: def start_machines ( filter : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required filter string null No Usage: { \"name\" : \"start-machines\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.machine.actions\" , \"func\" : \"start_machines\" } } name : start-machines provider : func : start_machines module : chaosazure.machine.actions type : python type : action","title":"start_machines"},{"location":"drivers/azure/#stop_machines","text":"Type action Module chaosazure.machine.actions Name stop_machines Return None Stop virtual machines at random. \u2013 filter : str, optional Filter the virtual machines. If the filter is omitted all machines in the subscription will be selected as potential chaos candidates. Some calling examples. Deep dive into the filter syntax: https://docs.microsoft.com/en-us/azure/kusto/query/ stop_machines(\u201cwhere resourceGroup==\u2019rg\u2019\u201c, c, s) Stop all machines from the group \u2018rg\u2019 stop_machines(\u201cwhere resourceGroup==\u2019mygroup\u2019 and name=\u2019myname\u2019\u201c, c, s) Stop the machine from the group \u2018mygroup\u2019 having the name \u2018myname\u2019 stop_machines(\u201cwhere resourceGroup==\u2019mygroup\u2019 | sample 2\u201d, c, s) Stop two machines at random from the group \u2018mygroup\u2019 Signature: def stop_machines ( filter : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required filter string null No Usage: { \"name\" : \"stop-machines\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.machine.actions\" , \"func\" : \"stop_machines\" } } name : stop-machines provider : func : stop_machines module : chaosazure.machine.actions type : python type : action","title":"stop_machines"},{"location":"drivers/azure/#stress_cpu","text":"Type action Module chaosazure.machine.actions Name stress_cpu Return None Stress CPU up to 100% at virtual machines. \u2013 filter : str, optional Filter the virtual machines. If the filter is omitted all machines in the subscription will be selected as potential chaos candidates. duration : int, optional Duration of the stress test (in seconds) that generates high CPU usage. Defaults to 120 seconds. timeout : int Additional wait time (in seconds) for stress operation to be completed. Getting and sending data from/to Azure may take some time so it\u2019s not recommended to set this value to less than 30s. Defaults to 60 seconds. Some calling examples. Deep dive into the filter syntax: https://docs.microsoft.com/en-us/azure/kusto/query/ stress_cpu(\u201cwhere resourceGroup==\u2019rg\u2019\u201c, configuration=c, secrets=s) Stress all machines from the group \u2018rg\u2019 stress_cpu(\u201cwhere resourceGroup==\u2019rg\u2019 and name=\u2019name\u2019\u201c, configuration=c, secrets=s) Stress the machine from the group \u2018rg\u2019 having the name \u2018name\u2019 stress_cpu(\u201cwhere resourceGroup==\u2019rg\u2019 | sample 2\u201d, configuration=c, secrets=s) Stress two machines at random from the group \u2018rg\u2019 Signature: def stress_cpu ( filter : str = None , duration : int = 120 , timeout : int = 60 , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required filter string null No duration integer 120 No timeout integer 60 No Usage: { \"name\" : \"stress-cpu\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.machine.actions\" , \"func\" : \"stress_cpu\" } } name : stress-cpu provider : func : stress_cpu module : chaosazure.machine.actions type : python type : action","title":"stress_cpu"},{"location":"drivers/azure/#vmss","text":"","title":"vmss"},{"location":"drivers/azure/#burn_io_1","text":"Type action Module chaosazure.vmss.actions Name burn_io Return None Increases the Disk I/O operations per second of the VMSS machine. Similar to the burn_io action of the machine.actions module. Signature: Arguments: Name Type Default Required filter string null No duration integer 60 No timeout integer 60 No instance_criteria object null No Usage: { \"name\" : \"burn-io\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.vmss.actions\" , \"func\" : \"burn_io\" } } name : burn-io provider : func : burn_io module : chaosazure.vmss.actions type : python type : action","title":"burn_io"},{"location":"drivers/azure/#count_instances","text":"Type probe Module chaosazure.vmss.probes Name count_instances Return integer Return count of VMSS instances. \u2013 filter : str Filter the VMSS instance. If the filter is omitted all machines in the subscription will be selected for the probe. Filtering example: \u2018where resourceGroup==\u201dmyresourcegroup\u201d and name=\u201dmyresourcename\u201d\u2019 Signature: def count_instances ( filter : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required filter string null No Usage: { \"name\" : \"count-instances\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.vmss.probes\" , \"func\" : \"count_instances\" } } name : count-instances provider : func : count_instances module : chaosazure.vmss.probes type : python type : probe","title":"count_instances"},{"location":"drivers/azure/#deallocate_vmss","text":"Type action Module chaosazure.vmss.actions Name deallocate_vmss Return None Deallocate a virtual machine scale set instance at random. \u2013 filter : str Filter the virtual machine scale set. If the filter is omitted all virtual machine scale sets in the subscription will be selected as potential chaos candidates. Filtering example: \u2018where resourceGroup==\u201dmyresourcegroup\u201d and name=\u201dmyresourcename\u201d\u2019 Signature: Arguments: Name Type Default Required filter string null No instance_criteria object null No Usage: { \"name\" : \"deallocate-vmss\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.vmss.actions\" , \"func\" : \"deallocate_vmss\" } } name : deallocate-vmss provider : func : deallocate_vmss module : chaosazure.vmss.actions type : python type : action","title":"deallocate_vmss"},{"location":"drivers/azure/#delete_vmss","text":"Type action Module chaosazure.vmss.actions Name delete_vmss Return None Delete a virtual machine scale set instance at random. Be aware : Deleting a VMSS instance is an invasive action. You will not be able to recover the VMSS instance once you deleted it. \u2013 filter : str Filter the virtual machine scale set. If the filter is omitted all virtual machine scale sets in the subscription will be selected as potential chaos candidates. Filtering example: \u2018where resourceGroup==\u201dmyresourcegroup\u201d and name=\u201dmyresourcename\u201d\u2019 Signature: Arguments: Name Type Default Required filter string null No instance_criteria object null No Usage: { \"name\" : \"delete-vmss\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.vmss.actions\" , \"func\" : \"delete_vmss\" } } name : delete-vmss provider : func : delete_vmss module : chaosazure.vmss.actions type : python type : action","title":"delete_vmss"},{"location":"drivers/azure/#fill_disk_1","text":"Type action Module chaosazure.vmss.actions Name fill_disk Return None Fill the VMSS machine disk with random data. Similar to the fill_disk action of the machine.actions module. Signature: Arguments: Name Type Default Required filter string null No duration integer 120 No timeout integer 60 No size integer 1000 No path string null No instance_criteria object null No Usage: { \"name\" : \"fill-disk\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.vmss.actions\" , \"func\" : \"fill_disk\" } } name : fill-disk provider : func : fill_disk module : chaosazure.vmss.actions type : python type : action","title":"fill_disk"},{"location":"drivers/azure/#network_latency_1","text":"Type action Module chaosazure.vmss.actions Name network_latency Return None Increases the response time of the virtual machine. Similar to the network_latency action of the machine.actions module. Signature: Arguments: Name Type Default Required filter string null No duration integer 60 No delay integer 200 No jitter integer 50 No timeout integer 60 No instance_criteria object null No Usage: { \"name\" : \"network-latency\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.vmss.actions\" , \"func\" : \"network_latency\" } } name : network-latency provider : func : network_latency module : chaosazure.vmss.actions type : python type : action","title":"network_latency"},{"location":"drivers/azure/#restart_vmss","text":"Type action Module chaosazure.vmss.actions Name restart_vmss Return None Restart a virtual machine scale set instance at random. \u2013 filter : str Filter the virtual machine scale set. If the filter is omitted all virtual machine scale sets in the subscription will be selected as potential chaos candidates. Filtering example: \u2018where resourceGroup==\u201dmyresourcegroup\u201d and name=\u201dmyresourcename\u201d\u2019 Signature: Arguments: Name Type Default Required filter string null No instance_criteria object null No Usage: { \"name\" : \"restart-vmss\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.vmss.actions\" , \"func\" : \"restart_vmss\" } } name : restart-vmss provider : func : restart_vmss module : chaosazure.vmss.actions type : python type : action","title":"restart_vmss"},{"location":"drivers/azure/#stop_vmss","text":"Type action Module chaosazure.vmss.actions Name stop_vmss Return None Stops instances from the filtered scale set either at random or by a defined instance criteria. \u2013 filter : str Filter the virtual machine scale set. If the filter is omitted all virtual machine scale sets in the subscription will be selected as potential chaos candidates. Filtering example: \u2018where resourceGroup==\u201dmyresourcegroup\u201d and name=\u201dmyresourcename\u201d\u2019 instance_criteria : Iterable[Mapping[str, any]] Allows specification of criteria for selection of a given virtual machine scale set instance. If the instance_criteria is omitted, an instance will be chosen at random. All of the criteria within each item of the Iterable must match, i.e. AND logic is applied. The first item with all matching criterion will be used to select the instance. Criteria example: [ {\u201cname\u201d: \u201cmyVMSSInstance1\u201d}, { \u201cname\u201d: \u201cmyVMSSInstance2\u201d, \u201cinstanceId\u201d: \u201c2\u201d } {\u201cinstanceId\u201d: \u201c3\u201d}, ] If the instances include two items. One with name = myVMSSInstance4 and instanceId = 2. The other with name = myVMSSInstance2 and instanceId = 3. The criteria {\u201cinstanceId\u201d: \u201c3\u201d} will be the first match since both the name and the instanceId did not match on the first criteria. Signature: Arguments: Name Type Default Required filter string null No instance_criteria object null No Usage: { \"name\" : \"stop-vmss\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.vmss.actions\" , \"func\" : \"stop_vmss\" } } name : stop-vmss provider : func : stop_vmss module : chaosazure.vmss.actions type : python type : action","title":"stop_vmss"},{"location":"drivers/azure/#stress_vmss_instance_cpu","text":"Type action Module chaosazure.vmss.actions Name stress_vmss_instance_cpu Return None Signature: Arguments: Name Type Default Required filter string null No duration integer 120 No timeout integer 60 No instance_criteria object null No Usage: { \"name\" : \"stress-vmss-instance-cpu\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.vmss.actions\" , \"func\" : \"stress_vmss_instance_cpu\" } } name : stress-vmss-instance-cpu provider : func : stress_vmss_instance_cpu module : chaosazure.vmss.actions type : python type : action","title":"stress_vmss_instance_cpu"},{"location":"drivers/azure/#webapp","text":"","title":"webapp"},{"location":"drivers/azure/#delete_webapp","text":"Type action Module chaosazure.webapp.actions Name delete_webapp Return None Delete a web app at random. ***Be aware**: Deleting a web app is an invasive action. You will not be able to recover the web app once you deleted it. \u2013 filter : str Filter the web apps. If the filter is omitted all web apps in the subscription will be selected as potential chaos candidates. Filtering example: \u2018where resourceGroup==\u201dmyresourcegroup\u201d and name=\u201dmyresourcename\u201d\u2019 Signature: def delete_webapp ( filter : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required filter string null No Usage: { \"name\" : \"delete-webapp\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.webapp.actions\" , \"func\" : \"delete_webapp\" } } name : delete-webapp provider : func : delete_webapp module : chaosazure.webapp.actions type : python type : action","title":"delete_webapp"},{"location":"drivers/azure/#restart_webapp","text":"Type action Module chaosazure.webapp.actions Name restart_webapp Return None Restart a web app at random. \u2013 filter : str Filter the web apps. If the filter is omitted all web apps in the subscription will be selected as potential chaos candidates. Filtering example: \u2018where resourceGroup==\u201dmyresourcegroup\u201d and name=\u201dmyresourcename\u201d\u2019 Signature: def restart_webapp ( filter : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required filter string null No Usage: { \"name\" : \"restart-webapp\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.webapp.actions\" , \"func\" : \"restart_webapp\" } } name : restart-webapp provider : func : restart_webapp module : chaosazure.webapp.actions type : python type : action","title":"restart_webapp"},{"location":"drivers/azure/#start_webapp","text":"Type action Module chaosazure.webapp.actions Name start_webapp Return None Start a web app at random. \u2013 filter : str Filter the web apps. If the filter is omitted all web apps in the subscription will be selected as potential chaos candidates. Filtering example: \u2018where resourceGroup==\u201dmyresourcegroup\u201d and name=\u201dmyresourcename\u201d\u2019 Signature: def start_webapp ( filter : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required filter string null No Usage: { \"name\" : \"start-webapp\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.webapp.actions\" , \"func\" : \"start_webapp\" } } name : start-webapp provider : func : start_webapp module : chaosazure.webapp.actions type : python type : action","title":"start_webapp"},{"location":"drivers/azure/#stop_webapp","text":"Type action Module chaosazure.webapp.actions Name stop_webapp Return None Stop a web app at random. \u2013 filter : str Filter the web apps. If the filter is omitted all web apps in the subscription will be selected as potential chaos candidates. Filtering example: \u2018where resourceGroup==\u201dmyresourcegroup\u201d and name=\u201dmyresourcename\u201d\u2019 Signature: def stop_webapp ( filter : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required filter string null No Usage: { \"name\" : \"stop-webapp\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosazure.webapp.actions\" , \"func\" : \"stop_webapp\" } } name : stop-webapp provider : func : stop_webapp module : chaosazure.webapp.actions type : python type : action","title":"stop_webapp"},{"location":"drivers/cloudfoundry/","text":"Extension chaoscf \u00b6 Version 0.7.1 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-cloud-foundry This extension package provides probes and actions for Chaos Engineering experiments against a Cloud Foundry instance using the Chaos Toolkit . Install \u00b6 This package requires Python 3.5+ To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install -U chaostoolkit-cloud-foundry Usage \u00b6 To use the probes and actions from this package, add a similar payload to your experiment file: { \"type\" : \"action\" , \"name\" : \"terminate-random-instance\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.probes\" , \"func\" : \"terminate_some_random_instance\" , \"arguments\" : { \"name\" : \"my-app\" , \"org_name\" : \"my-org\" , \"space_name\" : \"my-space\" } } }, { \"type\" : \"probe\" , \"name\" : \"fetch-app-statistics\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.probes\" , \"func\" : \"get_app_stats\" , \"arguments\" : { \"name\" : \"my-app\" , \"org_name\" : \"my-org\" , \"space_name\" : \"my-space\" } } } That\u2019s it! Please explore the code to see existing probes and actions. Discovery \u00b6 You may use the Chaos Toolkit to discover the capabilities of this extension: $ chaos discover chaostoolkit-cloud-foundry --no-install If you have logged in against a Cloud Foundry environment, this will discover information about it along the way. Configuration \u00b6 This extension to the Chaos Toolkit need credentials to a Cloud Foundry account with appropriate scopes. Please add the following sections to your experiment file: { \"configuration\" : { \"cf_api_url\" : \"https://api.local.pcfdev.io\" , \"cf_verify_ssl\" : false }, \"secrets\" : { \"cloudfoundry\" : { \"cf_username\" : \"user\" , \"cf_password\" : \"pass\" } } } You may leave \"cf_verifiy_ssl\" out of the configuration when you want to verify TLS certificates. Usually, local environments are self-signed so it may be useful to disable that check in that case. You may also specify the \"cf_client_id\" and \"cf_client_secret\" secrets when you need. Their default values are \"cf\" and \"\" respectively. These work well against a local PCF dev install. Then in your probe or action: { \"type\" : \"probe\" , \"name\" : \"fetch-app-statistics\" , \"provider\" : { \"type\" : \"python\" , \"secrets\" : [ \"cloudfoundry\" ], \"module\" : \"chaoscf.probes\" , \"func\" : \"get_app_stats\" , \"arguments\" : { \"name\" : \"my-app\" , \"org_name\" : \"my-org\" , \"space_name\" : \"my-space\" } } } Test \u00b6 To run the tests for the project execute the following: $ pip install -r requirements-dev.txt $ pytest Contribute \u00b6 If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. The Chaos Toolkit project requires all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR. Develop \u00b6 If you wish to develop on this project, make sure to install the development dependencies. But first, create a virtual environment and then install those dependencies. $ pip install -r requirements-dev.txt -r requirements.txt Then, point your environment to this directory: $ python setup.py develop Now, you can edit the files and they will be automatically be seen by your environment, even when running from the chaos command locally. Test \u00b6 To run the tests for the project execute the following: $ python setup.py test Exported Activities \u00b6 actions \u00b6 delete_app \u00b6 Type action Module chaoscf.actions Name delete_app Return None Delete application. See https://apidocs.cloudfoundry.org/280/apps/delete_a_particular_app.html Signature: def delete_app ( app_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ): pass Arguments: Name Type Default Required app_name string Yes org_name string null No space_name string null No Usage: { \"name\" : \"delete-app\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.actions\" , \"func\" : \"delete_app\" , \"arguments\" : { \"app_name\" : \"\" } } } name : delete-app provider : arguments : app_name : '' func : delete_app module : chaoscf.actions type : python type : action map_route_to_app \u00b6 Type action Module chaoscf.actions Name map_route_to_app Return list Map a specific route to a given application. As Domains are deprecated in the Cloud Foundry API, they are not specified here. See https://apidocs.cloudfoundry.org/280/#domains--deprecated- See https://www.cloudfoundry.org/blog/coming-changes-app-manifest-simplification/ See https://apidocs.cloudfoundry.org/280/apps/remove_route_from_the_app.html Signature: def map_route_to_app ( app_name : str , host_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required app_name string Yes host_name string Yes org_name string null No space_name string null No Usage: { \"name\" : \"map-route-to-app\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.actions\" , \"func\" : \"map_route_to_app\" , \"arguments\" : { \"app_name\" : \"\" , \"host_name\" : \"\" } } } name : map-route-to-app provider : arguments : app_name : '' host_name : '' func : map_route_to_app module : chaoscf.actions type : python type : action remove_routes_from_app \u00b6 Type action Module chaoscf.actions Name remove_routes_from_app Return None Remove routes from a given application. See https://apidocs.cloudfoundry.org/280/apps/remove_route_from_the_app.html Signature: def remove_routes_from_app ( app_name : str , route_host : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ): pass Arguments: Name Type Default Required app_name string Yes route_host string Yes org_name string null No space_name string null No Usage: { \"name\" : \"remove-routes-from-app\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.actions\" , \"func\" : \"remove_routes_from_app\" , \"arguments\" : { \"app_name\" : \"\" , \"route_host\" : \"\" } } } name : remove-routes-from-app provider : arguments : app_name : '' route_host : '' func : remove_routes_from_app module : chaoscf.actions type : python type : action start_all_apps \u00b6 Type action Module chaoscf.actions Name start_all_apps Return None Start all applications for the specified org name See https://apidocs.cloudfoundry.org/280/apps/updating_an_app.html Signature: def start_all_apps ( org_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]]): pass Arguments: Name Type Default Required org_name string Yes Usage: { \"name\" : \"start-all-apps\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.actions\" , \"func\" : \"start_all_apps\" , \"arguments\" : { \"org_name\" : \"\" } } } name : start-all-apps provider : arguments : org_name : '' func : start_all_apps module : chaoscf.actions type : python type : action start_app \u00b6 Type action Module chaoscf.actions Name start_app Return None Start application See https://apidocs.cloudfoundry.org/280/apps/updating_an_app.html Signature: def start_app ( app_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ): pass Arguments: Name Type Default Required app_name string Yes org_name string null No space_name string null No Usage: { \"name\" : \"start-app\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.actions\" , \"func\" : \"start_app\" , \"arguments\" : { \"app_name\" : \"\" } } } name : start-app provider : arguments : app_name : '' func : start_app module : chaoscf.actions type : python type : action stop_all_apps \u00b6 Type action Module chaoscf.actions Name stop_all_apps Return None Stop all application for the specified org name See https://apidocs.cloudfoundry.org/280/apps/updating_an_app.html Signature: def stop_all_apps ( org_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]]): pass Arguments: Name Type Default Required org_name string Yes Usage: { \"name\" : \"stop-all-apps\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.actions\" , \"func\" : \"stop_all_apps\" , \"arguments\" : { \"org_name\" : \"\" } } } name : stop-all-apps provider : arguments : org_name : '' func : stop_all_apps module : chaoscf.actions type : python type : action stop_app \u00b6 Type action Module chaoscf.actions Name stop_app Return None Stop application See https://apidocs.cloudfoundry.org/280/apps/updating_an_app.html Signature: def stop_app ( app_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ): pass Arguments: Name Type Default Required app_name string Yes org_name string null No space_name string null No Usage: { \"name\" : \"stop-app\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.actions\" , \"func\" : \"stop_app\" , \"arguments\" : { \"app_name\" : \"\" } } } name : stop-app provider : arguments : app_name : '' func : stop_app module : chaoscf.actions type : python type : action terminate_app_instance \u00b6 Type action Module chaoscf.actions Name terminate_app_instance Return None Terminate the application\u2019s instance at the given index. See https://apidocs.cloudfoundry.org/280/apps/terminate_the_running_app_instance_at_the_given_index.html Signature: def terminate_app_instance ( app_name : str , instance_index : int , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ): pass Arguments: Name Type Default Required app_name string Yes instance_index integer Yes org_name string null No space_name string null No Usage: { \"name\" : \"terminate-app-instance\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.actions\" , \"func\" : \"terminate_app_instance\" , \"arguments\" : { \"app_name\" : \"\" , \"instance_index\" : 0 } } } name : terminate-app-instance provider : arguments : app_name : '' instance_index : 0 func : terminate_app_instance module : chaoscf.actions type : python type : action terminate_some_random_instance \u00b6 Type action Module chaoscf.actions Name terminate_some_random_instance Return None Terminate a random application\u2019s instance. See https://apidocs.cloudfoundry.org/280/apps/terminate_the_running_app_instance_at_the_given_index.html Signature: def terminate_some_random_instance ( app_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ): pass Arguments: Name Type Default Required app_name string Yes org_name string null No space_name string null No Usage: { \"name\" : \"terminate-some-random-instance\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.actions\" , \"func\" : \"terminate_some_random_instance\" , \"arguments\" : { \"app_name\" : \"\" } } } name : terminate-some-random-instance provider : arguments : app_name : '' func : terminate_some_random_instance module : chaoscf.actions type : python type : action unbind_service_from_app \u00b6 Type action Module chaoscf.actions Name unbind_service_from_app Return None Unbind the service from the given application. See https://apidocs.cloudfoundry.org/280/service_bindings/delete_a_particular_service_binding.html Signature: def unbind_service_from_app ( app_name : str , bind_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ): pass Arguments: Name Type Default Required app_name string Yes bind_name string Yes org_name string null No space_name string null No Usage: { \"name\" : \"unbind-service-from-app\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.actions\" , \"func\" : \"unbind_service_from_app\" , \"arguments\" : { \"app_name\" : \"\" , \"bind_name\" : \"\" } } } name : unbind-service-from-app provider : arguments : app_name : '' bind_name : '' func : unbind_service_from_app module : chaoscf.actions type : python type : action unmap_route_from_app \u00b6 Type action Module chaoscf.actions Name unmap_route_from_app Return None Unmap a specific route from a given application. As Domains are deprecated in the Cloud Foundry API, they are not specified here. See https://apidocs.cloudfoundry.org/280/#domains--deprecated- See https://www.cloudfoundry.org/blog/coming-changes-app-manifest-simplification/ See https://apidocs.cloudfoundry.org/280/apps/remove_route_from_the_app.html Signature: def unmap_route_from_app ( app_name : str , host_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ): pass Arguments: Name Type Default Required app_name string Yes host_name string Yes org_name string null No space_name string null No Usage: { \"name\" : \"unmap-route-from-app\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.actions\" , \"func\" : \"unmap_route_from_app\" , \"arguments\" : { \"app_name\" : \"\" , \"host_name\" : \"\" } } } name : unmap-route-from-app provider : arguments : app_name : '' host_name : '' func : unmap_route_from_app module : chaoscf.actions type : python type : action api \u00b6 call_api \u00b6 Type Module chaoscf.api Name call_api Return requests.models.Response Perform a Cloud Foundry API call and return the full response to the caller. Signature: def call_api ( path : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], query : Dict [ str , Any ] = None , body : Dict [ str , Any ] = None , method : str = 'GET' , headers : Dict [ str , str ] = None ) -> requests . models . Response : pass Arguments: Name Type Default Required path string Yes query mapping null No body mapping null No method string \u201cGET\u201d No headers mapping null No Usage: { \"name\" : \"call-api\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.api\" , \"func\" : \"call_api\" , \"arguments\" : { \"path\" : \"\" } } } name : call-api provider : arguments : path : '' func : call_api module : chaoscf.api type : python type : '' get_app_by_name \u00b6 Type Module chaoscf.api Name get_app_by_name Return mapping Get the application with the given name. You may restrict the search by organization and/or space by providing the various according parameters. When passing the names, the function performs a lookup for each of them to fetch their GUID. See https://apidocs.cloudfoundry.org/280/apps/list_all_apps.html Signature: def get_app_by_name ( app_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], space_name : str = None , space_guid : str = None , org_name : str = None , org_guid : str = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required app_name string Yes space_name string null No space_guid string null No org_name string null No org_guid string null No Usage: { \"name\" : \"get-app-by-name\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.api\" , \"func\" : \"get_app_by_name\" , \"arguments\" : { \"app_name\" : \"\" } } } name : get-app-by-name provider : arguments : app_name : '' func : get_app_by_name module : chaoscf.api type : python type : '' get_app_instances \u00b6 Type Module chaoscf.api Name get_app_instances Return mapping Get all the instances of a started application. See https://apidocs.cloudfoundry.org/280/apps/get_the_instance_information_for_a_started_app.html Signature: def get_app_instances ( app_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], space_name : str = None , space_guid : str = None , org_name : str = None , org_guid : str = None ) -> Dict [ str , Dict [ str , Any ]]: pass Arguments: Name Type Default Required app_name string Yes space_name string null No space_guid string null No org_name string null No org_guid string null No Usage: { \"name\" : \"get-app-instances\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.api\" , \"func\" : \"get_app_instances\" , \"arguments\" : { \"app_name\" : \"\" } } } name : get-app-instances provider : arguments : app_name : '' func : get_app_instances module : chaoscf.api type : python type : '' get_app_routes_by_host \u00b6 Type Module chaoscf.api Name get_app_routes_by_host Return list Get all routes associated with the provided app and the given host. See https://apidocs.cloudfoundry.org/280/routes/list_all_routes.html Signature: def get_app_routes_by_host ( app_name : str , route_host : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], space_name : str = None , space_guid : str = None , org_name : str = None , org_guid : str = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required app_name string Yes route_host string Yes space_name string null No space_guid string null No org_name string null No org_guid string null No Usage: { \"name\" : \"get-app-routes-by-host\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.api\" , \"func\" : \"get_app_routes_by_host\" , \"arguments\" : { \"app_name\" : \"\" , \"route_host\" : \"\" } } } name : get-app-routes-by-host provider : arguments : app_name : '' route_host : '' func : get_app_routes_by_host module : chaoscf.api type : python type : '' get_apps_for_org \u00b6 Type Module chaoscf.api Name get_apps_for_org Return None List all applications available in the specified CF org name. See https://apidocs.cloudfoundry.org/280/apps/list_all_apps.html to understand the content of the response. Signature: def get_apps_for_org ( org_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]]): pass Arguments: Name Type Default Required org_name string Yes Usage: { \"name\" : \"get-apps-for-org\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.api\" , \"func\" : \"get_apps_for_org\" , \"arguments\" : { \"org_name\" : \"\" } } } name : get-apps-for-org provider : arguments : org_name : '' func : get_apps_for_org module : chaoscf.api type : python type : '' get_bind_by_name \u00b6 Type Module chaoscf.api Name get_bind_by_name Return mapping Get the service bind with the given name. You may restrict the search by organization and/or space by providing the various according parameters. When passing the names, the function performs a lookup for each of them to fetch their GUID. See https://apidocs.cloudfoundry.org/280/apps/list_all_apps.html Signature: def get_bind_by_name ( bind_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], app_name : str = None , space_name : str = None , space_guid : str = None , org_name : str = None , org_guid : str = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required bind_name string Yes app_name string null No space_name string null No space_guid string null No org_name string null No org_guid string null No Usage: { \"name\" : \"get-bind-by-name\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.api\" , \"func\" : \"get_bind_by_name\" , \"arguments\" : { \"bind_name\" : \"\" } } } name : get-bind-by-name provider : arguments : bind_name : '' func : get_bind_by_name module : chaoscf.api type : python type : '' get_org_by_name \u00b6 Type Module chaoscf.api Name get_org_by_name Return mapping Get the organization with the given name. Signature: def get_org_by_name ( org_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]]) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required org_name string Yes Usage: { \"name\" : \"get-org-by-name\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.api\" , \"func\" : \"get_org_by_name\" , \"arguments\" : { \"org_name\" : \"\" } } } name : get-org-by-name provider : arguments : org_name : '' func : get_org_by_name module : chaoscf.api type : python type : '' get_routes_by_host \u00b6 Type Module chaoscf.api Name get_routes_by_host Return mapping Get all routes with given host. See https://apidocs.cloudfoundry.org/280/routes/list_all_routes.html Signature: def get_routes_by_host ( route_host : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , org_guid : str = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required route_host string Yes org_name string null No org_guid string null No Usage: { \"name\" : \"get-routes-by-host\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.api\" , \"func\" : \"get_routes_by_host\" , \"arguments\" : { \"route_host\" : \"\" } } } name : get-routes-by-host provider : arguments : route_host : '' func : get_routes_by_host module : chaoscf.api type : python type : '' get_space_by_name \u00b6 Type Module chaoscf.api Name get_space_by_name Return mapping Get the space with the given name. You may restrict the search by organization by providing the various according parameters. When passing the name, the function performs a lookup for the org to fetch its GUID. Signature: def get_space_by_name ( space_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , org_guid = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required space_name string Yes org_name string null No org_guid null No Usage: { \"name\" : \"get-space-by-name\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.api\" , \"func\" : \"get_space_by_name\" , \"arguments\" : { \"space_name\" : \"\" } } } name : get-space-by-name provider : arguments : space_name : '' func : get_space_by_name module : chaoscf.api type : python type : '' probes \u00b6 get_app_stats \u00b6 Type probe Module chaoscf.probes Name get_app_stats Return mapping Fetch the metrics of the given application. See https://apidocs.cloudfoundry.org/280/apps/get_detailed_stats_for_a_started_app.html for more information. Signature: def get_app_stats ( app_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required app_name string Yes org_name string null No space_name string null No Usage: { \"name\" : \"get-app-stats\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.probes\" , \"func\" : \"get_app_stats\" , \"arguments\" : { \"app_name\" : \"\" } } } name : get-app-stats provider : arguments : app_name : '' func : get_app_stats module : chaoscf.probes type : python type : probe list_apps \u00b6 Type probe Module chaoscf.probes Name list_apps Return mapping List all applications available to the authorized user. See https://apidocs.cloudfoundry.org/280/apps/list_all_apps.html to understand the content of the response. Signature: def list_apps ( configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]]) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required Usage: { \"name\" : \"list-apps\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.probes\" , \"func\" : \"list_apps\" } } name : list-apps provider : func : list_apps module : chaoscf.probes type : python type : probe","title":"Cloud Foundry"},{"location":"drivers/cloudfoundry/#extension-chaoscf","text":"Version 0.7.1 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-cloud-foundry This extension package provides probes and actions for Chaos Engineering experiments against a Cloud Foundry instance using the Chaos Toolkit .","title":"Extension chaoscf"},{"location":"drivers/cloudfoundry/#install","text":"This package requires Python 3.5+ To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install -U chaostoolkit-cloud-foundry","title":"Install"},{"location":"drivers/cloudfoundry/#usage","text":"To use the probes and actions from this package, add a similar payload to your experiment file: { \"type\" : \"action\" , \"name\" : \"terminate-random-instance\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.probes\" , \"func\" : \"terminate_some_random_instance\" , \"arguments\" : { \"name\" : \"my-app\" , \"org_name\" : \"my-org\" , \"space_name\" : \"my-space\" } } }, { \"type\" : \"probe\" , \"name\" : \"fetch-app-statistics\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.probes\" , \"func\" : \"get_app_stats\" , \"arguments\" : { \"name\" : \"my-app\" , \"org_name\" : \"my-org\" , \"space_name\" : \"my-space\" } } } That\u2019s it! Please explore the code to see existing probes and actions.","title":"Usage"},{"location":"drivers/cloudfoundry/#discovery","text":"You may use the Chaos Toolkit to discover the capabilities of this extension: $ chaos discover chaostoolkit-cloud-foundry --no-install If you have logged in against a Cloud Foundry environment, this will discover information about it along the way.","title":"Discovery"},{"location":"drivers/cloudfoundry/#configuration","text":"This extension to the Chaos Toolkit need credentials to a Cloud Foundry account with appropriate scopes. Please add the following sections to your experiment file: { \"configuration\" : { \"cf_api_url\" : \"https://api.local.pcfdev.io\" , \"cf_verify_ssl\" : false }, \"secrets\" : { \"cloudfoundry\" : { \"cf_username\" : \"user\" , \"cf_password\" : \"pass\" } } } You may leave \"cf_verifiy_ssl\" out of the configuration when you want to verify TLS certificates. Usually, local environments are self-signed so it may be useful to disable that check in that case. You may also specify the \"cf_client_id\" and \"cf_client_secret\" secrets when you need. Their default values are \"cf\" and \"\" respectively. These work well against a local PCF dev install. Then in your probe or action: { \"type\" : \"probe\" , \"name\" : \"fetch-app-statistics\" , \"provider\" : { \"type\" : \"python\" , \"secrets\" : [ \"cloudfoundry\" ], \"module\" : \"chaoscf.probes\" , \"func\" : \"get_app_stats\" , \"arguments\" : { \"name\" : \"my-app\" , \"org_name\" : \"my-org\" , \"space_name\" : \"my-space\" } } }","title":"Configuration"},{"location":"drivers/cloudfoundry/#test","text":"To run the tests for the project execute the following: $ pip install -r requirements-dev.txt $ pytest","title":"Test"},{"location":"drivers/cloudfoundry/#contribute","text":"If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. The Chaos Toolkit project requires all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR.","title":"Contribute"},{"location":"drivers/cloudfoundry/#develop","text":"If you wish to develop on this project, make sure to install the development dependencies. But first, create a virtual environment and then install those dependencies. $ pip install -r requirements-dev.txt -r requirements.txt Then, point your environment to this directory: $ python setup.py develop Now, you can edit the files and they will be automatically be seen by your environment, even when running from the chaos command locally.","title":"Develop"},{"location":"drivers/cloudfoundry/#test_1","text":"To run the tests for the project execute the following: $ python setup.py test","title":"Test"},{"location":"drivers/cloudfoundry/#exported-activities","text":"","title":"Exported Activities"},{"location":"drivers/cloudfoundry/#actions","text":"","title":"actions"},{"location":"drivers/cloudfoundry/#delete_app","text":"Type action Module chaoscf.actions Name delete_app Return None Delete application. See https://apidocs.cloudfoundry.org/280/apps/delete_a_particular_app.html Signature: def delete_app ( app_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ): pass Arguments: Name Type Default Required app_name string Yes org_name string null No space_name string null No Usage: { \"name\" : \"delete-app\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.actions\" , \"func\" : \"delete_app\" , \"arguments\" : { \"app_name\" : \"\" } } } name : delete-app provider : arguments : app_name : '' func : delete_app module : chaoscf.actions type : python type : action","title":"delete_app"},{"location":"drivers/cloudfoundry/#map_route_to_app","text":"Type action Module chaoscf.actions Name map_route_to_app Return list Map a specific route to a given application. As Domains are deprecated in the Cloud Foundry API, they are not specified here. See https://apidocs.cloudfoundry.org/280/#domains--deprecated- See https://www.cloudfoundry.org/blog/coming-changes-app-manifest-simplification/ See https://apidocs.cloudfoundry.org/280/apps/remove_route_from_the_app.html Signature: def map_route_to_app ( app_name : str , host_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required app_name string Yes host_name string Yes org_name string null No space_name string null No Usage: { \"name\" : \"map-route-to-app\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.actions\" , \"func\" : \"map_route_to_app\" , \"arguments\" : { \"app_name\" : \"\" , \"host_name\" : \"\" } } } name : map-route-to-app provider : arguments : app_name : '' host_name : '' func : map_route_to_app module : chaoscf.actions type : python type : action","title":"map_route_to_app"},{"location":"drivers/cloudfoundry/#remove_routes_from_app","text":"Type action Module chaoscf.actions Name remove_routes_from_app Return None Remove routes from a given application. See https://apidocs.cloudfoundry.org/280/apps/remove_route_from_the_app.html Signature: def remove_routes_from_app ( app_name : str , route_host : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ): pass Arguments: Name Type Default Required app_name string Yes route_host string Yes org_name string null No space_name string null No Usage: { \"name\" : \"remove-routes-from-app\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.actions\" , \"func\" : \"remove_routes_from_app\" , \"arguments\" : { \"app_name\" : \"\" , \"route_host\" : \"\" } } } name : remove-routes-from-app provider : arguments : app_name : '' route_host : '' func : remove_routes_from_app module : chaoscf.actions type : python type : action","title":"remove_routes_from_app"},{"location":"drivers/cloudfoundry/#start_all_apps","text":"Type action Module chaoscf.actions Name start_all_apps Return None Start all applications for the specified org name See https://apidocs.cloudfoundry.org/280/apps/updating_an_app.html Signature: def start_all_apps ( org_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]]): pass Arguments: Name Type Default Required org_name string Yes Usage: { \"name\" : \"start-all-apps\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.actions\" , \"func\" : \"start_all_apps\" , \"arguments\" : { \"org_name\" : \"\" } } } name : start-all-apps provider : arguments : org_name : '' func : start_all_apps module : chaoscf.actions type : python type : action","title":"start_all_apps"},{"location":"drivers/cloudfoundry/#start_app","text":"Type action Module chaoscf.actions Name start_app Return None Start application See https://apidocs.cloudfoundry.org/280/apps/updating_an_app.html Signature: def start_app ( app_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ): pass Arguments: Name Type Default Required app_name string Yes org_name string null No space_name string null No Usage: { \"name\" : \"start-app\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.actions\" , \"func\" : \"start_app\" , \"arguments\" : { \"app_name\" : \"\" } } } name : start-app provider : arguments : app_name : '' func : start_app module : chaoscf.actions type : python type : action","title":"start_app"},{"location":"drivers/cloudfoundry/#stop_all_apps","text":"Type action Module chaoscf.actions Name stop_all_apps Return None Stop all application for the specified org name See https://apidocs.cloudfoundry.org/280/apps/updating_an_app.html Signature: def stop_all_apps ( org_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]]): pass Arguments: Name Type Default Required org_name string Yes Usage: { \"name\" : \"stop-all-apps\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.actions\" , \"func\" : \"stop_all_apps\" , \"arguments\" : { \"org_name\" : \"\" } } } name : stop-all-apps provider : arguments : org_name : '' func : stop_all_apps module : chaoscf.actions type : python type : action","title":"stop_all_apps"},{"location":"drivers/cloudfoundry/#stop_app","text":"Type action Module chaoscf.actions Name stop_app Return None Stop application See https://apidocs.cloudfoundry.org/280/apps/updating_an_app.html Signature: def stop_app ( app_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ): pass Arguments: Name Type Default Required app_name string Yes org_name string null No space_name string null No Usage: { \"name\" : \"stop-app\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.actions\" , \"func\" : \"stop_app\" , \"arguments\" : { \"app_name\" : \"\" } } } name : stop-app provider : arguments : app_name : '' func : stop_app module : chaoscf.actions type : python type : action","title":"stop_app"},{"location":"drivers/cloudfoundry/#terminate_app_instance","text":"Type action Module chaoscf.actions Name terminate_app_instance Return None Terminate the application\u2019s instance at the given index. See https://apidocs.cloudfoundry.org/280/apps/terminate_the_running_app_instance_at_the_given_index.html Signature: def terminate_app_instance ( app_name : str , instance_index : int , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ): pass Arguments: Name Type Default Required app_name string Yes instance_index integer Yes org_name string null No space_name string null No Usage: { \"name\" : \"terminate-app-instance\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.actions\" , \"func\" : \"terminate_app_instance\" , \"arguments\" : { \"app_name\" : \"\" , \"instance_index\" : 0 } } } name : terminate-app-instance provider : arguments : app_name : '' instance_index : 0 func : terminate_app_instance module : chaoscf.actions type : python type : action","title":"terminate_app_instance"},{"location":"drivers/cloudfoundry/#terminate_some_random_instance","text":"Type action Module chaoscf.actions Name terminate_some_random_instance Return None Terminate a random application\u2019s instance. See https://apidocs.cloudfoundry.org/280/apps/terminate_the_running_app_instance_at_the_given_index.html Signature: def terminate_some_random_instance ( app_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ): pass Arguments: Name Type Default Required app_name string Yes org_name string null No space_name string null No Usage: { \"name\" : \"terminate-some-random-instance\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.actions\" , \"func\" : \"terminate_some_random_instance\" , \"arguments\" : { \"app_name\" : \"\" } } } name : terminate-some-random-instance provider : arguments : app_name : '' func : terminate_some_random_instance module : chaoscf.actions type : python type : action","title":"terminate_some_random_instance"},{"location":"drivers/cloudfoundry/#unbind_service_from_app","text":"Type action Module chaoscf.actions Name unbind_service_from_app Return None Unbind the service from the given application. See https://apidocs.cloudfoundry.org/280/service_bindings/delete_a_particular_service_binding.html Signature: def unbind_service_from_app ( app_name : str , bind_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ): pass Arguments: Name Type Default Required app_name string Yes bind_name string Yes org_name string null No space_name string null No Usage: { \"name\" : \"unbind-service-from-app\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.actions\" , \"func\" : \"unbind_service_from_app\" , \"arguments\" : { \"app_name\" : \"\" , \"bind_name\" : \"\" } } } name : unbind-service-from-app provider : arguments : app_name : '' bind_name : '' func : unbind_service_from_app module : chaoscf.actions type : python type : action","title":"unbind_service_from_app"},{"location":"drivers/cloudfoundry/#unmap_route_from_app","text":"Type action Module chaoscf.actions Name unmap_route_from_app Return None Unmap a specific route from a given application. As Domains are deprecated in the Cloud Foundry API, they are not specified here. See https://apidocs.cloudfoundry.org/280/#domains--deprecated- See https://www.cloudfoundry.org/blog/coming-changes-app-manifest-simplification/ See https://apidocs.cloudfoundry.org/280/apps/remove_route_from_the_app.html Signature: def unmap_route_from_app ( app_name : str , host_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ): pass Arguments: Name Type Default Required app_name string Yes host_name string Yes org_name string null No space_name string null No Usage: { \"name\" : \"unmap-route-from-app\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.actions\" , \"func\" : \"unmap_route_from_app\" , \"arguments\" : { \"app_name\" : \"\" , \"host_name\" : \"\" } } } name : unmap-route-from-app provider : arguments : app_name : '' host_name : '' func : unmap_route_from_app module : chaoscf.actions type : python type : action","title":"unmap_route_from_app"},{"location":"drivers/cloudfoundry/#api","text":"","title":"api"},{"location":"drivers/cloudfoundry/#call_api","text":"Type Module chaoscf.api Name call_api Return requests.models.Response Perform a Cloud Foundry API call and return the full response to the caller. Signature: def call_api ( path : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], query : Dict [ str , Any ] = None , body : Dict [ str , Any ] = None , method : str = 'GET' , headers : Dict [ str , str ] = None ) -> requests . models . Response : pass Arguments: Name Type Default Required path string Yes query mapping null No body mapping null No method string \u201cGET\u201d No headers mapping null No Usage: { \"name\" : \"call-api\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.api\" , \"func\" : \"call_api\" , \"arguments\" : { \"path\" : \"\" } } } name : call-api provider : arguments : path : '' func : call_api module : chaoscf.api type : python type : ''","title":"call_api"},{"location":"drivers/cloudfoundry/#get_app_by_name","text":"Type Module chaoscf.api Name get_app_by_name Return mapping Get the application with the given name. You may restrict the search by organization and/or space by providing the various according parameters. When passing the names, the function performs a lookup for each of them to fetch their GUID. See https://apidocs.cloudfoundry.org/280/apps/list_all_apps.html Signature: def get_app_by_name ( app_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], space_name : str = None , space_guid : str = None , org_name : str = None , org_guid : str = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required app_name string Yes space_name string null No space_guid string null No org_name string null No org_guid string null No Usage: { \"name\" : \"get-app-by-name\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.api\" , \"func\" : \"get_app_by_name\" , \"arguments\" : { \"app_name\" : \"\" } } } name : get-app-by-name provider : arguments : app_name : '' func : get_app_by_name module : chaoscf.api type : python type : ''","title":"get_app_by_name"},{"location":"drivers/cloudfoundry/#get_app_instances","text":"Type Module chaoscf.api Name get_app_instances Return mapping Get all the instances of a started application. See https://apidocs.cloudfoundry.org/280/apps/get_the_instance_information_for_a_started_app.html Signature: def get_app_instances ( app_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], space_name : str = None , space_guid : str = None , org_name : str = None , org_guid : str = None ) -> Dict [ str , Dict [ str , Any ]]: pass Arguments: Name Type Default Required app_name string Yes space_name string null No space_guid string null No org_name string null No org_guid string null No Usage: { \"name\" : \"get-app-instances\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.api\" , \"func\" : \"get_app_instances\" , \"arguments\" : { \"app_name\" : \"\" } } } name : get-app-instances provider : arguments : app_name : '' func : get_app_instances module : chaoscf.api type : python type : ''","title":"get_app_instances"},{"location":"drivers/cloudfoundry/#get_app_routes_by_host","text":"Type Module chaoscf.api Name get_app_routes_by_host Return list Get all routes associated with the provided app and the given host. See https://apidocs.cloudfoundry.org/280/routes/list_all_routes.html Signature: def get_app_routes_by_host ( app_name : str , route_host : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], space_name : str = None , space_guid : str = None , org_name : str = None , org_guid : str = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required app_name string Yes route_host string Yes space_name string null No space_guid string null No org_name string null No org_guid string null No Usage: { \"name\" : \"get-app-routes-by-host\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.api\" , \"func\" : \"get_app_routes_by_host\" , \"arguments\" : { \"app_name\" : \"\" , \"route_host\" : \"\" } } } name : get-app-routes-by-host provider : arguments : app_name : '' route_host : '' func : get_app_routes_by_host module : chaoscf.api type : python type : ''","title":"get_app_routes_by_host"},{"location":"drivers/cloudfoundry/#get_apps_for_org","text":"Type Module chaoscf.api Name get_apps_for_org Return None List all applications available in the specified CF org name. See https://apidocs.cloudfoundry.org/280/apps/list_all_apps.html to understand the content of the response. Signature: def get_apps_for_org ( org_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]]): pass Arguments: Name Type Default Required org_name string Yes Usage: { \"name\" : \"get-apps-for-org\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.api\" , \"func\" : \"get_apps_for_org\" , \"arguments\" : { \"org_name\" : \"\" } } } name : get-apps-for-org provider : arguments : org_name : '' func : get_apps_for_org module : chaoscf.api type : python type : ''","title":"get_apps_for_org"},{"location":"drivers/cloudfoundry/#get_bind_by_name","text":"Type Module chaoscf.api Name get_bind_by_name Return mapping Get the service bind with the given name. You may restrict the search by organization and/or space by providing the various according parameters. When passing the names, the function performs a lookup for each of them to fetch their GUID. See https://apidocs.cloudfoundry.org/280/apps/list_all_apps.html Signature: def get_bind_by_name ( bind_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], app_name : str = None , space_name : str = None , space_guid : str = None , org_name : str = None , org_guid : str = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required bind_name string Yes app_name string null No space_name string null No space_guid string null No org_name string null No org_guid string null No Usage: { \"name\" : \"get-bind-by-name\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.api\" , \"func\" : \"get_bind_by_name\" , \"arguments\" : { \"bind_name\" : \"\" } } } name : get-bind-by-name provider : arguments : bind_name : '' func : get_bind_by_name module : chaoscf.api type : python type : ''","title":"get_bind_by_name"},{"location":"drivers/cloudfoundry/#get_org_by_name","text":"Type Module chaoscf.api Name get_org_by_name Return mapping Get the organization with the given name. Signature: def get_org_by_name ( org_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]]) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required org_name string Yes Usage: { \"name\" : \"get-org-by-name\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.api\" , \"func\" : \"get_org_by_name\" , \"arguments\" : { \"org_name\" : \"\" } } } name : get-org-by-name provider : arguments : org_name : '' func : get_org_by_name module : chaoscf.api type : python type : ''","title":"get_org_by_name"},{"location":"drivers/cloudfoundry/#get_routes_by_host","text":"Type Module chaoscf.api Name get_routes_by_host Return mapping Get all routes with given host. See https://apidocs.cloudfoundry.org/280/routes/list_all_routes.html Signature: def get_routes_by_host ( route_host : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , org_guid : str = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required route_host string Yes org_name string null No org_guid string null No Usage: { \"name\" : \"get-routes-by-host\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.api\" , \"func\" : \"get_routes_by_host\" , \"arguments\" : { \"route_host\" : \"\" } } } name : get-routes-by-host provider : arguments : route_host : '' func : get_routes_by_host module : chaoscf.api type : python type : ''","title":"get_routes_by_host"},{"location":"drivers/cloudfoundry/#get_space_by_name","text":"Type Module chaoscf.api Name get_space_by_name Return mapping Get the space with the given name. You may restrict the search by organization by providing the various according parameters. When passing the name, the function performs a lookup for the org to fetch its GUID. Signature: def get_space_by_name ( space_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , org_guid = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required space_name string Yes org_name string null No org_guid null No Usage: { \"name\" : \"get-space-by-name\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.api\" , \"func\" : \"get_space_by_name\" , \"arguments\" : { \"space_name\" : \"\" } } } name : get-space-by-name provider : arguments : space_name : '' func : get_space_by_name module : chaoscf.api type : python type : ''","title":"get_space_by_name"},{"location":"drivers/cloudfoundry/#probes","text":"","title":"probes"},{"location":"drivers/cloudfoundry/#get_app_stats","text":"Type probe Module chaoscf.probes Name get_app_stats Return mapping Fetch the metrics of the given application. See https://apidocs.cloudfoundry.org/280/apps/get_detailed_stats_for_a_started_app.html for more information. Signature: def get_app_stats ( app_name : str , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]], org_name : str = None , space_name : str = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required app_name string Yes org_name string null No space_name string null No Usage: { \"name\" : \"get-app-stats\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.probes\" , \"func\" : \"get_app_stats\" , \"arguments\" : { \"app_name\" : \"\" } } } name : get-app-stats provider : arguments : app_name : '' func : get_app_stats module : chaoscf.probes type : python type : probe","title":"get_app_stats"},{"location":"drivers/cloudfoundry/#list_apps","text":"Type probe Module chaoscf.probes Name list_apps Return mapping List all applications available to the authorized user. See https://apidocs.cloudfoundry.org/280/apps/list_all_apps.html to understand the content of the response. Signature: def list_apps ( configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]]) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required Usage: { \"name\" : \"list-apps\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoscf.probes\" , \"func\" : \"list_apps\" } } name : list-apps provider : func : list_apps module : chaoscf.probes type : python type : probe","title":"list_apps"},{"location":"drivers/dynatrace/","text":"Extension chaosdynatrace \u00b6 Version 0.1.0 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-dynatrace Dynatrace support for the Chaos Toolkit . Install \u00b6 To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install chaostoolkit-dynatrace Usage \u00b6 To use this package, you must create have access to a Dynatrace instance via DynatraceApi and be allowed to connect to it. the access credentials to the api must be specified in the configuration section { \"configuration\" : { \"dynatrace\" : { \"dynatrace_base_url\" : \"$dynatrace_base_url\" , \"dynatrace_token\" : \"$dynatrace_token\" } } } This package only exports probes to get some aspects of your system monitored by Dynatrace. Here is an example of how to get the failure rate of a service in Dynatrace. for this example, the api for validate de failure rate is Metric-v1 { \"type\" : \"probe\" , \"name\" : \"get-failure-rate-services\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosdynatrace.probes\" , \"func\" : \"failure_rate\" , \"arguments\" : { \"entity\" : \"SERVICE-665B05BC92550119\" , \"relative_time\" : \"30mins\" , \"failed_percentage\" : 1 } } } The probe returns true if the api request failure percentage is less than \u201cfailed_percentage\u201d or raises an exception when an error is met. The result is not further process and should be found in the generated report of the experiment run. Contribute \u00b6 If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. Develop \u00b6 If you wish to develop on this project, make sure to install the development dependencies. But first, create a virtual environment and then install those dependencies. $ pip install -r requirements-dev.txt -r requirements.txt Then, point your environment to this directory: $ python setup.py develop Now, you can edit the files and they will be automatically be seen by your environment, even when running from the chaos command locally. Test \u00b6 To run the tests for the project execute the following: $ pytest Add new Dynatrace API Support \u00b6 Once you have setup your environment, you can start adding new Dynatrace API support by adding new actions, probes and entire sub-packages for those. Exported Activities \u00b6 probes \u00b6 failure_rate \u00b6 Type probe Module chaosdynatrace.probes Name failure_rate Return boolean Validates the failure rate of a specific service. Returns true if the failure rate is less than the expected failure rate For more information check the api documentation. https://www.dynatrace.com/support/help/dynatrace-api/environment-api/metric-v1/ Signature: def failure_rate ( entity : str , relative_time : str , failed_percentage : int , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required entity string Yes relative_time string Yes failed_percentage integer Yes Usage: { \"name\" : \"failure-rate\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosdynatrace.probes\" , \"func\" : \"failure_rate\" , \"arguments\" : { \"entity\" : \"\" , \"relative_time\" : \"\" , \"failed_percentage\" : 0 } } } name : failure-rate provider : arguments : entity : '' failed_percentage : 0 relative_time : '' func : failure_rate module : chaosdynatrace.probes type : python type : probe","title":"Dynatrace"},{"location":"drivers/dynatrace/#extension-chaosdynatrace","text":"Version 0.1.0 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-dynatrace Dynatrace support for the Chaos Toolkit .","title":"Extension chaosdynatrace"},{"location":"drivers/dynatrace/#install","text":"To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install chaostoolkit-dynatrace","title":"Install"},{"location":"drivers/dynatrace/#usage","text":"To use this package, you must create have access to a Dynatrace instance via DynatraceApi and be allowed to connect to it. the access credentials to the api must be specified in the configuration section { \"configuration\" : { \"dynatrace\" : { \"dynatrace_base_url\" : \"$dynatrace_base_url\" , \"dynatrace_token\" : \"$dynatrace_token\" } } } This package only exports probes to get some aspects of your system monitored by Dynatrace. Here is an example of how to get the failure rate of a service in Dynatrace. for this example, the api for validate de failure rate is Metric-v1 { \"type\" : \"probe\" , \"name\" : \"get-failure-rate-services\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosdynatrace.probes\" , \"func\" : \"failure_rate\" , \"arguments\" : { \"entity\" : \"SERVICE-665B05BC92550119\" , \"relative_time\" : \"30mins\" , \"failed_percentage\" : 1 } } } The probe returns true if the api request failure percentage is less than \u201cfailed_percentage\u201d or raises an exception when an error is met. The result is not further process and should be found in the generated report of the experiment run.","title":"Usage"},{"location":"drivers/dynatrace/#contribute","text":"If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review.","title":"Contribute"},{"location":"drivers/dynatrace/#develop","text":"If you wish to develop on this project, make sure to install the development dependencies. But first, create a virtual environment and then install those dependencies. $ pip install -r requirements-dev.txt -r requirements.txt Then, point your environment to this directory: $ python setup.py develop Now, you can edit the files and they will be automatically be seen by your environment, even when running from the chaos command locally.","title":"Develop"},{"location":"drivers/dynatrace/#test","text":"To run the tests for the project execute the following: $ pytest","title":"Test"},{"location":"drivers/dynatrace/#add-new-dynatrace-api-support","text":"Once you have setup your environment, you can start adding new Dynatrace API support by adding new actions, probes and entire sub-packages for those.","title":"Add new Dynatrace API Support"},{"location":"drivers/dynatrace/#exported-activities","text":"","title":"Exported Activities"},{"location":"drivers/dynatrace/#probes","text":"","title":"probes"},{"location":"drivers/dynatrace/#failure_rate","text":"Type probe Module chaosdynatrace.probes Name failure_rate Return boolean Validates the failure rate of a specific service. Returns true if the failure rate is less than the expected failure rate For more information check the api documentation. https://www.dynatrace.com/support/help/dynatrace-api/environment-api/metric-v1/ Signature: def failure_rate ( entity : str , relative_time : str , failed_percentage : int , configuration : Dict [ str , Dict [ str , str ]], secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required entity string Yes relative_time string Yes failed_percentage integer Yes Usage: { \"name\" : \"failure-rate\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosdynatrace.probes\" , \"func\" : \"failure_rate\" , \"arguments\" : { \"entity\" : \"\" , \"relative_time\" : \"\" , \"failed_percentage\" : 0 } } } name : failure-rate provider : arguments : entity : '' failed_percentage : 0 relative_time : '' func : failure_rate module : chaosdynatrace.probes type : python type : probe","title":"failure_rate"},{"location":"drivers/gandi/","text":"Extension chaosgandi \u00b6 Version 0.1.2 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-gandi This project is a collection of actions and probes , gathered as an extension to the Chaos Toolkit . Install \u00b6 This package requires Python 3.5+ To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install -U chaostoolkit-gandi Usage \u00b6 To use the probes and actions from this package, add the following to your experiment file: { \"version\" : \"1.0.0\" , \"title\" : \"Our domains are not going expiring within a month\" , \"description\" : \"We need time to renew.\" , \"secrets\" : { \"gandi\" : { \"apikey\" : { \"type\" : \"env\" , \"key\" : \"GANDI_API_KEY\" } } }, \"steady-state-hypothesis\" : { \"title\" : \"Check domains are all more than 1 month away from expiring\" , \"probes\" : [ { \"type\" : \"probe\" , \"name\" : \"list-my-domains\" , \"tolerance\" : { \"type\" : \"probe\" , \"name\" : \"validate-domain-expire-date\" , \"provider\" : { \"type\" : \"python\" , \"secrets\" : [ \"gandi\" ], \"module\" : \"chaosgandi.domains.tolerances\" , \"func\" : \"domains_should_not_expire_in\" , \"arguments\" : { \"when\" : \"1 month\" } } }, \"provider\" : { \"type\" : \"python\" , \"secrets\" : [ \"gandi\" ], \"module\" : \"chaosgandi.domains.probes\" , \"func\" : \"list_domains\" } } ] }, \"method\" : [] } That\u2019s it! Set the GANDI_API_KEY environment variable to your Gandi API Key. Please explore the code to see existing probes and actions. Contribute \u00b6 If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. The Chaos Toolkit projects require all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR. Develop \u00b6 If you wish to develop on this project, make sure to install the development dependencies. But first, create a virtual environment and then install those dependencies. $ pip install -r requirements-dev.txt -r requirements.txt Then, point your environment to this directory: $ pip install -e . Now, you can edit the files and they will be automatically be seen by your environment, even when running from the chaos command locally. Test \u00b6 To run the tests for the project execute the following: $ pytest Exported Activities \u00b6 domains \u00b6 domains_should_not_expire_in \u00b6 Type tolerance Module chaosgandi.domains.tolerances Name domains_should_not_expire_in Return boolean Go through the list of Gandi domains and fails if any expires before the given date threshold as a relative time to now. Signature: def domains_should_not_expire_in ( value : List [ Dict [ str , Any ]] = None , when : str = '1 month' ) -> bool : pass Arguments: Name Type Default Required value list null No when string \u201c1 month\u201d No Tolerances declare the value argument which is automatically injected by Chaos Toolkit as the output of the probe they are evaluating. Usage: { \"steady-state-hypothesis\" : { \"title\" : \"...\" , \"probes\" : [ { \"type\" : \"probe\" , \"tolerance\" : { \"name\" : \"domains-should-not-expire-in\" , \"type\" : \"tolerance\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgandi.domains.tolerances\" , \"func\" : \"domains_should_not_expire_in\" } }, \"...\" : \"...\" } ] } } steady-state-hypothesis : probes : - '...' : '...' tolerance : name : domains-should-not-expire-in provider : func : domains_should_not_expire_in module : chaosgandi.domains.tolerances type : python type : tolerance type : probe title : '...' list_domains \u00b6 Type probe Module chaosgandi.domains.probes Name list_domains Return list List all domains or those matching the given TLD or FQDN filters and return the list as-is. See https://api.gandi.net/docs/domains/#v5-domain-domains Signature: def list_domains ( fqdn_filter : str = None , tld_filter : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required fqdn_filter string null No tld_filter string null No Usage: { \"name\" : \"list-domains\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgandi.domains.probes\" , \"func\" : \"list_domains\" } } name : list-domains provider : func : list_domains module : chaosgandi.domains.probes type : python type : probe list_nameservers \u00b6 Type probe Module chaosgandi.domains.probes Name list_nameservers Return list List nameservers set for this domain and return them as a list of strings. See https://api.gandi.net/docs/domains/#v5-domain-domains-domain-nameservers Signature: def list_nameservers ( domain : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ str ]: pass Arguments: Name Type Default Required domain string Yes Usage: { \"name\" : \"list-nameservers\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgandi.domains.probes\" , \"func\" : \"list_nameservers\" , \"arguments\" : { \"domain\" : \"\" } } } name : list-nameservers provider : arguments : domain : '' func : list_nameservers module : chaosgandi.domains.probes type : python type : probe","title":"Gandi"},{"location":"drivers/gandi/#extension-chaosgandi","text":"Version 0.1.2 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-gandi This project is a collection of actions and probes , gathered as an extension to the Chaos Toolkit .","title":"Extension chaosgandi"},{"location":"drivers/gandi/#install","text":"This package requires Python 3.5+ To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install -U chaostoolkit-gandi","title":"Install"},{"location":"drivers/gandi/#usage","text":"To use the probes and actions from this package, add the following to your experiment file: { \"version\" : \"1.0.0\" , \"title\" : \"Our domains are not going expiring within a month\" , \"description\" : \"We need time to renew.\" , \"secrets\" : { \"gandi\" : { \"apikey\" : { \"type\" : \"env\" , \"key\" : \"GANDI_API_KEY\" } } }, \"steady-state-hypothesis\" : { \"title\" : \"Check domains are all more than 1 month away from expiring\" , \"probes\" : [ { \"type\" : \"probe\" , \"name\" : \"list-my-domains\" , \"tolerance\" : { \"type\" : \"probe\" , \"name\" : \"validate-domain-expire-date\" , \"provider\" : { \"type\" : \"python\" , \"secrets\" : [ \"gandi\" ], \"module\" : \"chaosgandi.domains.tolerances\" , \"func\" : \"domains_should_not_expire_in\" , \"arguments\" : { \"when\" : \"1 month\" } } }, \"provider\" : { \"type\" : \"python\" , \"secrets\" : [ \"gandi\" ], \"module\" : \"chaosgandi.domains.probes\" , \"func\" : \"list_domains\" } } ] }, \"method\" : [] } That\u2019s it! Set the GANDI_API_KEY environment variable to your Gandi API Key. Please explore the code to see existing probes and actions.","title":"Usage"},{"location":"drivers/gandi/#contribute","text":"If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. The Chaos Toolkit projects require all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR.","title":"Contribute"},{"location":"drivers/gandi/#develop","text":"If you wish to develop on this project, make sure to install the development dependencies. But first, create a virtual environment and then install those dependencies. $ pip install -r requirements-dev.txt -r requirements.txt Then, point your environment to this directory: $ pip install -e . Now, you can edit the files and they will be automatically be seen by your environment, even when running from the chaos command locally.","title":"Develop"},{"location":"drivers/gandi/#test","text":"To run the tests for the project execute the following: $ pytest","title":"Test"},{"location":"drivers/gandi/#exported-activities","text":"","title":"Exported Activities"},{"location":"drivers/gandi/#domains","text":"","title":"domains"},{"location":"drivers/gandi/#domains_should_not_expire_in","text":"Type tolerance Module chaosgandi.domains.tolerances Name domains_should_not_expire_in Return boolean Go through the list of Gandi domains and fails if any expires before the given date threshold as a relative time to now. Signature: def domains_should_not_expire_in ( value : List [ Dict [ str , Any ]] = None , when : str = '1 month' ) -> bool : pass Arguments: Name Type Default Required value list null No when string \u201c1 month\u201d No Tolerances declare the value argument which is automatically injected by Chaos Toolkit as the output of the probe they are evaluating. Usage: { \"steady-state-hypothesis\" : { \"title\" : \"...\" , \"probes\" : [ { \"type\" : \"probe\" , \"tolerance\" : { \"name\" : \"domains-should-not-expire-in\" , \"type\" : \"tolerance\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgandi.domains.tolerances\" , \"func\" : \"domains_should_not_expire_in\" } }, \"...\" : \"...\" } ] } } steady-state-hypothesis : probes : - '...' : '...' tolerance : name : domains-should-not-expire-in provider : func : domains_should_not_expire_in module : chaosgandi.domains.tolerances type : python type : tolerance type : probe title : '...'","title":"domains_should_not_expire_in"},{"location":"drivers/gandi/#list_domains","text":"Type probe Module chaosgandi.domains.probes Name list_domains Return list List all domains or those matching the given TLD or FQDN filters and return the list as-is. See https://api.gandi.net/docs/domains/#v5-domain-domains Signature: def list_domains ( fqdn_filter : str = None , tld_filter : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required fqdn_filter string null No tld_filter string null No Usage: { \"name\" : \"list-domains\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgandi.domains.probes\" , \"func\" : \"list_domains\" } } name : list-domains provider : func : list_domains module : chaosgandi.domains.probes type : python type : probe","title":"list_domains"},{"location":"drivers/gandi/#list_nameservers","text":"Type probe Module chaosgandi.domains.probes Name list_nameservers Return list List nameservers set for this domain and return them as a list of strings. See https://api.gandi.net/docs/domains/#v5-domain-domains-domain-nameservers Signature: def list_nameservers ( domain : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ str ]: pass Arguments: Name Type Default Required domain string Yes Usage: { \"name\" : \"list-nameservers\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgandi.domains.probes\" , \"func\" : \"list_nameservers\" , \"arguments\" : { \"domain\" : \"\" } } } name : list-nameservers provider : arguments : domain : '' func : list_nameservers module : chaosgandi.domains.probes type : python type : probe","title":"list_nameservers"},{"location":"drivers/gcp/","text":"Extension chaosgcp \u00b6 Version 0.2.1 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-google-cloud-platform This project is a collection of actions and probes , gathered as an extension to the Chaos Toolkit . It targets the Google Cloud Platform . Install \u00b6 This package requires Python 3.5+ To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install -U chaostoolkit-google-cloud-platform Usage \u00b6 To use the probes and actions from this package, add the following to your experiment file: { \"type\" : \"action\" , \"name\" : \"swap-nodepool-for-a-new-one\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgcp.gke.nodepool.actions\" , \"func\" : \"swap_nodepool\" , \"secrets\" : [ \"gcp\" , \"k8s\" ], \"arguments\" : { \"old_node_pool_id\" : \"...\" , \"new_nodepool_body\" : { \"nodePool\" : { \"config\" : { \"oauthScopes\" : [ \"gke-version-default\" , \"https://www.googleapis.com/auth/devstorage.read_only\" , \"https://www.googleapis.com/auth/logging.write\" , \"https://www.googleapis.com/auth/monitoring\" , \"https://www.googleapis.com/auth/service.management.readonly\" , \"https://www.googleapis.com/auth/servicecontrol\" , \"https://www.googleapis.com/auth/trace.append\" ] }, \"initialNodeCount\" : 3 , \"name\" : \"new-default-pool\" } } } } } That\u2019s it! Please explore the code to see existing probes and actions. Configuration \u00b6 Project and Cluster Information \u00b6 You can pass the context via the configuration section of your experiment: { \"configuration\" : { \"gcp_project_id\" : \"...\" , \"gcp_gke_cluster_name\" : \"...\" , \"gcp_region\" : \"...\" , \"gcp_zone\" : \"...\" } } Note that most functions exposed in this package also take those values directly when you want specific values for them. Credentials \u00b6 This extension expects a service account with enough permissions to perform its operations. Please create such a service account manually (do not use the default one for your cluster if you can, so you\u2019ll be able to delete that service account if need be). Once you have created your service account, either keep the file on the same machine where you will be running the experiment from. Or, pass its content as part of the secrets section, although this is not recommended because your sensitive data will be quite visible. Here is the first way: { \"secrets\" : { \"gcp\" : { \"service_account_file\" : \"/path/to/sa.json\" } } } While the embedded way looks like this: { \"secrets\" : { \"k8s\" : { \"KUBERNETES_CONTEXT\" : \"gke_project_name-g70e8ya0_us-central1_cluster-hello-world\" }, \"gcp\" : { \"service_account_info\" : { \"type\" : \"service_account\" , \"project_id\" : \"...\" , \"private_key_id\" : \"...\" , \"private_key\" : \"...\" , \"client_email\" : \"...\" , \"client_id\" : \"...\" , \"auth_uri\" : \"https://accounts.google.com/o/oauth2/auth\" , \"token_uri\" : \"https://accounts.google.com/o/oauth2/token\" , \"auth_provider_x509_cert_url\" : \"https://www.googleapis.com/oauth2/v1/certs\" , \"client_x509_cert_url\" : \"https://www.googleapis.com/robot/v1/metadata/x509/....\" } } } } Notice also how we provided here the k8s entry. This is only because, in our example we use the swap_nodepool action which drains the Kubernetes nodes and it requires the Kubernetes cluster credentials to work. These are documented in the Kubernetes extension for Chaos Toolkit . This is the only action that requires such a secret payload, others only speak to the GCP API. Putting it all together \u00b6 Here is a full example: { \"version\" : \"1.0.0\" , \"title\" : \"...\" , \"description\" : \"...\" , \"configuration\" : { \"gcp_project_id\" : \"...\" , \"gcp_gke_cluster_name\" : \"...\" , \"gcp_region\" : \"...\" , \"gcp_zone\" : \"...\" }, \"secrets\" : { \"gcp\" : { \"service_account_file\" : \"/path/to/sa.json\" }, \"k8s\" : { \"KUBERNETES_CONTEXT\" : \"gke_project_name-g70e8ya0_us-central1_cluster-hello-world\" }, }, \"method\" : [ { \"type\" : \"action\" , \"name\" : \"swap-nodepool-for-a-new-one\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgcp.gke.nodepool.actions\" , \"func\" : \"swap_nodepool\" , \"secrets\" : [ \"gcp\" , \"k8s\" ], \"arguments\" : { \"old_node_pool_id\" : \"...\" , \"new_nodepool_body\" : { \"nodePool\" : { \"config\" : { \"oauthScopes\" : [ \"gke-version-default\" , \"https://www.googleapis.com/auth/devstorage.read_only\" , \"https://www.googleapis.com/auth/logging.write\" , \"https://www.googleapis.com/auth/monitoring\" , \"https://www.googleapis.com/auth/service.management.readonly\" , \"https://www.googleapis.com/auth/servicecontrol\" , \"https://www.googleapis.com/auth/trace.append\" ] }, \"initialNodeCount\" : 3 , \"name\" : \"new-default-pool\" } } } } } ] } Migrate from GCE extension \u00b6 If you previously used the deprecated GCE extension , here is a quick recap of changes you\u2019ll need to go through to update your experiments. The module chaosgce.nodepool.actions has been replaced by chaosgcp.gke.nodepool.actions . You will need to update the module key for the python providers. The configuration keys in the configuration section have been renamed accordingly: \"gce_project_id\" -> \"gcp_project_id\" \"gce_region\" -> \"gcp_region\" \"gce_zone\" -> \"gcp_zone\" \"gce_cluster_name\" -> \"gcp_gke_cluster_name\" Contribute \u00b6 If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. The Chaos Toolkit projects require all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR. If you wish to add a new function to this extension, that is related to a Google Cloud product that is not available yet in this package, please use the product short name or acronym as a first level subpackage (eg. iam, gke, sql, storage, \u2026). See the list of [GCP products and services][gcp_products]. [gcp_products] https://cloud.google.com/products/ Develop \u00b6 If you wish to develop on this project, make sure to install the development dependencies. But first, create a virtual environment and then install those dependencies. $ pip install -r requirements-dev.txt -r requirements.txt Then, point your environment to this directory: $ python setup.py develop Now, you can edit the files and they will be automatically be seen by your environment, even when running from the chaos command locally. Test \u00b6 To run the tests for the project execute the following: $ pytest Exported Activities \u00b6 cloudbuild \u00b6 get_trigger \u00b6 Type probe Module chaosgcp.cloudbuild.probes Name get_trigger Return None Returns information about a BuildTrigger. See: https://cloud.google.com/cloud-build/docs/api/reference/rest/v1/projects.triggers/get :param name: name of the trigger :param configuration: :param secrets: :return: Signature: def get_trigger ( name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes Usage: { \"name\" : \"get-trigger\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgcp.cloudbuild.probes\" , \"func\" : \"get_trigger\" , \"arguments\" : { \"name\" : \"\" } } } name : get-trigger provider : arguments : name : '' func : get_trigger module : chaosgcp.cloudbuild.probes type : python type : probe list_trigger_names \u00b6 Type probe Module chaosgcp.cloudbuild.probes Name list_trigger_names Return None List only the trigger names of a project :param configuration: :param secrets: :return: Signature: def list_trigger_names ( configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required Usage: { \"name\" : \"list-trigger-names\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgcp.cloudbuild.probes\" , \"func\" : \"list_trigger_names\" } } name : list-trigger-names provider : func : list_trigger_names module : chaosgcp.cloudbuild.probes type : python type : probe list_triggers \u00b6 Type probe Module chaosgcp.cloudbuild.probes Name list_triggers Return None Lists existing BuildTriggers. See: https://cloud.google.com/cloud-build/docs/api/reference/rest/v1/projects.triggers/list :param configuration: :param secrets: :return: Signature: def list_triggers ( configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required Usage: { \"name\" : \"list-triggers\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgcp.cloudbuild.probes\" , \"func\" : \"list_triggers\" } } name : list-triggers provider : func : list_triggers module : chaosgcp.cloudbuild.probes type : python type : probe run_trigger \u00b6 Type action Module chaosgcp.cloudbuild.actions Name run_trigger Return None Runs a BuildTrigger at a particular source revision. NB: The trigger must exist in the targeted project. See: https://cloud.google.com/cloud-build/docs/api/reference/rest/v1/projects.triggers/run :param name: name of the trigger :param source: location of the source in a Google Cloud Source Repository :param configuration: :param secrets: :return: Signature: def run_trigger ( name : str , source : Dict [ Any , Any ], configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes source mapping Yes Usage: { \"name\" : \"run-trigger\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgcp.cloudbuild.actions\" , \"func\" : \"run_trigger\" , \"arguments\" : { \"name\" : \"\" , \"source\" : {} } } } name : run-trigger provider : arguments : name : '' source : {} func : run_trigger module : chaosgcp.cloudbuild.actions type : python type : action nodepool \u00b6 create_new_nodepool \u00b6 Type action Module chaosgcp.gke.nodepool.actions Name create_new_nodepool Return mapping Create a new node pool in the given cluster/zone of the provided project. The node pool config must be passed a mapping to the body parameter and respect the REST API. If wait_until_complete is set to True (the default), the function will block until the node pool is ready. Otherwise, will return immediatly with the operation information. See: https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.zones.clusters.nodePools/create Signature: def create_new_nodepool ( body : Dict [ str , Any ], wait_until_complete : bool = True , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required body mapping Yes wait_until_complete boolean true No Usage: { \"name\" : \"create-new-nodepool\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgcp.gke.nodepool.actions\" , \"func\" : \"create_new_nodepool\" , \"arguments\" : { \"body\" : {} } } } name : create-new-nodepool provider : arguments : body : {} func : create_new_nodepool module : chaosgcp.gke.nodepool.actions type : python type : action delete_nodepool \u00b6 Type action Module chaosgcp.gke.nodepool.actions Name delete_nodepool Return mapping Delete node pool from the given cluster/zone of the provided project. If wait_until_complete is set to True (the default), the function will block until the node pool is deleted. Otherwise, will return immediatly with the operation information. See: https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.zones.clusters.nodePools/create Signature: def delete_nodepool ( node_pool_id : str , wait_until_complete : bool = True , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required node_pool_id string Yes wait_until_complete boolean true No Usage: { \"name\" : \"delete-nodepool\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgcp.gke.nodepool.actions\" , \"func\" : \"delete_nodepool\" , \"arguments\" : { \"node_pool_id\" : \"\" } } } name : delete-nodepool provider : arguments : node_pool_id : '' func : delete_nodepool module : chaosgcp.gke.nodepool.actions type : python type : action swap_nodepool \u00b6 Type action Module chaosgcp.gke.nodepool.actions Name swap_nodepool Return mapping Create a new nodepool, drain the old one so pods can be rescheduled on the new pool. Delete the old nodepool only delete_old_node_pool is set to True , which is not the default. Otherwise, leave the old node pool cordonned so it cannot be scheduled any longer. Please ensure to provide the Kubernetes secrets as well when calling this action. See https://github.com/chaostoolkit/chaostoolkit-kubernetes#configuration Signature: def swap_nodepool ( old_node_pool_id : str , new_nodepool_body : Dict [ str , Any ], wait_until_complete : bool = True , delete_old_node_pool : bool = False , drain_timeout : int = 120 , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required old_node_pool_id string Yes new_nodepool_body mapping Yes wait_until_complete boolean true No delete_old_node_pool boolean false No drain_timeout integer 120 No Usage: { \"name\" : \"swap-nodepool\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgcp.gke.nodepool.actions\" , \"func\" : \"swap_nodepool\" , \"arguments\" : { \"old_node_pool_id\" : \"\" , \"new_nodepool_body\" : {} } } } name : swap-nodepool provider : arguments : new_nodepool_body : {} old_node_pool_id : '' func : swap_nodepool module : chaosgcp.gke.nodepool.actions type : python type : action sql \u00b6 describe_instance \u00b6 Type probe Module chaosgcp.sql.probes Name describe_instance Return mapping Displays configuration and metadata about a Cloud SQL instance. Information such as instance name, IP address, region, the CA certificate and configuration settings will be displayed. See: https://cloud.google.com/sql/docs/postgres/admin-api/v1beta4/instances/get :param instance_id: Cloud SQL instance ID. Signature: def describe_instance ( instance_id : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required instance_id string Yes Usage: { \"name\" : \"describe-instance\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgcp.sql.probes\" , \"func\" : \"describe_instance\" , \"arguments\" : { \"instance_id\" : \"\" } } } name : describe-instance provider : arguments : instance_id : '' func : describe_instance module : chaosgcp.sql.probes type : python type : probe export_data \u00b6 Type action Module chaosgcp.sql.actions Name export_data Return mapping Exports data from a Cloud SQL instance to a Cloud Storage bucket as a SQL dump or CSV file. See: https://cloud.google.com/sql/docs/postgres/admin-api/v1beta4/instances/export If project_id is given, it will take precedence over the global project ID defined at the configuration level. Signature: def export_data ( instance_id : str , storage_uri : str , project_id : str = None , file_type : str = 'sql' , databases : List [ str ] = None , tables : List [ str ] = None , export_schema_only : bool = False , wait_until_complete : bool = True , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required instance_id string Yes storage_uri string Yes project_id string null No file_type string \u201csql\u201d No databases list null No tables list null No export_schema_only boolean false No wait_until_complete boolean true No Usage: { \"name\" : \"export-data\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgcp.sql.actions\" , \"func\" : \"export_data\" , \"arguments\" : { \"instance_id\" : \"\" , \"storage_uri\" : \"\" } } } name : export-data provider : arguments : instance_id : '' storage_uri : '' func : export_data module : chaosgcp.sql.actions type : python type : action import_data \u00b6 Type action Module chaosgcp.sql.actions Name import_data Return mapping Imports data into a Cloud SQL instance from a SQL dump or CSV file in Cloud Storage. See: https://cloud.google.com/sql/docs/postgres/admin-api/v1beta4/instances/import If project_id is given, it will take precedence over the global project ID defined at the configuration level. Signature: def import_data ( instance_id : str , storage_uri : str , database : str , project_id : str = None , file_type : str = 'sql' , import_user : str = None , table : str = None , columns : List [ str ] = None , wait_until_complete : bool = True , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required instance_id string Yes storage_uri string Yes database string Yes project_id string null No file_type string \u201csql\u201d No import_user string null No table string null No columns list null No wait_until_complete boolean true No Usage: { \"name\" : \"import-data\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgcp.sql.actions\" , \"func\" : \"import_data\" , \"arguments\" : { \"instance_id\" : \"\" , \"storage_uri\" : \"\" , \"database\" : \"\" } } } name : import-data provider : arguments : database : '' instance_id : '' storage_uri : '' func : import_data module : chaosgcp.sql.actions type : python type : action list_instances \u00b6 Type probe Module chaosgcp.sql.probes Name list_instances Return mapping Lists Cloud SQL instances in a given project in the alphabetical order of the instance name. See: https://cloud.google.com/sql/docs/postgres/admin-api/v1beta4/instances/list Signature: def list_instances ( configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required Usage: { \"name\" : \"list-instances\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgcp.sql.probes\" , \"func\" : \"list_instances\" } } name : list-instances provider : func : list_instances module : chaosgcp.sql.probes type : python type : probe trigger_failover \u00b6 Type action Module chaosgcp.sql.actions Name trigger_failover Return mapping Causes a high-availability Cloud SQL instance to failover. See: https://cloud.google.com/sql/docs/postgres/admin-api/v1beta4/instances/failover :param instance_id: Cloud SQL instance ID. :param wait_until_complete: wait for the operation in progress to complete. :param settings_version: The current settings version of this instance. :return: Signature: def trigger_failover ( instance_id : str , wait_until_complete : bool = True , settings_version : int = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required instance_id string Yes wait_until_complete boolean true No settings_version integer null No Usage: { \"name\" : \"trigger-failover\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgcp.sql.actions\" , \"func\" : \"trigger_failover\" , \"arguments\" : { \"instance_id\" : \"\" } } } name : trigger-failover provider : arguments : instance_id : '' func : trigger_failover module : chaosgcp.sql.actions type : python type : action storage \u00b6 object_exists \u00b6 Type probe Module chaosgcp.storage.probes Name object_exists Return boolean Indicates whether a file in Cloud Storage bucket exists. :param bucket_name: name of the bucket :param object_name: name of the object within the bucket as path :param configuration: :param secrets: Signature: def object_exists ( bucket_name : str , object_name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required bucket_name string Yes object_name string Yes Usage: { \"name\" : \"object-exists\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgcp.storage.probes\" , \"func\" : \"object_exists\" , \"arguments\" : { \"bucket_name\" : \"\" , \"object_name\" : \"\" } } } name : object-exists provider : arguments : bucket_name : '' object_name : '' func : object_exists module : chaosgcp.storage.probes type : python type : probe","title":"Google Cloud Platform"},{"location":"drivers/gcp/#extension-chaosgcp","text":"Version 0.2.1 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-google-cloud-platform This project is a collection of actions and probes , gathered as an extension to the Chaos Toolkit . It targets the Google Cloud Platform .","title":"Extension chaosgcp"},{"location":"drivers/gcp/#install","text":"This package requires Python 3.5+ To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install -U chaostoolkit-google-cloud-platform","title":"Install"},{"location":"drivers/gcp/#usage","text":"To use the probes and actions from this package, add the following to your experiment file: { \"type\" : \"action\" , \"name\" : \"swap-nodepool-for-a-new-one\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgcp.gke.nodepool.actions\" , \"func\" : \"swap_nodepool\" , \"secrets\" : [ \"gcp\" , \"k8s\" ], \"arguments\" : { \"old_node_pool_id\" : \"...\" , \"new_nodepool_body\" : { \"nodePool\" : { \"config\" : { \"oauthScopes\" : [ \"gke-version-default\" , \"https://www.googleapis.com/auth/devstorage.read_only\" , \"https://www.googleapis.com/auth/logging.write\" , \"https://www.googleapis.com/auth/monitoring\" , \"https://www.googleapis.com/auth/service.management.readonly\" , \"https://www.googleapis.com/auth/servicecontrol\" , \"https://www.googleapis.com/auth/trace.append\" ] }, \"initialNodeCount\" : 3 , \"name\" : \"new-default-pool\" } } } } } That\u2019s it! Please explore the code to see existing probes and actions.","title":"Usage"},{"location":"drivers/gcp/#configuration","text":"","title":"Configuration"},{"location":"drivers/gcp/#project-and-cluster-information","text":"You can pass the context via the configuration section of your experiment: { \"configuration\" : { \"gcp_project_id\" : \"...\" , \"gcp_gke_cluster_name\" : \"...\" , \"gcp_region\" : \"...\" , \"gcp_zone\" : \"...\" } } Note that most functions exposed in this package also take those values directly when you want specific values for them.","title":"Project and Cluster Information"},{"location":"drivers/gcp/#credentials","text":"This extension expects a service account with enough permissions to perform its operations. Please create such a service account manually (do not use the default one for your cluster if you can, so you\u2019ll be able to delete that service account if need be). Once you have created your service account, either keep the file on the same machine where you will be running the experiment from. Or, pass its content as part of the secrets section, although this is not recommended because your sensitive data will be quite visible. Here is the first way: { \"secrets\" : { \"gcp\" : { \"service_account_file\" : \"/path/to/sa.json\" } } } While the embedded way looks like this: { \"secrets\" : { \"k8s\" : { \"KUBERNETES_CONTEXT\" : \"gke_project_name-g70e8ya0_us-central1_cluster-hello-world\" }, \"gcp\" : { \"service_account_info\" : { \"type\" : \"service_account\" , \"project_id\" : \"...\" , \"private_key_id\" : \"...\" , \"private_key\" : \"...\" , \"client_email\" : \"...\" , \"client_id\" : \"...\" , \"auth_uri\" : \"https://accounts.google.com/o/oauth2/auth\" , \"token_uri\" : \"https://accounts.google.com/o/oauth2/token\" , \"auth_provider_x509_cert_url\" : \"https://www.googleapis.com/oauth2/v1/certs\" , \"client_x509_cert_url\" : \"https://www.googleapis.com/robot/v1/metadata/x509/....\" } } } } Notice also how we provided here the k8s entry. This is only because, in our example we use the swap_nodepool action which drains the Kubernetes nodes and it requires the Kubernetes cluster credentials to work. These are documented in the Kubernetes extension for Chaos Toolkit . This is the only action that requires such a secret payload, others only speak to the GCP API.","title":"Credentials"},{"location":"drivers/gcp/#putting-it-all-together","text":"Here is a full example: { \"version\" : \"1.0.0\" , \"title\" : \"...\" , \"description\" : \"...\" , \"configuration\" : { \"gcp_project_id\" : \"...\" , \"gcp_gke_cluster_name\" : \"...\" , \"gcp_region\" : \"...\" , \"gcp_zone\" : \"...\" }, \"secrets\" : { \"gcp\" : { \"service_account_file\" : \"/path/to/sa.json\" }, \"k8s\" : { \"KUBERNETES_CONTEXT\" : \"gke_project_name-g70e8ya0_us-central1_cluster-hello-world\" }, }, \"method\" : [ { \"type\" : \"action\" , \"name\" : \"swap-nodepool-for-a-new-one\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgcp.gke.nodepool.actions\" , \"func\" : \"swap_nodepool\" , \"secrets\" : [ \"gcp\" , \"k8s\" ], \"arguments\" : { \"old_node_pool_id\" : \"...\" , \"new_nodepool_body\" : { \"nodePool\" : { \"config\" : { \"oauthScopes\" : [ \"gke-version-default\" , \"https://www.googleapis.com/auth/devstorage.read_only\" , \"https://www.googleapis.com/auth/logging.write\" , \"https://www.googleapis.com/auth/monitoring\" , \"https://www.googleapis.com/auth/service.management.readonly\" , \"https://www.googleapis.com/auth/servicecontrol\" , \"https://www.googleapis.com/auth/trace.append\" ] }, \"initialNodeCount\" : 3 , \"name\" : \"new-default-pool\" } } } } } ] }","title":"Putting it all together"},{"location":"drivers/gcp/#migrate-from-gce-extension","text":"If you previously used the deprecated GCE extension , here is a quick recap of changes you\u2019ll need to go through to update your experiments. The module chaosgce.nodepool.actions has been replaced by chaosgcp.gke.nodepool.actions . You will need to update the module key for the python providers. The configuration keys in the configuration section have been renamed accordingly: \"gce_project_id\" -> \"gcp_project_id\" \"gce_region\" -> \"gcp_region\" \"gce_zone\" -> \"gcp_zone\" \"gce_cluster_name\" -> \"gcp_gke_cluster_name\"","title":"Migrate from GCE extension"},{"location":"drivers/gcp/#contribute","text":"If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. The Chaos Toolkit projects require all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR. If you wish to add a new function to this extension, that is related to a Google Cloud product that is not available yet in this package, please use the product short name or acronym as a first level subpackage (eg. iam, gke, sql, storage, \u2026). See the list of [GCP products and services][gcp_products]. [gcp_products] https://cloud.google.com/products/","title":"Contribute"},{"location":"drivers/gcp/#develop","text":"If you wish to develop on this project, make sure to install the development dependencies. But first, create a virtual environment and then install those dependencies. $ pip install -r requirements-dev.txt -r requirements.txt Then, point your environment to this directory: $ python setup.py develop Now, you can edit the files and they will be automatically be seen by your environment, even when running from the chaos command locally.","title":"Develop"},{"location":"drivers/gcp/#test","text":"To run the tests for the project execute the following: $ pytest","title":"Test"},{"location":"drivers/gcp/#exported-activities","text":"","title":"Exported Activities"},{"location":"drivers/gcp/#cloudbuild","text":"","title":"cloudbuild"},{"location":"drivers/gcp/#get_trigger","text":"Type probe Module chaosgcp.cloudbuild.probes Name get_trigger Return None Returns information about a BuildTrigger. See: https://cloud.google.com/cloud-build/docs/api/reference/rest/v1/projects.triggers/get :param name: name of the trigger :param configuration: :param secrets: :return: Signature: def get_trigger ( name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes Usage: { \"name\" : \"get-trigger\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgcp.cloudbuild.probes\" , \"func\" : \"get_trigger\" , \"arguments\" : { \"name\" : \"\" } } } name : get-trigger provider : arguments : name : '' func : get_trigger module : chaosgcp.cloudbuild.probes type : python type : probe","title":"get_trigger"},{"location":"drivers/gcp/#list_trigger_names","text":"Type probe Module chaosgcp.cloudbuild.probes Name list_trigger_names Return None List only the trigger names of a project :param configuration: :param secrets: :return: Signature: def list_trigger_names ( configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required Usage: { \"name\" : \"list-trigger-names\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgcp.cloudbuild.probes\" , \"func\" : \"list_trigger_names\" } } name : list-trigger-names provider : func : list_trigger_names module : chaosgcp.cloudbuild.probes type : python type : probe","title":"list_trigger_names"},{"location":"drivers/gcp/#list_triggers","text":"Type probe Module chaosgcp.cloudbuild.probes Name list_triggers Return None Lists existing BuildTriggers. See: https://cloud.google.com/cloud-build/docs/api/reference/rest/v1/projects.triggers/list :param configuration: :param secrets: :return: Signature: def list_triggers ( configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required Usage: { \"name\" : \"list-triggers\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgcp.cloudbuild.probes\" , \"func\" : \"list_triggers\" } } name : list-triggers provider : func : list_triggers module : chaosgcp.cloudbuild.probes type : python type : probe","title":"list_triggers"},{"location":"drivers/gcp/#run_trigger","text":"Type action Module chaosgcp.cloudbuild.actions Name run_trigger Return None Runs a BuildTrigger at a particular source revision. NB: The trigger must exist in the targeted project. See: https://cloud.google.com/cloud-build/docs/api/reference/rest/v1/projects.triggers/run :param name: name of the trigger :param source: location of the source in a Google Cloud Source Repository :param configuration: :param secrets: :return: Signature: def run_trigger ( name : str , source : Dict [ Any , Any ], configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes source mapping Yes Usage: { \"name\" : \"run-trigger\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgcp.cloudbuild.actions\" , \"func\" : \"run_trigger\" , \"arguments\" : { \"name\" : \"\" , \"source\" : {} } } } name : run-trigger provider : arguments : name : '' source : {} func : run_trigger module : chaosgcp.cloudbuild.actions type : python type : action","title":"run_trigger"},{"location":"drivers/gcp/#nodepool","text":"","title":"nodepool"},{"location":"drivers/gcp/#create_new_nodepool","text":"Type action Module chaosgcp.gke.nodepool.actions Name create_new_nodepool Return mapping Create a new node pool in the given cluster/zone of the provided project. The node pool config must be passed a mapping to the body parameter and respect the REST API. If wait_until_complete is set to True (the default), the function will block until the node pool is ready. Otherwise, will return immediatly with the operation information. See: https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.zones.clusters.nodePools/create Signature: def create_new_nodepool ( body : Dict [ str , Any ], wait_until_complete : bool = True , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required body mapping Yes wait_until_complete boolean true No Usage: { \"name\" : \"create-new-nodepool\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgcp.gke.nodepool.actions\" , \"func\" : \"create_new_nodepool\" , \"arguments\" : { \"body\" : {} } } } name : create-new-nodepool provider : arguments : body : {} func : create_new_nodepool module : chaosgcp.gke.nodepool.actions type : python type : action","title":"create_new_nodepool"},{"location":"drivers/gcp/#delete_nodepool","text":"Type action Module chaosgcp.gke.nodepool.actions Name delete_nodepool Return mapping Delete node pool from the given cluster/zone of the provided project. If wait_until_complete is set to True (the default), the function will block until the node pool is deleted. Otherwise, will return immediatly with the operation information. See: https://cloud.google.com/kubernetes-engine/docs/reference/rest/v1/projects.zones.clusters.nodePools/create Signature: def delete_nodepool ( node_pool_id : str , wait_until_complete : bool = True , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required node_pool_id string Yes wait_until_complete boolean true No Usage: { \"name\" : \"delete-nodepool\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgcp.gke.nodepool.actions\" , \"func\" : \"delete_nodepool\" , \"arguments\" : { \"node_pool_id\" : \"\" } } } name : delete-nodepool provider : arguments : node_pool_id : '' func : delete_nodepool module : chaosgcp.gke.nodepool.actions type : python type : action","title":"delete_nodepool"},{"location":"drivers/gcp/#swap_nodepool","text":"Type action Module chaosgcp.gke.nodepool.actions Name swap_nodepool Return mapping Create a new nodepool, drain the old one so pods can be rescheduled on the new pool. Delete the old nodepool only delete_old_node_pool is set to True , which is not the default. Otherwise, leave the old node pool cordonned so it cannot be scheduled any longer. Please ensure to provide the Kubernetes secrets as well when calling this action. See https://github.com/chaostoolkit/chaostoolkit-kubernetes#configuration Signature: def swap_nodepool ( old_node_pool_id : str , new_nodepool_body : Dict [ str , Any ], wait_until_complete : bool = True , delete_old_node_pool : bool = False , drain_timeout : int = 120 , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required old_node_pool_id string Yes new_nodepool_body mapping Yes wait_until_complete boolean true No delete_old_node_pool boolean false No drain_timeout integer 120 No Usage: { \"name\" : \"swap-nodepool\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgcp.gke.nodepool.actions\" , \"func\" : \"swap_nodepool\" , \"arguments\" : { \"old_node_pool_id\" : \"\" , \"new_nodepool_body\" : {} } } } name : swap-nodepool provider : arguments : new_nodepool_body : {} old_node_pool_id : '' func : swap_nodepool module : chaosgcp.gke.nodepool.actions type : python type : action","title":"swap_nodepool"},{"location":"drivers/gcp/#sql","text":"","title":"sql"},{"location":"drivers/gcp/#describe_instance","text":"Type probe Module chaosgcp.sql.probes Name describe_instance Return mapping Displays configuration and metadata about a Cloud SQL instance. Information such as instance name, IP address, region, the CA certificate and configuration settings will be displayed. See: https://cloud.google.com/sql/docs/postgres/admin-api/v1beta4/instances/get :param instance_id: Cloud SQL instance ID. Signature: def describe_instance ( instance_id : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required instance_id string Yes Usage: { \"name\" : \"describe-instance\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgcp.sql.probes\" , \"func\" : \"describe_instance\" , \"arguments\" : { \"instance_id\" : \"\" } } } name : describe-instance provider : arguments : instance_id : '' func : describe_instance module : chaosgcp.sql.probes type : python type : probe","title":"describe_instance"},{"location":"drivers/gcp/#export_data","text":"Type action Module chaosgcp.sql.actions Name export_data Return mapping Exports data from a Cloud SQL instance to a Cloud Storage bucket as a SQL dump or CSV file. See: https://cloud.google.com/sql/docs/postgres/admin-api/v1beta4/instances/export If project_id is given, it will take precedence over the global project ID defined at the configuration level. Signature: def export_data ( instance_id : str , storage_uri : str , project_id : str = None , file_type : str = 'sql' , databases : List [ str ] = None , tables : List [ str ] = None , export_schema_only : bool = False , wait_until_complete : bool = True , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required instance_id string Yes storage_uri string Yes project_id string null No file_type string \u201csql\u201d No databases list null No tables list null No export_schema_only boolean false No wait_until_complete boolean true No Usage: { \"name\" : \"export-data\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgcp.sql.actions\" , \"func\" : \"export_data\" , \"arguments\" : { \"instance_id\" : \"\" , \"storage_uri\" : \"\" } } } name : export-data provider : arguments : instance_id : '' storage_uri : '' func : export_data module : chaosgcp.sql.actions type : python type : action","title":"export_data"},{"location":"drivers/gcp/#import_data","text":"Type action Module chaosgcp.sql.actions Name import_data Return mapping Imports data into a Cloud SQL instance from a SQL dump or CSV file in Cloud Storage. See: https://cloud.google.com/sql/docs/postgres/admin-api/v1beta4/instances/import If project_id is given, it will take precedence over the global project ID defined at the configuration level. Signature: def import_data ( instance_id : str , storage_uri : str , database : str , project_id : str = None , file_type : str = 'sql' , import_user : str = None , table : str = None , columns : List [ str ] = None , wait_until_complete : bool = True , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required instance_id string Yes storage_uri string Yes database string Yes project_id string null No file_type string \u201csql\u201d No import_user string null No table string null No columns list null No wait_until_complete boolean true No Usage: { \"name\" : \"import-data\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgcp.sql.actions\" , \"func\" : \"import_data\" , \"arguments\" : { \"instance_id\" : \"\" , \"storage_uri\" : \"\" , \"database\" : \"\" } } } name : import-data provider : arguments : database : '' instance_id : '' storage_uri : '' func : import_data module : chaosgcp.sql.actions type : python type : action","title":"import_data"},{"location":"drivers/gcp/#list_instances","text":"Type probe Module chaosgcp.sql.probes Name list_instances Return mapping Lists Cloud SQL instances in a given project in the alphabetical order of the instance name. See: https://cloud.google.com/sql/docs/postgres/admin-api/v1beta4/instances/list Signature: def list_instances ( configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required Usage: { \"name\" : \"list-instances\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgcp.sql.probes\" , \"func\" : \"list_instances\" } } name : list-instances provider : func : list_instances module : chaosgcp.sql.probes type : python type : probe","title":"list_instances"},{"location":"drivers/gcp/#trigger_failover","text":"Type action Module chaosgcp.sql.actions Name trigger_failover Return mapping Causes a high-availability Cloud SQL instance to failover. See: https://cloud.google.com/sql/docs/postgres/admin-api/v1beta4/instances/failover :param instance_id: Cloud SQL instance ID. :param wait_until_complete: wait for the operation in progress to complete. :param settings_version: The current settings version of this instance. :return: Signature: def trigger_failover ( instance_id : str , wait_until_complete : bool = True , settings_version : int = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required instance_id string Yes wait_until_complete boolean true No settings_version integer null No Usage: { \"name\" : \"trigger-failover\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgcp.sql.actions\" , \"func\" : \"trigger_failover\" , \"arguments\" : { \"instance_id\" : \"\" } } } name : trigger-failover provider : arguments : instance_id : '' func : trigger_failover module : chaosgcp.sql.actions type : python type : action","title":"trigger_failover"},{"location":"drivers/gcp/#storage","text":"","title":"storage"},{"location":"drivers/gcp/#object_exists","text":"Type probe Module chaosgcp.storage.probes Name object_exists Return boolean Indicates whether a file in Cloud Storage bucket exists. :param bucket_name: name of the bucket :param object_name: name of the object within the bucket as path :param configuration: :param secrets: Signature: def object_exists ( bucket_name : str , object_name : str , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required bucket_name string Yes object_name string Yes Usage: { \"name\" : \"object-exists\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosgcp.storage.probes\" , \"func\" : \"object_exists\" , \"arguments\" : { \"bucket_name\" : \"\" , \"object_name\" : \"\" } } } name : object-exists provider : arguments : bucket_name : '' object_name : '' func : object_exists module : chaosgcp.storage.probes type : python type : probe","title":"object_exists"},{"location":"drivers/humio/","text":"Extension chaoshumio \u00b6 Version 0.5.1 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-humio This project is an extension for the Chaos Toolkit to target Humio . Install \u00b6 This package requires Python 3.5+ To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install -U chaostoolkit-humio Humio Token \u00b6 To use this extension, you will need one piece of information from Humio, the API token for a user. Usage \u00b6 This extension can be used a control on the experiment or a notification plugin of the Chaos Toolkit CLI itself. Usually, only one of these two methods is used at any given time as they serve similar purpose but feel free to combine them. The control approach is deeper because it logs down to the activity whereas notifications are much higher level. This extension can also be used as a probe to fetch information from Humio. Query Log Events \u00b6 To use this extension as a probe as part of your experiment, use it as follows: { \"configuration\" : { \"humio_url\" : { \"type\" : \"env\" , \"key\" : \"HUMIO_URL\" , \"default\" : \"https://cloud.humio.com\" }, \"humio_repository\" : { \"type\" : \"env\" , \"key\" : \"HUMIO_REPOSITORY\" , \"default\" : \"sandbox\" } }, \"secrets\" : { \"humio\" : { \"token\" : { \"type\" : \"env\" , \"key\" : \"HUMIO_TOKEN\" } } }, \"steady-state-hypothesis\" : { \"title\" : \"Running experiment\" , \"probes\" : [ { \"name\" : \"run-humio-search-query\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoshumio.probes\" , \"func\" : \"search_query\" , \"secrets\" : [ \"humio\" ], \"arguments\" : { \"qs\" : \"count(as=_count)\" , \"start\" : \"24hours\" , \"end\" : \"now\" } }, \"tolerance\" : { \"name\" : \"humio-query-result-value-greater-than\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoshumio.tolerances\" , \"func\" : \"field_value_above\" , \"arguments\" : { \"field\" : \"_count\" , \"lower\" : 1 } } } } ] } } In this example, we are using the search_query probe and validate it with a specific tolerance that can inspect the returned payload from Humio and ensure each value matches the required expectations. Notification \u00b6 To use this extension to push notifications, edit your chaostoolkit settings by adding the following payload: notifications : - type : plugin module : chaoshumio.notification humio_url : https://myhumio.company.com token : my-token By default all events will be forwarded to that channel. You may filter only those events you care for: notifications : - type : plugin module : chaoshumio.notification humio_url : https://myhumio.company.com token : my-token events : - run-failed - run-started Only sends those two events. Control \u00b6 To use this extension as a control over the experiment and send logs during the execution of the experiment to https://cloud.humio.com , add the following payload to your experiment: { \"secrets\" : { \"humio\" : { \"token\" : { \"type\" : \"env\" , \"key\" : \"HUMIO_INGEST_TOKEN\" } } }, \"controls\" : [ { \"name\" : \"humio-logger\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoshumio.control\" , \"secrets\" : [ \"humio\" ] } } ] } If you want to send logs to a different Humio URL endpoint, specify the humio_url configuration parameter. The following shows how this parameter: { \"secrets\" : { \"humio\" : { \"token\" : { \"type\" : \"env\" , \"key\" : \"HUMIO_INGEST_TOKEN\" } } }, \"configuration\" : { \"humio_url\" : \"https://myhumio.company.com\" }, \"controls\" : [ { \"name\" : \"humio-logger\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoshumio.control\" , \"secrets\" : [ \"humio\" ] } } ] } This will ensure the results of the experiment, steady-state, method, rollbacks and each activity are sent to Humio. The experiment itself will also be send initially. Contribute \u00b6 If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. The Chaos Toolkit projects require all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR. Develop \u00b6 If you wish to develop on this project, make sure to install the development dependencies. But first, create a virtual environment and then install those dependencies. $ pip install -r requirements-dev.txt -r requirements.txt Then, point your environment to this directory: $ pip install -e . Now, you can edit the files and they will be automatically be seen by your environment, even when running from the chaos command locally. Test \u00b6 To run the tests for the project execute the following: $ pytest Exported Controls \u00b6 This package exports controls covering the following phases of the execution of an experiment: Level Before After Experiment True True Steady-state Hypothesis False True Method False True Rollback False True Activities False True To use this control module, please add the following section to your experiment: { \"name\" : \"chaoshumio\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoshumio.control\" } } name : chaoshumio provider : module : chaoshumio.control type : python This block may also be enabled at any other level (steady-state hypothesis or activity) to focus only on that level. When enabled at the experiment level, by default, all sub-levels are also applied unless you set the automatic properties to false . Exported Activities \u00b6 notification \u00b6 notify \u00b6 Type Module chaoshumio.notification Name notify Return None Send a log message to the Humio ingest endpoint. The settings must contain: \"token\" : a slack API token \"humio_url\" : the Humio endpoint to send the event to If token is missing, no notification is sent. If humio_url is not specified then the default, https://cloud.humio.com , will be used. Signature: def notify ( settings : Dict [ str , Any ], event : Dict [ str , Any ]): pass Arguments: Name Type Default Required settings mapping Yes event mapping Yes Usage: { \"name\" : \"notify\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoshumio.notification\" , \"func\" : \"notify\" , \"arguments\" : { \"settings\" : {}, \"event\" : {} } } } name : notify provider : arguments : event : {} settings : {} func : notify module : chaoshumio.notification type : python type : '' probes \u00b6 search_query \u00b6 Type probe Module chaoshumio.probes Name search_query Return Any Perform a search query against the Humio API and returns its result as-is. Set result_as_text to true to get the result as a raw string, otherwise the probe returns a JSON payload. Make sure to set the Humio token as part of the experiment secrets and the repository name as part of its configuration section using the humio_repository key. See https://docs.humio.com/api/using-the-search-api-with-humio/#query Signature: def search_query ( qs : str , start : Union [ int , str ] = '24hours' , end : Union [ int , str ] = 'now' , tz_offset : int = 0 , params : Union [ str , Dict [ str , str ]] = None , result_as_text : bool = False , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Any : pass Arguments: Name Type Default Required qs string Yes start object \u201c24hours\u201d No end object \u201cnow\u201d No tz_offset integer 0 No params object null No result_as_text boolean false No Usage: { \"name\" : \"search-query\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoshumio.probes\" , \"func\" : \"search_query\" , \"arguments\" : { \"qs\" : \"\" } } } name : search-query provider : arguments : qs : '' func : search_query module : chaoshumio.probes type : python type : probe tolerances \u00b6 field_value_above \u00b6 Type tolerance Module chaoshumio.tolerances Name field_value_above Return boolean Validate value at the given field to be above the given lower limit. Signature: def field_value_above ( value : Any = None , field : str = None , lower : float = None ) -> bool : pass Arguments: Name Type Default Required value object null No field string null No lower number null No Tolerances declare the value argument which is automatically injected by Chaos Toolkit as the output of the probe they are evaluating. Usage: { \"steady-state-hypothesis\" : { \"title\" : \"...\" , \"probes\" : [ { \"type\" : \"probe\" , \"tolerance\" : { \"name\" : \"field-value-above\" , \"type\" : \"tolerance\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoshumio.tolerances\" , \"func\" : \"field_value_above\" } }, \"...\" : \"...\" } ] } } steady-state-hypothesis : probes : - '...' : '...' tolerance : name : field-value-above provider : func : field_value_above module : chaoshumio.tolerances type : python type : tolerance type : probe title : '...' field_value_between \u00b6 Type tolerance Module chaoshumio.tolerances Name field_value_between Return boolean Validate value at the given field to be between the lower/upper boundaries. Signature: def field_value_between ( value : Any = None , field : str = None , lower : float = None , upper : float = None ) -> bool : pass Arguments: Name Type Default Required value object null No field string null No lower number null No upper number null No Tolerances declare the value argument which is automatically injected by Chaos Toolkit as the output of the probe they are evaluating. Usage: { \"steady-state-hypothesis\" : { \"title\" : \"...\" , \"probes\" : [ { \"type\" : \"probe\" , \"tolerance\" : { \"name\" : \"field-value-between\" , \"type\" : \"tolerance\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoshumio.tolerances\" , \"func\" : \"field_value_between\" } }, \"...\" : \"...\" } ] } } steady-state-hypothesis : probes : - '...' : '...' tolerance : name : field-value-between provider : func : field_value_between module : chaoshumio.tolerances type : python type : tolerance type : probe title : '...' field_value_under \u00b6 Type tolerance Module chaoshumio.tolerances Name field_value_under Return boolean Validate value at the given field to be under the given upper limit. Signature: def field_value_under ( value : Any = None , field : str = None , upper : float = None ) -> bool : pass Arguments: Name Type Default Required value object null No field string null No upper number null No Tolerances declare the value argument which is automatically injected by Chaos Toolkit as the output of the probe they are evaluating. Usage: { \"steady-state-hypothesis\" : { \"title\" : \"...\" , \"probes\" : [ { \"type\" : \"probe\" , \"tolerance\" : { \"name\" : \"field-value-under\" , \"type\" : \"tolerance\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoshumio.tolerances\" , \"func\" : \"field_value_under\" } }, \"...\" : \"...\" } ] } } steady-state-hypothesis : probes : - '...' : '...' tolerance : name : field-value-under provider : func : field_value_under module : chaoshumio.tolerances type : python type : tolerance type : probe title : '...'","title":"Humio"},{"location":"drivers/humio/#extension-chaoshumio","text":"Version 0.5.1 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-humio This project is an extension for the Chaos Toolkit to target Humio .","title":"Extension chaoshumio"},{"location":"drivers/humio/#install","text":"This package requires Python 3.5+ To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install -U chaostoolkit-humio","title":"Install"},{"location":"drivers/humio/#humio-token","text":"To use this extension, you will need one piece of information from Humio, the API token for a user.","title":"Humio Token"},{"location":"drivers/humio/#usage","text":"This extension can be used a control on the experiment or a notification plugin of the Chaos Toolkit CLI itself. Usually, only one of these two methods is used at any given time as they serve similar purpose but feel free to combine them. The control approach is deeper because it logs down to the activity whereas notifications are much higher level. This extension can also be used as a probe to fetch information from Humio.","title":"Usage"},{"location":"drivers/humio/#query-log-events","text":"To use this extension as a probe as part of your experiment, use it as follows: { \"configuration\" : { \"humio_url\" : { \"type\" : \"env\" , \"key\" : \"HUMIO_URL\" , \"default\" : \"https://cloud.humio.com\" }, \"humio_repository\" : { \"type\" : \"env\" , \"key\" : \"HUMIO_REPOSITORY\" , \"default\" : \"sandbox\" } }, \"secrets\" : { \"humio\" : { \"token\" : { \"type\" : \"env\" , \"key\" : \"HUMIO_TOKEN\" } } }, \"steady-state-hypothesis\" : { \"title\" : \"Running experiment\" , \"probes\" : [ { \"name\" : \"run-humio-search-query\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoshumio.probes\" , \"func\" : \"search_query\" , \"secrets\" : [ \"humio\" ], \"arguments\" : { \"qs\" : \"count(as=_count)\" , \"start\" : \"24hours\" , \"end\" : \"now\" } }, \"tolerance\" : { \"name\" : \"humio-query-result-value-greater-than\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoshumio.tolerances\" , \"func\" : \"field_value_above\" , \"arguments\" : { \"field\" : \"_count\" , \"lower\" : 1 } } } } ] } } In this example, we are using the search_query probe and validate it with a specific tolerance that can inspect the returned payload from Humio and ensure each value matches the required expectations.","title":"Query Log Events"},{"location":"drivers/humio/#notification","text":"To use this extension to push notifications, edit your chaostoolkit settings by adding the following payload: notifications : - type : plugin module : chaoshumio.notification humio_url : https://myhumio.company.com token : my-token By default all events will be forwarded to that channel. You may filter only those events you care for: notifications : - type : plugin module : chaoshumio.notification humio_url : https://myhumio.company.com token : my-token events : - run-failed - run-started Only sends those two events.","title":"Notification"},{"location":"drivers/humio/#control","text":"To use this extension as a control over the experiment and send logs during the execution of the experiment to https://cloud.humio.com , add the following payload to your experiment: { \"secrets\" : { \"humio\" : { \"token\" : { \"type\" : \"env\" , \"key\" : \"HUMIO_INGEST_TOKEN\" } } }, \"controls\" : [ { \"name\" : \"humio-logger\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoshumio.control\" , \"secrets\" : [ \"humio\" ] } } ] } If you want to send logs to a different Humio URL endpoint, specify the humio_url configuration parameter. The following shows how this parameter: { \"secrets\" : { \"humio\" : { \"token\" : { \"type\" : \"env\" , \"key\" : \"HUMIO_INGEST_TOKEN\" } } }, \"configuration\" : { \"humio_url\" : \"https://myhumio.company.com\" }, \"controls\" : [ { \"name\" : \"humio-logger\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoshumio.control\" , \"secrets\" : [ \"humio\" ] } } ] } This will ensure the results of the experiment, steady-state, method, rollbacks and each activity are sent to Humio. The experiment itself will also be send initially.","title":"Control"},{"location":"drivers/humio/#contribute","text":"If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. The Chaos Toolkit projects require all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR.","title":"Contribute"},{"location":"drivers/humio/#develop","text":"If you wish to develop on this project, make sure to install the development dependencies. But first, create a virtual environment and then install those dependencies. $ pip install -r requirements-dev.txt -r requirements.txt Then, point your environment to this directory: $ pip install -e . Now, you can edit the files and they will be automatically be seen by your environment, even when running from the chaos command locally.","title":"Develop"},{"location":"drivers/humio/#test","text":"To run the tests for the project execute the following: $ pytest","title":"Test"},{"location":"drivers/humio/#exported-controls","text":"This package exports controls covering the following phases of the execution of an experiment: Level Before After Experiment True True Steady-state Hypothesis False True Method False True Rollback False True Activities False True To use this control module, please add the following section to your experiment: { \"name\" : \"chaoshumio\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoshumio.control\" } } name : chaoshumio provider : module : chaoshumio.control type : python This block may also be enabled at any other level (steady-state hypothesis or activity) to focus only on that level. When enabled at the experiment level, by default, all sub-levels are also applied unless you set the automatic properties to false .","title":"Exported Controls"},{"location":"drivers/humio/#exported-activities","text":"","title":"Exported Activities"},{"location":"drivers/humio/#notification_1","text":"","title":"notification"},{"location":"drivers/humio/#notify","text":"Type Module chaoshumio.notification Name notify Return None Send a log message to the Humio ingest endpoint. The settings must contain: \"token\" : a slack API token \"humio_url\" : the Humio endpoint to send the event to If token is missing, no notification is sent. If humio_url is not specified then the default, https://cloud.humio.com , will be used. Signature: def notify ( settings : Dict [ str , Any ], event : Dict [ str , Any ]): pass Arguments: Name Type Default Required settings mapping Yes event mapping Yes Usage: { \"name\" : \"notify\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoshumio.notification\" , \"func\" : \"notify\" , \"arguments\" : { \"settings\" : {}, \"event\" : {} } } } name : notify provider : arguments : event : {} settings : {} func : notify module : chaoshumio.notification type : python type : ''","title":"notify"},{"location":"drivers/humio/#probes","text":"","title":"probes"},{"location":"drivers/humio/#search_query","text":"Type probe Module chaoshumio.probes Name search_query Return Any Perform a search query against the Humio API and returns its result as-is. Set result_as_text to true to get the result as a raw string, otherwise the probe returns a JSON payload. Make sure to set the Humio token as part of the experiment secrets and the repository name as part of its configuration section using the humio_repository key. See https://docs.humio.com/api/using-the-search-api-with-humio/#query Signature: def search_query ( qs : str , start : Union [ int , str ] = '24hours' , end : Union [ int , str ] = 'now' , tz_offset : int = 0 , params : Union [ str , Dict [ str , str ]] = None , result_as_text : bool = False , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Any : pass Arguments: Name Type Default Required qs string Yes start object \u201c24hours\u201d No end object \u201cnow\u201d No tz_offset integer 0 No params object null No result_as_text boolean false No Usage: { \"name\" : \"search-query\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoshumio.probes\" , \"func\" : \"search_query\" , \"arguments\" : { \"qs\" : \"\" } } } name : search-query provider : arguments : qs : '' func : search_query module : chaoshumio.probes type : python type : probe","title":"search_query"},{"location":"drivers/humio/#tolerances","text":"","title":"tolerances"},{"location":"drivers/humio/#field_value_above","text":"Type tolerance Module chaoshumio.tolerances Name field_value_above Return boolean Validate value at the given field to be above the given lower limit. Signature: def field_value_above ( value : Any = None , field : str = None , lower : float = None ) -> bool : pass Arguments: Name Type Default Required value object null No field string null No lower number null No Tolerances declare the value argument which is automatically injected by Chaos Toolkit as the output of the probe they are evaluating. Usage: { \"steady-state-hypothesis\" : { \"title\" : \"...\" , \"probes\" : [ { \"type\" : \"probe\" , \"tolerance\" : { \"name\" : \"field-value-above\" , \"type\" : \"tolerance\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoshumio.tolerances\" , \"func\" : \"field_value_above\" } }, \"...\" : \"...\" } ] } } steady-state-hypothesis : probes : - '...' : '...' tolerance : name : field-value-above provider : func : field_value_above module : chaoshumio.tolerances type : python type : tolerance type : probe title : '...'","title":"field_value_above"},{"location":"drivers/humio/#field_value_between","text":"Type tolerance Module chaoshumio.tolerances Name field_value_between Return boolean Validate value at the given field to be between the lower/upper boundaries. Signature: def field_value_between ( value : Any = None , field : str = None , lower : float = None , upper : float = None ) -> bool : pass Arguments: Name Type Default Required value object null No field string null No lower number null No upper number null No Tolerances declare the value argument which is automatically injected by Chaos Toolkit as the output of the probe they are evaluating. Usage: { \"steady-state-hypothesis\" : { \"title\" : \"...\" , \"probes\" : [ { \"type\" : \"probe\" , \"tolerance\" : { \"name\" : \"field-value-between\" , \"type\" : \"tolerance\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoshumio.tolerances\" , \"func\" : \"field_value_between\" } }, \"...\" : \"...\" } ] } } steady-state-hypothesis : probes : - '...' : '...' tolerance : name : field-value-between provider : func : field_value_between module : chaoshumio.tolerances type : python type : tolerance type : probe title : '...'","title":"field_value_between"},{"location":"drivers/humio/#field_value_under","text":"Type tolerance Module chaoshumio.tolerances Name field_value_under Return boolean Validate value at the given field to be under the given upper limit. Signature: def field_value_under ( value : Any = None , field : str = None , upper : float = None ) -> bool : pass Arguments: Name Type Default Required value object null No field string null No upper number null No Tolerances declare the value argument which is automatically injected by Chaos Toolkit as the output of the probe they are evaluating. Usage: { \"steady-state-hypothesis\" : { \"title\" : \"...\" , \"probes\" : [ { \"type\" : \"probe\" , \"tolerance\" : { \"name\" : \"field-value-under\" , \"type\" : \"tolerance\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoshumio.tolerances\" , \"func\" : \"field_value_under\" } }, \"...\" : \"...\" } ] } } steady-state-hypothesis : probes : - '...' : '...' tolerance : name : field-value-under provider : func : field_value_under module : chaoshumio.tolerances type : python type : tolerance type : probe title : '...'","title":"field_value_under"},{"location":"drivers/istio/","text":"Extension chaosistio \u00b6 Version 0.2.0 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-istio This project is a collection of actions and probes , gathered as an extension to the Chaos Toolkit . Install \u00b6 This package requires Python 3.6+ To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install -U chaostoolkit-istio Usage \u00b6 Below is an example of using this extension to inject a delay of 5 seconds to a specific user. Note this example can be applied against the bookinfo Istio sample application . To run it, simple set the KUBERNETES_CONTEXT environment variable to the target cluster and ensure your local kubeconfig is properly populated for that context. Set also the PRODUCT_PAGE_SERVICE_BASE_URL to the address of the Istio gateway. For instance: $ export PRODUCT_PAGE_SERVICE_BASE_URL=$(kubectl get po -l istio=ingressgateway -n istio-system -o 'jsonpath={.items[0].status.hostIP}'):$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.spec.ports[?(@.name==\"http2\")].nodePort}') { \"title\" : \"Network latency does not impact our users\" , \"description\" : \"Using Istio fault injection capability, let's explore how latency impacts a single user\" , \"configuration\" : { \"product_page_url\" : { \"type\" : \"env\" , \"key\" : \"PRODUCT_PAGE_SERVICE_BASE_URL\" } }, \"secrets\" : { \"istio\" : { \"KUBERNETES_CONTEXT\" : { \"type\" : \"env\" , \"key\" : \"KUBERNETES_CONTEXT\" } } }, \"steady-state-hypothesis\" : { \"title\" : \"Our service should respond under 1 second\" , \"probes\" : [ { \"type\" : \"probe\" , \"name\" : \"sign-in-as-jason\" , \"tolerance\" : 0 , \"provider\" : { \"type\" : \"process\" , \"path\" : \"curl\" , \"arguments\" : \"-v -X POST -d 'username=jason&passwd=' -c /tmp/cookie.txt --silent ${product_page_url}/login\" } }, { \"type\" : \"probe\" , \"name\" : \"fetch-productpage-for-jason-in-due-time\" , \"tolerance\" : 0 , \"provider\" : { \"type\" : \"process\" , \"path\" : \"curl\" , \"arguments\" : \"-v --connect-timeout 1 --max-time 1 -b /tmp/cookie.txt --silent ${product_page_url}/productpage\" } } ] }, \"method\" : [ { \"type\" : \"action\" , \"name\" : \"inject-fault-for-jason-only\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosistio.fault.actions\" , \"func\" : \"add_delay_fault\" , \"secrets\" : [ \"istio\" ], \"arguments\" : { \"virtual_service_name\" : \"reviews\" , \"fixed_delay\" : \"5s\" , \"percentage\" : { \"value\" : 100.0 }, \"routes\" : [ { \"destination\" : { \"host\" : \"reviews\" , \"subset\" : \"v2\" } } ] } }, \"pauses\" : { \"after\" : 2 } } ], \"rollbacks\" : [ { \"type\" : \"action\" , \"name\" : \"remove-fault-for-jason-only\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosistio.fault.actions\" , \"func\" : \"remove_delay_fault\" , \"secrets\" : [ \"istio\" ], \"arguments\" : { \"virtual_service_name\" : \"reviews\" , \"routes\" : [ { \"destination\" : { \"host\" : \"reviews\" , \"subset\" : \"v2\" } } ] } } } ] } That\u2019s it! Please explore the code to see existing probes and actions. Configuration \u00b6 This extension needs you specify how to connect to the Kubernetes cluster. This can be done by setting the KUBERNETES_CONTEXT in the secrets payload. Contribute \u00b6 If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. The Chaos Toolkit projects require all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR. Develop \u00b6 If you wish to develop on this project, make sure to install the development dependencies. But first, create a virtual environment and then install those dependencies. $ pip install -r requirements-dev.txt -r requirements.txt Then, point your environment to this directory: $ python setup.py develop Now, you can edit the files and they will be automatically be seen by your environment, even when running from the chaos command locally. Test \u00b6 To run the tests for the project execute the following: $ pytest Exported Activities \u00b6 fault \u00b6 add_abort_fault \u00b6 Type action Module chaosistio.fault.actions Name add_abort_fault Return mapping Abort requests early by the virtual service identified by name See https://istio.io/docs/reference/config/istio.networking.v1alpha3/#HTTPFaultInjection-Abort Signature: def add_abort_fault ( virtual_service_name : str , http_status : int , routes : List [ Dict [ str , str ]], percentage : float = None , ns : str = 'default' , version : str = 'networking.istio.io/v1alpha3' , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required virtual_service_name string Yes http_status integer Yes routes list Yes percentage number null No ns string \u201cdefault\u201d No version string \u201cnetworking.istio.io/v1alpha3\u201d No Usage: { \"name\" : \"add-abort-fault\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosistio.fault.actions\" , \"func\" : \"add_abort_fault\" , \"arguments\" : { \"virtual_service_name\" : \"\" , \"http_status\" : 0 , \"routes\" : [] } } } name : add-abort-fault provider : arguments : http_status : 0 routes : [] virtual_service_name : '' func : add_abort_fault module : chaosistio.fault.actions type : python type : action add_delay_fault \u00b6 Type action Module chaosistio.fault.actions Name add_delay_fault Return mapping Add delay to the virtual service identified by name See https://istio.io/docs/reference/config/istio.networking.v1alpha3/#HTTPFaultInjection-Delay Signature: def add_delay_fault ( virtual_service_name : str , fixed_delay : str , routes : List [ Dict [ str , str ]], percentage : float = None , ns : str = 'default' , version : str = 'networking.istio.io/v1alpha3' , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required virtual_service_name string Yes fixed_delay string Yes routes list Yes percentage number null No ns string \u201cdefault\u201d No version string \u201cnetworking.istio.io/v1alpha3\u201d No Usage: { \"name\" : \"add-delay-fault\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosistio.fault.actions\" , \"func\" : \"add_delay_fault\" , \"arguments\" : { \"virtual_service_name\" : \"\" , \"fixed_delay\" : \"\" , \"routes\" : [] } } } name : add-delay-fault provider : arguments : fixed_delay : '' routes : [] virtual_service_name : '' func : add_delay_fault module : chaosistio.fault.actions type : python type : action get_virtual_service \u00b6 Type probe Module chaosistio.fault.probes Name get_virtual_service Return mapping Get a virtual service identified by name See https://istio.io/docs/reference/config/istio.networking.v1alpha3/#VirtualService Signature: def get_virtual_service ( virtual_service_name : str , ns : str = 'default' , version : str = 'networking.istio.io/v1alpha3' , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required virtual_service_name string Yes ns string \u201cdefault\u201d No version string \u201cnetworking.istio.io/v1alpha3\u201d No Usage: { \"name\" : \"get-virtual-service\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosistio.fault.probes\" , \"func\" : \"get_virtual_service\" , \"arguments\" : { \"virtual_service_name\" : \"\" } } } name : get-virtual-service provider : arguments : virtual_service_name : '' func : get_virtual_service module : chaosistio.fault.probes type : python type : probe remove_abort_fault \u00b6 Type action Module chaosistio.fault.actions Name remove_abort_fault Return mapping Remove abort request faults from the virtual service identified by name See https://istio.io/docs/reference/config/istio.networking.v1alpha3/#HTTPFaultInjection-Abort Signature: def remove_abort_fault ( virtual_service_name : str , routes : List [ Dict [ str , str ]], ns : str = 'default' , version : str = 'networking.istio.io/v1alpha3' , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required virtual_service_name string Yes routes list Yes ns string \u201cdefault\u201d No version string \u201cnetworking.istio.io/v1alpha3\u201d No Usage: { \"name\" : \"remove-abort-fault\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosistio.fault.actions\" , \"func\" : \"remove_abort_fault\" , \"arguments\" : { \"virtual_service_name\" : \"\" , \"routes\" : [] } } } name : remove-abort-fault provider : arguments : routes : [] virtual_service_name : '' func : remove_abort_fault module : chaosistio.fault.actions type : python type : action remove_delay_fault \u00b6 Type action Module chaosistio.fault.actions Name remove_delay_fault Return mapping Remove delay from the virtual service identified by name See https://istio.io/docs/reference/config/istio.networking.v1alpha3/#HTTPFaultInjection-Delay Signature: def remove_delay_fault ( virtual_service_name : str , routes : List [ Dict [ str , str ]], ns : str = 'default' , version : str = 'networking.istio.io/v1alpha3' , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required virtual_service_name string Yes routes list Yes ns string \u201cdefault\u201d No version string \u201cnetworking.istio.io/v1alpha3\u201d No Usage: { \"name\" : \"remove-delay-fault\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosistio.fault.actions\" , \"func\" : \"remove_delay_fault\" , \"arguments\" : { \"virtual_service_name\" : \"\" , \"routes\" : [] } } } name : remove-delay-fault provider : arguments : routes : [] virtual_service_name : '' func : remove_delay_fault module : chaosistio.fault.actions type : python type : action set_fault \u00b6 Type action Module chaosistio.fault.actions Name set_fault Return mapping Setfault injection on the virtual service identified by name The fault argument must be the object passed as the spec property of a virtual service resource. If a fault already exists, it is updated with the new specification. See https://istio.io/docs/reference/config/istio.networking.v1alpha3/#HTTPFaultInjection Signature: def set_fault ( virtual_service_name : str , routes : List [ Dict [ str , str ]], fault : Dict [ str , Any ], ns : str = 'default' , version : str = 'networking.istio.io/v1alpha3' , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required virtual_service_name string Yes routes list Yes fault mapping Yes ns string \u201cdefault\u201d No version string \u201cnetworking.istio.io/v1alpha3\u201d No Usage: { \"name\" : \"set-fault\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosistio.fault.actions\" , \"func\" : \"set_fault\" , \"arguments\" : { \"virtual_service_name\" : \"\" , \"routes\" : [], \"fault\" : {} } } } name : set-fault provider : arguments : fault : {} routes : [] virtual_service_name : '' func : set_fault module : chaosistio.fault.actions type : python type : action unset_fault \u00b6 Type action Module chaosistio.fault.actions Name unset_fault Return mapping Unset fault injection from the virtual service identified by name The fault argument must be the object passed as the spec property of a virtual service resource. See https://istio.io/docs/reference/config/istio.networking.v1alpha3/#HTTPFaultInjection Signature: def unset_fault ( virtual_service_name : str , routes : List [ Dict [ str , str ]], ns : str = 'default' , version : str = 'networking.istio.io/v1alpha3' , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required virtual_service_name string Yes routes list Yes ns string \u201cdefault\u201d No version string \u201cnetworking.istio.io/v1alpha3\u201d No Usage: { \"name\" : \"unset-fault\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosistio.fault.actions\" , \"func\" : \"unset_fault\" , \"arguments\" : { \"virtual_service_name\" : \"\" , \"routes\" : [] } } } name : unset-fault provider : arguments : routes : [] virtual_service_name : '' func : unset_fault module : chaosistio.fault.actions type : python type : action","title":"Istio"},{"location":"drivers/istio/#extension-chaosistio","text":"Version 0.2.0 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-istio This project is a collection of actions and probes , gathered as an extension to the Chaos Toolkit .","title":"Extension chaosistio"},{"location":"drivers/istio/#install","text":"This package requires Python 3.6+ To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install -U chaostoolkit-istio","title":"Install"},{"location":"drivers/istio/#usage","text":"Below is an example of using this extension to inject a delay of 5 seconds to a specific user. Note this example can be applied against the bookinfo Istio sample application . To run it, simple set the KUBERNETES_CONTEXT environment variable to the target cluster and ensure your local kubeconfig is properly populated for that context. Set also the PRODUCT_PAGE_SERVICE_BASE_URL to the address of the Istio gateway. For instance: $ export PRODUCT_PAGE_SERVICE_BASE_URL=$(kubectl get po -l istio=ingressgateway -n istio-system -o 'jsonpath={.items[0].status.hostIP}'):$(kubectl -n istio-system get service istio-ingressgateway -o jsonpath='{.spec.ports[?(@.name==\"http2\")].nodePort}') { \"title\" : \"Network latency does not impact our users\" , \"description\" : \"Using Istio fault injection capability, let's explore how latency impacts a single user\" , \"configuration\" : { \"product_page_url\" : { \"type\" : \"env\" , \"key\" : \"PRODUCT_PAGE_SERVICE_BASE_URL\" } }, \"secrets\" : { \"istio\" : { \"KUBERNETES_CONTEXT\" : { \"type\" : \"env\" , \"key\" : \"KUBERNETES_CONTEXT\" } } }, \"steady-state-hypothesis\" : { \"title\" : \"Our service should respond under 1 second\" , \"probes\" : [ { \"type\" : \"probe\" , \"name\" : \"sign-in-as-jason\" , \"tolerance\" : 0 , \"provider\" : { \"type\" : \"process\" , \"path\" : \"curl\" , \"arguments\" : \"-v -X POST -d 'username=jason&passwd=' -c /tmp/cookie.txt --silent ${product_page_url}/login\" } }, { \"type\" : \"probe\" , \"name\" : \"fetch-productpage-for-jason-in-due-time\" , \"tolerance\" : 0 , \"provider\" : { \"type\" : \"process\" , \"path\" : \"curl\" , \"arguments\" : \"-v --connect-timeout 1 --max-time 1 -b /tmp/cookie.txt --silent ${product_page_url}/productpage\" } } ] }, \"method\" : [ { \"type\" : \"action\" , \"name\" : \"inject-fault-for-jason-only\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosistio.fault.actions\" , \"func\" : \"add_delay_fault\" , \"secrets\" : [ \"istio\" ], \"arguments\" : { \"virtual_service_name\" : \"reviews\" , \"fixed_delay\" : \"5s\" , \"percentage\" : { \"value\" : 100.0 }, \"routes\" : [ { \"destination\" : { \"host\" : \"reviews\" , \"subset\" : \"v2\" } } ] } }, \"pauses\" : { \"after\" : 2 } } ], \"rollbacks\" : [ { \"type\" : \"action\" , \"name\" : \"remove-fault-for-jason-only\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosistio.fault.actions\" , \"func\" : \"remove_delay_fault\" , \"secrets\" : [ \"istio\" ], \"arguments\" : { \"virtual_service_name\" : \"reviews\" , \"routes\" : [ { \"destination\" : { \"host\" : \"reviews\" , \"subset\" : \"v2\" } } ] } } } ] } That\u2019s it! Please explore the code to see existing probes and actions.","title":"Usage"},{"location":"drivers/istio/#configuration","text":"This extension needs you specify how to connect to the Kubernetes cluster. This can be done by setting the KUBERNETES_CONTEXT in the secrets payload.","title":"Configuration"},{"location":"drivers/istio/#contribute","text":"If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. The Chaos Toolkit projects require all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR.","title":"Contribute"},{"location":"drivers/istio/#develop","text":"If you wish to develop on this project, make sure to install the development dependencies. But first, create a virtual environment and then install those dependencies. $ pip install -r requirements-dev.txt -r requirements.txt Then, point your environment to this directory: $ python setup.py develop Now, you can edit the files and they will be automatically be seen by your environment, even when running from the chaos command locally.","title":"Develop"},{"location":"drivers/istio/#test","text":"To run the tests for the project execute the following: $ pytest","title":"Test"},{"location":"drivers/istio/#exported-activities","text":"","title":"Exported Activities"},{"location":"drivers/istio/#fault","text":"","title":"fault"},{"location":"drivers/istio/#add_abort_fault","text":"Type action Module chaosistio.fault.actions Name add_abort_fault Return mapping Abort requests early by the virtual service identified by name See https://istio.io/docs/reference/config/istio.networking.v1alpha3/#HTTPFaultInjection-Abort Signature: def add_abort_fault ( virtual_service_name : str , http_status : int , routes : List [ Dict [ str , str ]], percentage : float = None , ns : str = 'default' , version : str = 'networking.istio.io/v1alpha3' , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required virtual_service_name string Yes http_status integer Yes routes list Yes percentage number null No ns string \u201cdefault\u201d No version string \u201cnetworking.istio.io/v1alpha3\u201d No Usage: { \"name\" : \"add-abort-fault\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosistio.fault.actions\" , \"func\" : \"add_abort_fault\" , \"arguments\" : { \"virtual_service_name\" : \"\" , \"http_status\" : 0 , \"routes\" : [] } } } name : add-abort-fault provider : arguments : http_status : 0 routes : [] virtual_service_name : '' func : add_abort_fault module : chaosistio.fault.actions type : python type : action","title":"add_abort_fault"},{"location":"drivers/istio/#add_delay_fault","text":"Type action Module chaosistio.fault.actions Name add_delay_fault Return mapping Add delay to the virtual service identified by name See https://istio.io/docs/reference/config/istio.networking.v1alpha3/#HTTPFaultInjection-Delay Signature: def add_delay_fault ( virtual_service_name : str , fixed_delay : str , routes : List [ Dict [ str , str ]], percentage : float = None , ns : str = 'default' , version : str = 'networking.istio.io/v1alpha3' , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required virtual_service_name string Yes fixed_delay string Yes routes list Yes percentage number null No ns string \u201cdefault\u201d No version string \u201cnetworking.istio.io/v1alpha3\u201d No Usage: { \"name\" : \"add-delay-fault\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosistio.fault.actions\" , \"func\" : \"add_delay_fault\" , \"arguments\" : { \"virtual_service_name\" : \"\" , \"fixed_delay\" : \"\" , \"routes\" : [] } } } name : add-delay-fault provider : arguments : fixed_delay : '' routes : [] virtual_service_name : '' func : add_delay_fault module : chaosistio.fault.actions type : python type : action","title":"add_delay_fault"},{"location":"drivers/istio/#get_virtual_service","text":"Type probe Module chaosistio.fault.probes Name get_virtual_service Return mapping Get a virtual service identified by name See https://istio.io/docs/reference/config/istio.networking.v1alpha3/#VirtualService Signature: def get_virtual_service ( virtual_service_name : str , ns : str = 'default' , version : str = 'networking.istio.io/v1alpha3' , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required virtual_service_name string Yes ns string \u201cdefault\u201d No version string \u201cnetworking.istio.io/v1alpha3\u201d No Usage: { \"name\" : \"get-virtual-service\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosistio.fault.probes\" , \"func\" : \"get_virtual_service\" , \"arguments\" : { \"virtual_service_name\" : \"\" } } } name : get-virtual-service provider : arguments : virtual_service_name : '' func : get_virtual_service module : chaosistio.fault.probes type : python type : probe","title":"get_virtual_service"},{"location":"drivers/istio/#remove_abort_fault","text":"Type action Module chaosistio.fault.actions Name remove_abort_fault Return mapping Remove abort request faults from the virtual service identified by name See https://istio.io/docs/reference/config/istio.networking.v1alpha3/#HTTPFaultInjection-Abort Signature: def remove_abort_fault ( virtual_service_name : str , routes : List [ Dict [ str , str ]], ns : str = 'default' , version : str = 'networking.istio.io/v1alpha3' , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required virtual_service_name string Yes routes list Yes ns string \u201cdefault\u201d No version string \u201cnetworking.istio.io/v1alpha3\u201d No Usage: { \"name\" : \"remove-abort-fault\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosistio.fault.actions\" , \"func\" : \"remove_abort_fault\" , \"arguments\" : { \"virtual_service_name\" : \"\" , \"routes\" : [] } } } name : remove-abort-fault provider : arguments : routes : [] virtual_service_name : '' func : remove_abort_fault module : chaosistio.fault.actions type : python type : action","title":"remove_abort_fault"},{"location":"drivers/istio/#remove_delay_fault","text":"Type action Module chaosistio.fault.actions Name remove_delay_fault Return mapping Remove delay from the virtual service identified by name See https://istio.io/docs/reference/config/istio.networking.v1alpha3/#HTTPFaultInjection-Delay Signature: def remove_delay_fault ( virtual_service_name : str , routes : List [ Dict [ str , str ]], ns : str = 'default' , version : str = 'networking.istio.io/v1alpha3' , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required virtual_service_name string Yes routes list Yes ns string \u201cdefault\u201d No version string \u201cnetworking.istio.io/v1alpha3\u201d No Usage: { \"name\" : \"remove-delay-fault\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosistio.fault.actions\" , \"func\" : \"remove_delay_fault\" , \"arguments\" : { \"virtual_service_name\" : \"\" , \"routes\" : [] } } } name : remove-delay-fault provider : arguments : routes : [] virtual_service_name : '' func : remove_delay_fault module : chaosistio.fault.actions type : python type : action","title":"remove_delay_fault"},{"location":"drivers/istio/#set_fault","text":"Type action Module chaosistio.fault.actions Name set_fault Return mapping Setfault injection on the virtual service identified by name The fault argument must be the object passed as the spec property of a virtual service resource. If a fault already exists, it is updated with the new specification. See https://istio.io/docs/reference/config/istio.networking.v1alpha3/#HTTPFaultInjection Signature: def set_fault ( virtual_service_name : str , routes : List [ Dict [ str , str ]], fault : Dict [ str , Any ], ns : str = 'default' , version : str = 'networking.istio.io/v1alpha3' , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required virtual_service_name string Yes routes list Yes fault mapping Yes ns string \u201cdefault\u201d No version string \u201cnetworking.istio.io/v1alpha3\u201d No Usage: { \"name\" : \"set-fault\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosistio.fault.actions\" , \"func\" : \"set_fault\" , \"arguments\" : { \"virtual_service_name\" : \"\" , \"routes\" : [], \"fault\" : {} } } } name : set-fault provider : arguments : fault : {} routes : [] virtual_service_name : '' func : set_fault module : chaosistio.fault.actions type : python type : action","title":"set_fault"},{"location":"drivers/istio/#unset_fault","text":"Type action Module chaosistio.fault.actions Name unset_fault Return mapping Unset fault injection from the virtual service identified by name The fault argument must be the object passed as the spec property of a virtual service resource. See https://istio.io/docs/reference/config/istio.networking.v1alpha3/#HTTPFaultInjection Signature: def unset_fault ( virtual_service_name : str , routes : List [ Dict [ str , str ]], ns : str = 'default' , version : str = 'networking.istio.io/v1alpha3' , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required virtual_service_name string Yes routes list Yes ns string \u201cdefault\u201d No version string \u201cnetworking.istio.io/v1alpha3\u201d No Usage: { \"name\" : \"unset-fault\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosistio.fault.actions\" , \"func\" : \"unset_fault\" , \"arguments\" : { \"virtual_service_name\" : \"\" , \"routes\" : [] } } } name : unset-fault provider : arguments : routes : [] virtual_service_name : '' func : unset_fault module : chaosistio.fault.actions type : python type : action","title":"unset_fault"},{"location":"drivers/k6/","text":"Extension chaosk6 \u00b6 Version 0.3.0 Repository https://github.com/k6io/chaostoolkit-k6 This project is a collection of actions and probes , gathered as an extension to the Chaos Toolkit . Install \u00b6 This package requires Python 3.5+ To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install -U chaostoolkit-k6 Usage \u00b6 Please explore the code to see existing probes and actions. Configuration \u00b6 Contribute \u00b6 If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. The Chaos Toolkit projects require all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR. Develop \u00b6 If you wish to develop on this project, make sure to install the development dependencies. But first, create a virtual environment and then install those dependencies. $ pip install -r requirements-dev.txt -r requirements.txt Then, point your environment to this directory: $ pip install -e . Now, you can edit the files and they will be automatically be seen by your environment, even when running from the chaos command locally. Test \u00b6 To run the tests for the project execute the following: $ pytest Exported Activities \u00b6 actions \u00b6 run_script \u00b6 Type action Module chaosk6.actions Name run_script Return None Run an arbitrary k6 script with a configurable amount of VUs and duration. Depending on the specs of the attacking machine, possible VU amount may vary. For a non-customized 2019 Macbook Pro, it will cap around 250 \u00b1 50. \u2013 scriptPath : str Full path to the k6 test script vus : int Amount of virtual users to run the test with duration : str Duration, written as a string, ie: 1h2m3s etc Signature: def run_script ( scriptPath : str = None , vus : int = 1 , duration : str = '1s' ): pass Arguments: Name Type Default Required scriptPath string null No vus integer 1 No duration string \u201c1s\u201d No Usage: { \"name\" : \"run-script\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk6.actions\" , \"func\" : \"run_script\" } } name : run-script provider : func : run_script module : chaosk6.actions type : python type : action stress_endpoint \u00b6 Type action Module chaosk6.actions Name stress_endpoint Return None Stress a single endpoint with a configurable amount of VUs and duration. Depending on the specs of the attacking machine, possible VU amount may vary. For a non-customized 2019 Macbook Pro, it will cap around 250 \u00b1 50. \u2013 endpoint : str The URL to the endpoint you want to stress, including the scheme prefix. vus : int Amount of virtual users to run the test with duration : str Duration, written as a string, ie: 1h2m3s etc Signature: def stress_endpoint ( endpoint : str = None , vus : int = 1 , duration : str = '1s' ): pass Arguments: Name Type Default Required endpoint string null No vus integer 1 No duration string \u201c1s\u201d No Usage: { \"name\" : \"stress-endpoint\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk6.actions\" , \"func\" : \"stress_endpoint\" } } name : stress-endpoint provider : func : stress_endpoint module : chaosk6.actions type : python type : action probes \u00b6 http \u00b6 Type probe Module chaosk6.probes Name http Return boolean Probe an endpoint to make sure it responds to an http request with the expected HTTP status code. Depending on the endpoint and your payload, this action might be destructive. Use with caution. \u2013 endpoint : str The URL to the endpoint to probe method : str A valid http request method name, like GET, POST, PUT, DELETE, OPTIONS, or PATCH status : int The expected HTTP Response status code. vus : int The amount of concurrent virtual users accessing the endpoint duration : str How long to probe the endpoint. Expressed as a duration string, i.e \u201c20s\u201d, \u201c1m\u201d, \u201c1h\u201d etc. timeout : int Timeout duration for http requests. Defaults to 1 second Signature: def http ( endpoint : str , method : str = 'GET' , status : int = 200 , body : str = '' , headers : dict = {}, vus : int = 1 , duration : str = '' , debug : bool = False , timeout : int = 1 ) -> bool : pass Arguments: Name Type Default Required endpoint string Yes method string \u201cGET\u201d No status integer 200 No body string \u201d\u201c No headers mapping {} No vus integer 1 No duration string \u201d\u201c No debug boolean false No timeout integer 1 No Usage: { \"name\" : \"http\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk6.probes\" , \"func\" : \"http\" , \"arguments\" : { \"endpoint\" : \"\" } } } name : http provider : arguments : endpoint : '' func : http module : chaosk6.probes type : python type : probe","title":"k6"},{"location":"drivers/k6/#extension-chaosk6","text":"Version 0.3.0 Repository https://github.com/k6io/chaostoolkit-k6 This project is a collection of actions and probes , gathered as an extension to the Chaos Toolkit .","title":"Extension chaosk6"},{"location":"drivers/k6/#install","text":"This package requires Python 3.5+ To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install -U chaostoolkit-k6","title":"Install"},{"location":"drivers/k6/#usage","text":"Please explore the code to see existing probes and actions.","title":"Usage"},{"location":"drivers/k6/#configuration","text":"","title":"Configuration"},{"location":"drivers/k6/#contribute","text":"If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. The Chaos Toolkit projects require all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR.","title":"Contribute"},{"location":"drivers/k6/#develop","text":"If you wish to develop on this project, make sure to install the development dependencies. But first, create a virtual environment and then install those dependencies. $ pip install -r requirements-dev.txt -r requirements.txt Then, point your environment to this directory: $ pip install -e . Now, you can edit the files and they will be automatically be seen by your environment, even when running from the chaos command locally.","title":"Develop"},{"location":"drivers/k6/#test","text":"To run the tests for the project execute the following: $ pytest","title":"Test"},{"location":"drivers/k6/#exported-activities","text":"","title":"Exported Activities"},{"location":"drivers/k6/#actions","text":"","title":"actions"},{"location":"drivers/k6/#run_script","text":"Type action Module chaosk6.actions Name run_script Return None Run an arbitrary k6 script with a configurable amount of VUs and duration. Depending on the specs of the attacking machine, possible VU amount may vary. For a non-customized 2019 Macbook Pro, it will cap around 250 \u00b1 50. \u2013 scriptPath : str Full path to the k6 test script vus : int Amount of virtual users to run the test with duration : str Duration, written as a string, ie: 1h2m3s etc Signature: def run_script ( scriptPath : str = None , vus : int = 1 , duration : str = '1s' ): pass Arguments: Name Type Default Required scriptPath string null No vus integer 1 No duration string \u201c1s\u201d No Usage: { \"name\" : \"run-script\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk6.actions\" , \"func\" : \"run_script\" } } name : run-script provider : func : run_script module : chaosk6.actions type : python type : action","title":"run_script"},{"location":"drivers/k6/#stress_endpoint","text":"Type action Module chaosk6.actions Name stress_endpoint Return None Stress a single endpoint with a configurable amount of VUs and duration. Depending on the specs of the attacking machine, possible VU amount may vary. For a non-customized 2019 Macbook Pro, it will cap around 250 \u00b1 50. \u2013 endpoint : str The URL to the endpoint you want to stress, including the scheme prefix. vus : int Amount of virtual users to run the test with duration : str Duration, written as a string, ie: 1h2m3s etc Signature: def stress_endpoint ( endpoint : str = None , vus : int = 1 , duration : str = '1s' ): pass Arguments: Name Type Default Required endpoint string null No vus integer 1 No duration string \u201c1s\u201d No Usage: { \"name\" : \"stress-endpoint\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk6.actions\" , \"func\" : \"stress_endpoint\" } } name : stress-endpoint provider : func : stress_endpoint module : chaosk6.actions type : python type : action","title":"stress_endpoint"},{"location":"drivers/k6/#probes","text":"","title":"probes"},{"location":"drivers/k6/#http","text":"Type probe Module chaosk6.probes Name http Return boolean Probe an endpoint to make sure it responds to an http request with the expected HTTP status code. Depending on the endpoint and your payload, this action might be destructive. Use with caution. \u2013 endpoint : str The URL to the endpoint to probe method : str A valid http request method name, like GET, POST, PUT, DELETE, OPTIONS, or PATCH status : int The expected HTTP Response status code. vus : int The amount of concurrent virtual users accessing the endpoint duration : str How long to probe the endpoint. Expressed as a duration string, i.e \u201c20s\u201d, \u201c1m\u201d, \u201c1h\u201d etc. timeout : int Timeout duration for http requests. Defaults to 1 second Signature: def http ( endpoint : str , method : str = 'GET' , status : int = 200 , body : str = '' , headers : dict = {}, vus : int = 1 , duration : str = '' , debug : bool = False , timeout : int = 1 ) -> bool : pass Arguments: Name Type Default Required endpoint string Yes method string \u201cGET\u201d No status integer 200 No body string \u201d\u201c No headers mapping {} No vus integer 1 No duration string \u201d\u201c No debug boolean false No timeout integer 1 No Usage: { \"name\" : \"http\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk6.probes\" , \"func\" : \"http\" , \"arguments\" : { \"endpoint\" : \"\" } } } name : http provider : arguments : endpoint : '' func : http module : chaosk6.probes type : python type : probe","title":"http"},{"location":"drivers/kubernetes/","text":"Extension chaosk8s \u00b6 Version 0.25.1 Repository https://github.com/chaostoolkit/chaostoolkit-kubernetes This project contains activities, such as probes and actions, you can call from your experiment through the Chaos Toolkit to perform Chaos Engineering against the Kubernetes API: killing a pod, removing a statefulset or node\u2026 Install \u00b6 To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install chaostoolkit-kubernetes Usage \u00b6 To use the probes and actions from this package, add the following to your experiment file: { \"title\" : \"Do we remain available in face of pod going down?\" , \"description\" : \"We expect Kubernetes to handle the situation gracefully when a pod goes down\" , \"tags\" : [ \"kubernetes\" ], \"steady-state-hypothesis\" : { \"title\" : \"Verifying service remains healthy\" , \"probes\" : [ { \"name\" : \"all-our-microservices-should-be-healthy\" , \"type\" : \"probe\" , \"tolerance\" : true , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.probes\" , \"func\" : \"microservice_available_and_healthy\" , \"arguments\" : { \"name\" : \"myapp\" } } } ] }, \"method\" : [ { \"type\" : \"action\" , \"name\" : \"terminate-db-pod\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.pod.actions\" , \"func\" : \"terminate_pods\" , \"arguments\" : { \"label_selector\" : \"app=my-app\" , \"name_pattern\" : \"my-app-[0-9]$\" , \"rand\" : true } }, \"pauses\" : { \"after\" : 5 } } ] } That\u2019s it! Notice how the action gives you the way to kill one pod randomly. Please explore the documentation to see existing probes and actions. Configuration \u00b6 Use ~/.kube/config \u00b6 If you have a valid entry in your ~/.kube/config file for the cluster you want to target, then there is nothing to be done. You may specify KUBECONFIG to specify a different location. $ export KUBECONFIG=/tmp/my-config Specify the Kubernetes context \u00b6 Quite often, your Kubernetes configuration contains several entries and you need to define the one to use as a default context when not it isn\u2019t explicitely provided. You may of course change your default using kubectl config use-context KUBERNETES_CONTEXT but you can also be explicit in your experiment as follows: { \"title\" : \"Do we remain available in face of pod going down?\" , \"description\" : \"We expect Kubernetes to handle the situation gracefully when a pod goes down\" , \"tags\" : [ \"kubernetes\" ], \"secrets\" : { \"k8s\" : { \"KUBERNETES_CONTEXT\" : \"...\" } }, \"steady-state-hypothesis\" : { \"title\" : \"Verifying service remains healthy\" , \"probes\" : [ { \"name\" : \"all-our-microservices-should-be-healthy\" , \"type\" : \"probe\" , \"tolerance\" : true , \"secrets\" : [ \"k8s\" ], \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.probes\" , \"func\" : \"microservice_available_and_healthy\" , \"arguments\" : { \"name\" : \"myapp\" } } } ] }, \"method\" : [ { \"type\" : \"action\" , \"name\" : \"terminate-db-pod\" , \"secrets\" : [ \"k8s\" ], \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.pod.actions\" , \"func\" : \"terminate_pods\" , \"arguments\" : { \"label_selector\" : \"app=my-app\" , \"name_pattern\" : \"my-app-[0-9]$\" , \"rand\" : true } }, \"pauses\" : { \"after\" : 5 } } ] } You need to specify the KUBERNETES_CONTEXT secret key to the name of the context you want the experiment to use. Make sure to also inform the actions and probes about the secret entries they should be passed \"secrets\": [\"k8s\"] . Use a Pod\u2019s service account \u00b6 When running from a pod (not your local machine or a CI for instance), the ./.kube/config file does not exist. Instead, the credentials can be found at /var/run/secrets/kubernetes.io/serviceaccount/token . To let the extension know about this, simply set CHAOSTOOLKIT_IN_POD from the environment variable of the pod specification: env : - name : CHAOSTOOLKIT_IN_POD value : \"true\" Pass all credentials in the experiment \u00b6 Finally, you may pass explicitely all required credentials information to the experiment as follows: Using an API key \u00b6 { \"secrets\" : { \"kubernetes\" : { \"KUBERNETES_HOST\" : \"http://somehost\" , \"KUBERNETES_API_KEY\" : { \"type\" : \"env\" , \"key\" : \"SOME_ENV_VAR\" } } } } Using a username/password \u00b6 { \"secrets\" : { \"kubernetes\" : { \"KUBERNETES_HOST\" : \"http://somehost\" , \"KUBERNETES_USERNAME\" : { \"type\" : \"env\" , \"key\" : \"SOME_ENV_VAR\" }, \"KUBERNETES_PASSWORD\" : { \"type\" : \"env\" , \"key\" : \"SOME_ENV_VAR\" } } } } Using a TLS key/certificate \u00b6 { \"secrets\" : { \"kubernetes\" : { \"KUBERNETES_HOST\" : \"http://somehost\" , \"KUBERNETES_CERT_FILE\" : { \"type\" : \"env\" , \"key\" : \"SOME_ENV_VAR\" }, \"KUBERNETES_KEY_FILE\" : { \"type\" : \"env\" , \"key\" : \"SOME_ENV_VAR\" } } } } Managed Kubernetes Clusters Authentication \u00b6 On some managed Kubernetes clusters, you also need to authenticate against the platform itself because the Kubernetes authentication is delegated to it. Google Cloud Platform \u00b6 In addition to your Kubernetes credentials (via the ~/.kube/config file), you need to authenticate against the Google Cloud Platform itself. Usually this is done via : $ gcloud auth login But can also be achieved by defining the GOOGLE_APPLICATION_CREDENTIALS environment variable. Contribute \u00b6 If you wish to contribute more functions to this package, you are more than welcome to do so. Please fork this project, make your changes following the usual PEP 8 code style, add appropriate tests and submit a PR for review. The Chaos Toolkit projects require all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR. Develop \u00b6 If you wish to develop on this project, make sure to install the development dependencies. But first, create a virtual environment and then install those dependencies. $ pip install -r requirements-dev.txt -r requirements.txt Then, point your environment to this directory: $ pip install -e . Now, you can edit the files and they will be automatically be seen by your environment, even when running from the chaos command locally. Test \u00b6 To run the tests for the project execute the following: $ pytest Exported Activities \u00b6 actions \u00b6 kill_microservice \u00b6 Type action Module chaosk8s.actions Name kill_microservice Return None !!!DEPRECATED!!! Signature: def kill_microservice ( name : str , ns : str = 'default' , label_selector : str = 'name in ( {name} )' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string \u201cname in ({name})\u201d No Usage: { \"name\" : \"kill-microservice\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.actions\" , \"func\" : \"kill_microservice\" , \"arguments\" : { \"name\" : \"\" } } } name : kill-microservice provider : arguments : name : '' func : kill_microservice module : chaosk8s.actions type : python type : action remove_service_endpoint \u00b6 Type action Module chaosk8s.actions Name remove_service_endpoint Return None !!!DEPRECATED!!! Signature: def remove_service_endpoint ( name : str , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No Usage: { \"name\" : \"remove-service-endpoint\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.actions\" , \"func\" : \"remove_service_endpoint\" , \"arguments\" : { \"name\" : \"\" } } } name : remove-service-endpoint provider : arguments : name : '' func : remove_service_endpoint module : chaosk8s.actions type : python type : action scale_microservice \u00b6 Type action Module chaosk8s.actions Name scale_microservice Return None !!!DEPRECATED!!! Signature: def scale_microservice ( name : str , replicas : int , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes replicas integer Yes ns string \u201cdefault\u201d No Usage: { \"name\" : \"scale-microservice\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.actions\" , \"func\" : \"scale_microservice\" , \"arguments\" : { \"name\" : \"\" , \"replicas\" : 0 } } } name : scale-microservice provider : arguments : name : '' replicas : 0 func : scale_microservice module : chaosk8s.actions type : python type : action start_microservice \u00b6 Type action Module chaosk8s.actions Name start_microservice Return None !!!DEPRECATED!!! Signature: def start_microservice ( spec_path : str , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required spec_path string Yes ns string \u201cdefault\u201d No Usage: { \"name\" : \"start-microservice\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.actions\" , \"func\" : \"start_microservice\" , \"arguments\" : { \"spec_path\" : \"\" } } } name : start-microservice provider : arguments : spec_path : '' func : start_microservice module : chaosk8s.actions type : python type : action crd \u00b6 create_cluster_custom_object \u00b6 Type action Module chaosk8s.crd.actions Name create_cluster_custom_object Return mapping Delete a custom object in the given namespace. Read more about custom resources here: https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/ Signature: def create_cluster_custom_object ( group : str , version : str , plural : str , resource : Dict [ str , Any ] = None , resource_as_yaml_file : str = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required group string Yes version string Yes plural string Yes resource mapping null No resource_as_yaml_file string null No Usage: { \"name\" : \"create-cluster-custom-object\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.crd.actions\" , \"func\" : \"create_cluster_custom_object\" , \"arguments\" : { \"group\" : \"\" , \"version\" : \"\" , \"plural\" : \"\" } } } name : create-cluster-custom-object provider : arguments : group : '' plural : '' version : '' func : create_cluster_custom_object module : chaosk8s.crd.actions type : python type : action create_custom_object \u00b6 Type action Module chaosk8s.crd.actions Name create_custom_object Return mapping Create a custom object in the given namespace. Its custom resource definition must already exists or this will fail with a 404. Read more about custom resources here: https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/ Signature: def create_custom_object ( group : str , version : str , plural : str , ns : str = 'default' , resource : Dict [ str , Any ] = None , resource_as_yaml_file : str = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required group string Yes version string Yes plural string Yes ns string \u201cdefault\u201d No resource mapping null No resource_as_yaml_file string null No Usage: { \"name\" : \"create-custom-object\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.crd.actions\" , \"func\" : \"create_custom_object\" , \"arguments\" : { \"group\" : \"\" , \"version\" : \"\" , \"plural\" : \"\" } } } name : create-custom-object provider : arguments : group : '' plural : '' version : '' func : create_custom_object module : chaosk8s.crd.actions type : python type : action delete_cluster_custom_object \u00b6 Type action Module chaosk8s.crd.actions Name delete_cluster_custom_object Return mapping Delete a custom object cluster wide. Read more about custom resources here: https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/ Signature: def delete_cluster_custom_object ( group : str , version : str , plural : str , name : str , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required group string Yes version string Yes plural string Yes name string Yes Usage: { \"name\" : \"delete-cluster-custom-object\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.crd.actions\" , \"func\" : \"delete_cluster_custom_object\" , \"arguments\" : { \"group\" : \"\" , \"version\" : \"\" , \"plural\" : \"\" , \"name\" : \"\" } } } name : delete-cluster-custom-object provider : arguments : group : '' name : '' plural : '' version : '' func : delete_cluster_custom_object module : chaosk8s.crd.actions type : python type : action delete_custom_object \u00b6 Type action Module chaosk8s.crd.actions Name delete_custom_object Return mapping Create a custom object cluster wide. Its custom resource definition must already exists or this will fail with a 404. Read more about custom resources here: https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/ Signature: def delete_custom_object ( group : str , version : str , plural : str , name : str , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required group string Yes version string Yes plural string Yes name string Yes ns string \u201cdefault\u201d No Usage: { \"name\" : \"delete-custom-object\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.crd.actions\" , \"func\" : \"delete_custom_object\" , \"arguments\" : { \"group\" : \"\" , \"version\" : \"\" , \"plural\" : \"\" , \"name\" : \"\" } } } name : delete-custom-object provider : arguments : group : '' name : '' plural : '' version : '' func : delete_custom_object module : chaosk8s.crd.actions type : python type : action get_cluster_custom_object \u00b6 Type probe Module chaosk8s.crd.probes Name get_cluster_custom_object Return mapping Get a custom object cluster-wide. Read more about custom resources here: https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/ Signature: def get_cluster_custom_object ( group : str , version : str , plural : str , name : str , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required group string Yes version string Yes plural string Yes name string Yes Usage: { \"name\" : \"get-cluster-custom-object\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.crd.probes\" , \"func\" : \"get_cluster_custom_object\" , \"arguments\" : { \"group\" : \"\" , \"version\" : \"\" , \"plural\" : \"\" , \"name\" : \"\" } } } name : get-cluster-custom-object provider : arguments : group : '' name : '' plural : '' version : '' func : get_cluster_custom_object module : chaosk8s.crd.probes type : python type : probe get_custom_object \u00b6 Type probe Module chaosk8s.crd.probes Name get_custom_object Return mapping Get a custom object in the given namespace. Read more about custom resources here: https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/ Signature: def get_custom_object ( group : str , version : str , plural : str , name : str , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required group string Yes version string Yes plural string Yes name string Yes ns string \u201cdefault\u201d No Usage: { \"name\" : \"get-custom-object\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.crd.probes\" , \"func\" : \"get_custom_object\" , \"arguments\" : { \"group\" : \"\" , \"version\" : \"\" , \"plural\" : \"\" , \"name\" : \"\" } } } name : get-custom-object provider : arguments : group : '' name : '' plural : '' version : '' func : get_custom_object module : chaosk8s.crd.probes type : python type : probe list_cluster_custom_objects \u00b6 Type probe Module chaosk8s.crd.probes Name list_cluster_custom_objects Return list List custom objects cluster-wide. Read more about custom resources here: https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/ Signature: def list_cluster_custom_objects ( group : str , version : str , plural : str , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required group string Yes version string Yes plural string Yes Usage: { \"name\" : \"list-cluster-custom-objects\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.crd.probes\" , \"func\" : \"list_cluster_custom_objects\" , \"arguments\" : { \"group\" : \"\" , \"version\" : \"\" , \"plural\" : \"\" } } } name : list-cluster-custom-objects provider : arguments : group : '' plural : '' version : '' func : list_cluster_custom_objects module : chaosk8s.crd.probes type : python type : probe list_custom_objects \u00b6 Type probe Module chaosk8s.crd.probes Name list_custom_objects Return list List custom objects in the given namespace. Read more about custom resources here: https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/ Signature: def list_custom_objects ( group : str , version : str , plural : str , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required group string Yes version string Yes plural string Yes ns string \u201cdefault\u201d No Usage: { \"name\" : \"list-custom-objects\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.crd.probes\" , \"func\" : \"list_custom_objects\" , \"arguments\" : { \"group\" : \"\" , \"version\" : \"\" , \"plural\" : \"\" } } } name : list-custom-objects provider : arguments : group : '' plural : '' version : '' func : list_custom_objects module : chaosk8s.crd.probes type : python type : probe patch_cluster_custom_object \u00b6 Type action Module chaosk8s.crd.actions Name patch_cluster_custom_object Return mapping Patch a custom object cluster-wide. The resource must be the updated version to apply. Force will re-acquire conflicting fields owned by others. Read more about custom resources here: https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/ Signature: def patch_cluster_custom_object ( group : str , version : str , plural : str , name : str , force : bool = False , resource : Dict [ str , Any ] = None , resource_as_yaml_file : str = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required group string Yes version string Yes plural string Yes name string Yes force boolean false No resource mapping null No resource_as_yaml_file string null No Usage: { \"name\" : \"patch-cluster-custom-object\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.crd.actions\" , \"func\" : \"patch_cluster_custom_object\" , \"arguments\" : { \"group\" : \"\" , \"version\" : \"\" , \"plural\" : \"\" , \"name\" : \"\" } } } name : patch-cluster-custom-object provider : arguments : group : '' name : '' plural : '' version : '' func : patch_cluster_custom_object module : chaosk8s.crd.actions type : python type : action patch_custom_object \u00b6 Type action Module chaosk8s.crd.actions Name patch_custom_object Return mapping Patch a custom object in the given namespace. The resource must be the updated version to apply. Force will re-acquire conflicting fields owned by others. Read more about custom resources here: https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/ Signature: def patch_custom_object ( group : str , version : str , plural : str , name : str , ns : str = 'default' , force : bool = False , resource : Dict [ str , Any ] = None , resource_as_yaml_file : str = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required group string Yes version string Yes plural string Yes name string Yes ns string \u201cdefault\u201d No force boolean false No resource mapping null No resource_as_yaml_file string null No Usage: { \"name\" : \"patch-custom-object\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.crd.actions\" , \"func\" : \"patch_custom_object\" , \"arguments\" : { \"group\" : \"\" , \"version\" : \"\" , \"plural\" : \"\" , \"name\" : \"\" } } } name : patch-custom-object provider : arguments : group : '' name : '' plural : '' version : '' func : patch_custom_object module : chaosk8s.crd.actions type : python type : action replace_cluster_custom_object \u00b6 Type action Module chaosk8s.crd.actions Name replace_cluster_custom_object Return mapping Replace a custom object in the given namespace. The resource must be the new version to apply. Read more about custom resources here: https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/ Signature: def replace_cluster_custom_object ( group : str , version : str , plural : str , name : str , force : bool = False , resource : Dict [ str , Any ] = None , resource_as_yaml_file : str = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required group string Yes version string Yes plural string Yes name string Yes force boolean false No resource mapping null No resource_as_yaml_file string null No Usage: { \"name\" : \"replace-cluster-custom-object\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.crd.actions\" , \"func\" : \"replace_cluster_custom_object\" , \"arguments\" : { \"group\" : \"\" , \"version\" : \"\" , \"plural\" : \"\" , \"name\" : \"\" } } } name : replace-cluster-custom-object provider : arguments : group : '' name : '' plural : '' version : '' func : replace_cluster_custom_object module : chaosk8s.crd.actions type : python type : action replace_custom_object \u00b6 Type action Module chaosk8s.crd.actions Name replace_custom_object Return mapping Replace a custom object in the given namespace. The resource must be the new version to apply. Read more about custom resources here: https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/ Signature: def replace_custom_object ( group : str , version : str , plural : str , name : str , ns : str = 'default' , force : bool = False , resource : Dict [ str , Any ] = None , resource_as_yaml_file : str = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required group string Yes version string Yes plural string Yes name string Yes ns string \u201cdefault\u201d No force boolean false No resource mapping null No resource_as_yaml_file string null No Usage: { \"name\" : \"replace-custom-object\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.crd.actions\" , \"func\" : \"replace_custom_object\" , \"arguments\" : { \"group\" : \"\" , \"version\" : \"\" , \"plural\" : \"\" , \"name\" : \"\" } } } name : replace-custom-object provider : arguments : group : '' name : '' plural : '' version : '' func : replace_custom_object module : chaosk8s.crd.actions type : python type : action deployment \u00b6 create_deployment \u00b6 Type action Module chaosk8s.deployment.actions Name create_deployment Return None Create a deployment described by the deployment config, which must be the path to the JSON or YAML representation of the deployment. Signature: def create_deployment ( spec_path : str , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required spec_path string Yes ns string \u201cdefault\u201d No Usage: { \"name\" : \"create-deployment\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.deployment.actions\" , \"func\" : \"create_deployment\" , \"arguments\" : { \"spec_path\" : \"\" } } } name : create-deployment provider : arguments : spec_path : '' func : create_deployment module : chaosk8s.deployment.actions type : python type : action delete_deployment \u00b6 Type action Module chaosk8s.deployment.actions Name delete_deployment Return None Delete a deployment by name in the namespace ns . The deployment is deleted without a graceful period to trigger an abrupt termination. The selected resources are matched by the given label_selector . Signature: def delete_deployment ( name : str , ns : str = 'default' , label_selector : str = 'name in ( {name} )' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string \u201cname in ({name})\u201d No Usage: { \"name\" : \"delete-deployment\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.deployment.actions\" , \"func\" : \"delete_deployment\" , \"arguments\" : { \"name\" : \"\" } } } name : delete-deployment provider : arguments : name : '' func : delete_deployment module : chaosk8s.deployment.actions type : python type : action deployment_available_and_healthy \u00b6 Type probe Module chaosk8s.deployment.probes Name deployment_available_and_healthy Return Union[bool, NoneType] Lookup a deployment by name in the namespace ns . The selected resources are matched by the given label_selector . Raises :exc: chaoslib.exceptions.ActivityFailed when the state is not as expected. Signature: def deployment_available_and_healthy ( name : str , ns : str = 'default' , label_selector : str = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Union [ bool , NoneType ]: pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string null No Usage: { \"name\" : \"deployment-available-and-healthy\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.deployment.probes\" , \"func\" : \"deployment_available_and_healthy\" , \"arguments\" : { \"name\" : \"\" } } } name : deployment-available-and-healthy provider : arguments : name : '' func : deployment_available_and_healthy module : chaosk8s.deployment.probes type : python type : probe deployment_fully_available \u00b6 Type probe Module chaosk8s.deployment.probes Name deployment_fully_available Return Union[bool, NoneType] Wait until all the deployment expected replicas are available. Once this state is reached, return True . If the state is not reached after timeout seconds, a :exc: chaoslib.exceptions.ActivityFailed exception is raised. Signature: def deployment_fully_available ( name : str , ns : str = 'default' , label_selector : str = None , timeout : int = 30 , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Union [ bool , NoneType ]: pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string null No timeout integer 30 No Usage: { \"name\" : \"deployment-fully-available\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.deployment.probes\" , \"func\" : \"deployment_fully_available\" , \"arguments\" : { \"name\" : \"\" } } } name : deployment-fully-available provider : arguments : name : '' func : deployment_fully_available module : chaosk8s.deployment.probes type : python type : probe deployment_not_fully_available \u00b6 Type probe Module chaosk8s.deployment.probes Name deployment_not_fully_available Return Union[bool, NoneType] Wait until the deployment gets into an intermediate state where not all expected replicas are available. Once this state is reached, return True . If the state is not reached after timeout seconds, a :exc: chaoslib.exceptions.ActivityFailed exception is raised. Signature: def deployment_not_fully_available ( name : str , ns : str = 'default' , label_selector : str = None , timeout : int = 30 , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Union [ bool , NoneType ]: pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string null No timeout integer 30 No Usage: { \"name\" : \"deployment-not-fully-available\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.deployment.probes\" , \"func\" : \"deployment_not_fully_available\" , \"arguments\" : { \"name\" : \"\" } } } name : deployment-not-fully-available provider : arguments : name : '' func : deployment_not_fully_available module : chaosk8s.deployment.probes type : python type : probe scale_deployment \u00b6 Type action Module chaosk8s.deployment.actions Name scale_deployment Return None Scale a deployment up or down. The name is the name of the deployment. Signature: def scale_deployment ( name : str , replicas : int , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes replicas integer Yes ns string \u201cdefault\u201d No Usage: { \"name\" : \"scale-deployment\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.deployment.actions\" , \"func\" : \"scale_deployment\" , \"arguments\" : { \"name\" : \"\" , \"replicas\" : 0 } } } name : scale-deployment provider : arguments : name : '' replicas : 0 func : scale_deployment module : chaosk8s.deployment.actions type : python type : action networking \u00b6 allow_dns_access \u00b6 Type action Module chaosk8s.networking.actions Name allow_dns_access Return None Convenient helper rule to DNS access from all pods in a namespace, unless `label_selectors, in which case, only matching pods will be impacted. Signature: def allow_dns_access ( label_selectors : Dict [ str , Any ] = None , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required label_selectors mapping null No ns string \u201cdefault\u201d No Usage: { \"name\" : \"allow-dns-access\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.networking.actions\" , \"func\" : \"allow_dns_access\" } } name : allow-dns-access provider : func : allow_dns_access module : chaosk8s.networking.actions type : python type : action create_network_policy \u00b6 Type action Module chaosk8s.networking.actions Name create_network_policy Return None Create a network policy in the given namespace eitehr from the definition as spec or from a file containing the definition at spec_path . Signature: def create_network_policy ( spec : Dict [ str , Any ] = None , spec_path : str = None , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required spec mapping null No spec_path string null No ns string \u201cdefault\u201d No Usage: { \"name\" : \"create-network-policy\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.networking.actions\" , \"func\" : \"create_network_policy\" } } name : create-network-policy provider : func : create_network_policy module : chaosk8s.networking.actions type : python type : action deny_all_egress \u00b6 Type action Module chaosk8s.networking.actions Name deny_all_egress Return None Convenient helper rule to deny all egress network from all pods in a namespace, unless `label_selectors, in which case, only matching pods will be impacted. Signature: def deny_all_egress ( label_selectors : Dict [ str , Any ] = None , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required label_selectors mapping null No ns string \u201cdefault\u201d No Usage: { \"name\" : \"deny-all-egress\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.networking.actions\" , \"func\" : \"deny_all_egress\" } } name : deny-all-egress provider : func : deny_all_egress module : chaosk8s.networking.actions type : python type : action deny_all_ingress \u00b6 Type action Module chaosk8s.networking.actions Name deny_all_ingress Return None Convenient helper policy to deny ingress network to all pods in a namespace, unless `label_selectors, in which case, only matching pods will be impacted. Signature: def deny_all_ingress ( label_selectors : Dict [ str , Any ] = None , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required label_selectors mapping null No ns string \u201cdefault\u201d No Usage: { \"name\" : \"deny-all-ingress\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.networking.actions\" , \"func\" : \"deny_all_ingress\" } } name : deny-all-ingress provider : func : deny_all_ingress module : chaosk8s.networking.actions type : python type : action remove_allow_dns_access \u00b6 Type action Module chaosk8s.networking.actions Name remove_allow_dns_access Return None Remove the rule set by the allow_dns_access action. Signature: def remove_allow_dns_access ( ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required ns string \u201cdefault\u201d No Usage: { \"name\" : \"remove-allow-dns-access\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.networking.actions\" , \"func\" : \"remove_allow_dns_access\" } } name : remove-allow-dns-access provider : func : remove_allow_dns_access module : chaosk8s.networking.actions type : python type : action remove_deny_all_egress \u00b6 Type action Module chaosk8s.networking.actions Name remove_deny_all_egress Return None Remove the rule set by the deny_all_egress action. Signature: def remove_deny_all_egress ( ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required ns string \u201cdefault\u201d No Usage: { \"name\" : \"remove-deny-all-egress\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.networking.actions\" , \"func\" : \"remove_deny_all_egress\" } } name : remove-deny-all-egress provider : func : remove_deny_all_egress module : chaosk8s.networking.actions type : python type : action remove_deny_all_ingress \u00b6 Type action Module chaosk8s.networking.actions Name remove_deny_all_ingress Return None Remove the rule set by the deny_all_ingress action. Signature: def remove_deny_all_ingress ( ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required ns string \u201cdefault\u201d No Usage: { \"name\" : \"remove-deny-all-ingress\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.networking.actions\" , \"func\" : \"remove_deny_all_ingress\" } } name : remove-deny-all-ingress provider : func : remove_deny_all_ingress module : chaosk8s.networking.actions type : python type : action remove_network_policy \u00b6 Type action Module chaosk8s.networking.actions Name remove_network_policy Return None Create a network policy in the given namespace eitehr from the definition as spec or from a file containing the definition at spec_path . Signature: def remove_network_policy ( name : str , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No Usage: { \"name\" : \"remove-network-policy\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.networking.actions\" , \"func\" : \"remove_network_policy\" , \"arguments\" : { \"name\" : \"\" } } } name : remove-network-policy provider : arguments : name : '' func : remove_network_policy module : chaosk8s.networking.actions type : python type : action node \u00b6 cordon_node \u00b6 Type action Module chaosk8s.node.actions Name cordon_node Return None Cordon nodes matching the given label or name, so that no pods are scheduled on them any longer. Signature: def cordon_node ( name : str = None , label_selector : str = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string null No label_selector string null No Usage: { \"name\" : \"cordon-node\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.node.actions\" , \"func\" : \"cordon_node\" } } name : cordon-node provider : func : cordon_node module : chaosk8s.node.actions type : python type : action create_node \u00b6 Type action Module chaosk8s.node.actions Name create_node Return kubernetes.client.models.v1_node.V1Node Create one new node in the cluster. Due to the way things work on certain cloud providers, you won\u2019t be able to use this meaningfully on them. For instance on GCE, this will likely fail. See also: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency Signature: def create_node ( meta : Dict [ str , Any ] = None , spec : Dict [ str , Any ] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> kubernetes . client . models . v1_node . V1Node : pass Arguments: Name Type Default Required meta mapping null No spec mapping null No Usage: { \"name\" : \"create-node\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.node.actions\" , \"func\" : \"create_node\" } } name : create-node provider : func : create_node module : chaosk8s.node.actions type : python type : action delete_nodes \u00b6 Type action Module chaosk8s.node.actions Name delete_nodes Return None Delete nodes gracefully. Select the appropriate nodes by label. Nodes are not drained beforehand so we can see how cluster behaves. Nodes cannot be restarted, they are really deleted. Please be careful when using this action. On certain cloud providers, you also need to delete the underneath VM instance as well afterwards. This is the case on GCE for instance. If all is set to True , all nodes will be terminated. If rand is set to True , one random node will be terminated. If \u0300 count is set to a positive number, only a upto count nodes (randomly picked) will be terminated. Otherwise, the first retrieved node will be terminated. Signature: def delete_nodes ( label_selector : str = None , all : bool = False , rand : bool = False , count : int = None , grace_period_seconds : int = None , secrets : Dict [ str , Dict [ str , str ]] = None , pod_label_selector : str = None , pod_namespace : str = None ): pass Arguments: Name Type Default Required label_selector string null No all boolean false No rand boolean false No count integer null No grace_period_seconds integer null No pod_label_selector string null No pod_namespace string null No Usage: { \"name\" : \"delete-nodes\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.node.actions\" , \"func\" : \"delete_nodes\" } } name : delete-nodes provider : func : delete_nodes module : chaosk8s.node.actions type : python type : action drain_nodes \u00b6 Type action Module chaosk8s.node.actions Name drain_nodes Return boolean Drain nodes matching the given label or name, so that no pods are scheduled on them any longer and running pods are evicted. It does a similar job to kubectl drain --ignore-daemonsets or kubectl drain --delete-local-data --ignore-daemonsets if delete_pods_with_local_storage is set to True . There is no equivalent to the kubectl drain --force flag. You probably want to call uncordon from in your experiment\u2019s rollbacks. Signature: def drain_nodes ( name : str = None , label_selector : str = None , delete_pods_with_local_storage : bool = False , timeout : int = 120 , secrets : Dict [ str , Dict [ str , str ]] = None , count : int = None , pod_label_selector : str = None , pod_namespace : str = None ) -> bool : pass Arguments: Name Type Default Required name string null No label_selector string null No delete_pods_with_local_storage boolean false No timeout integer 120 No count integer null No pod_label_selector string null No pod_namespace string null No Usage: { \"name\" : \"drain-nodes\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.node.actions\" , \"func\" : \"drain_nodes\" } } name : drain-nodes provider : func : drain_nodes module : chaosk8s.node.actions type : python type : action get_nodes \u00b6 Type probe Module chaosk8s.node.probes Name get_nodes Return None List all Kubernetes worker nodes in your cluster. You may filter nodes by specifying a label selector. Signature: def get_nodes ( label_selector : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required label_selector string null No Usage: { \"name\" : \"get-nodes\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.node.probes\" , \"func\" : \"get_nodes\" } } name : get-nodes provider : func : get_nodes module : chaosk8s.node.probes type : python type : probe uncordon_node \u00b6 Type action Module chaosk8s.node.actions Name uncordon_node Return None Uncordon nodes matching the given label name, so that pods can be scheduled on them again. Signature: def uncordon_node ( name : str = None , label_selector : str = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string null No label_selector string null No Usage: { \"name\" : \"uncordon-node\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.node.actions\" , \"func\" : \"uncordon_node\" } } name : uncordon-node provider : func : uncordon_node module : chaosk8s.node.actions type : python type : action pod \u00b6 count_pods \u00b6 Type probe Module chaosk8s.pod.probes Name count_pods Return integer Count the number of pods matching the given selector in a given phase , if one is given. Signature: def count_pods ( label_selector : str , phase : str = None , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required label_selector string Yes phase string null No ns string \u201cdefault\u201d No Usage: { \"name\" : \"count-pods\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.pod.probes\" , \"func\" : \"count_pods\" , \"arguments\" : { \"label_selector\" : \"\" } } } name : count-pods provider : arguments : label_selector : '' func : count_pods module : chaosk8s.pod.probes type : python type : probe delete_pods \u00b6 Type action Module chaosk8s.pod.actions Name delete_pods Return None Delete pods by name in the namespace ns . The pods are deleted without a graceful period to trigger an abrupt termination. The selected resources are matched by the given label_selector . Signature: def delete_pods ( name : str , ns : str = 'default' , label_selector : str = 'name in ( {name} )' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string \u201cname in ({name})\u201d No Usage: { \"name\" : \"delete-pods\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.pod.actions\" , \"func\" : \"delete_pods\" , \"arguments\" : { \"name\" : \"\" } } } name : delete-pods provider : arguments : name : '' func : delete_pods module : chaosk8s.pod.actions type : python type : action exec_in_pods \u00b6 Type action Module chaosk8s.pod.actions Name exec_in_pods Return list Execute the command cmd in the specified pod\u2019s container. Select the appropriate pods by label and/or name patterns. Whenever a pattern is provided for the name, all pods retrieved will be filtered out if their name do not match the given pattern. If neither label_selector nor name_pattern are provided, all pods in the namespace will be selected for termination. If all is set to True , all matching pods will be affected. Value of qty varies based on mode . If mode is set to fixed , then qty refers to number of pods affected. If mode is set to percentage , then qty refers to percentage of pods, from 1 to 100, to be affected. Default mode is fixed and default qty is 1 . If order is set to oldest , the retrieved pods will be ordered by the pods creation_timestamp, with the oldest pod first in list. If rand is set to True , n random pods will be affected Otherwise, the first retrieved n pods will be used Signature: def exec_in_pods ( cmd : str , label_selector : str = None , name_pattern : str = None , all : bool = False , rand : bool = False , mode : str = 'fixed' , qty : int = 1 , ns : str = 'default' , order : str = 'alphabetic' , container_name : str = None , request_timeout : int = 60 , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required cmd string Yes label_selector string null No name_pattern string null No all boolean false No rand boolean false No mode string \u201cfixed\u201d No qty integer 1 No ns string \u201cdefault\u201d No order string \u201calphabetic\u201d No container_name string null No request_timeout integer 60 No Usage: { \"name\" : \"exec-in-pods\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.pod.actions\" , \"func\" : \"exec_in_pods\" , \"arguments\" : { \"cmd\" : \"\" } } } name : exec-in-pods provider : arguments : cmd : '' func : exec_in_pods module : chaosk8s.pod.actions type : python type : action pod_is_not_available \u00b6 Type probe Module chaosk8s.pod.probes Name pod_is_not_available Return boolean Lookup pods with a name label set to the given name in the specified ns . Raises :exc: chaoslib.exceptions.ActivityFailed when one of the pods with the specified name is in the \"Running\" phase. Signature: def pod_is_not_available ( name : str , ns : str = 'default' , label_selector : str = 'name in ( {name} )' , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string \u201cname in ({name})\u201d No Usage: { \"name\" : \"pod-is-not-available\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.pod.probes\" , \"func\" : \"pod_is_not_available\" , \"arguments\" : { \"name\" : \"\" } } } name : pod-is-not-available provider : arguments : name : '' func : pod_is_not_available module : chaosk8s.pod.probes type : python type : probe pods_in_conditions \u00b6 Type probe Module chaosk8s.pod.probes Name pods_in_conditions Return boolean Lookup a pod by label_selector in the namespace ns . Raises :exc: chaoslib.exceptions.ActivityFailed if one of the given conditions type/status is not as expected Signature: def pods_in_conditions ( label_selector : str , conditions : List [ Dict [ str , str ]], ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required label_selector string Yes conditions list Yes ns string \u201cdefault\u201d No Usage: { \"name\" : \"pods-in-conditions\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.pod.probes\" , \"func\" : \"pods_in_conditions\" , \"arguments\" : { \"label_selector\" : \"\" , \"conditions\" : [] } } } name : pods-in-conditions provider : arguments : conditions : [] label_selector : '' func : pods_in_conditions module : chaosk8s.pod.probes type : python type : probe pods_in_phase \u00b6 Type probe Module chaosk8s.pod.probes Name pods_in_phase Return boolean Lookup a pod by label_selector in the namespace ns . Raises :exc: chaoslib.exceptions.ActivityFailed when the state is not as expected. Signature: def pods_in_phase ( label_selector : str , phase : str = 'Running' , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required label_selector string Yes phase string \u201cRunning\u201d No ns string \u201cdefault\u201d No Usage: { \"name\" : \"pods-in-phase\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.pod.probes\" , \"func\" : \"pods_in_phase\" , \"arguments\" : { \"label_selector\" : \"\" } } } name : pods-in-phase provider : arguments : label_selector : '' func : pods_in_phase module : chaosk8s.pod.probes type : python type : probe pods_not_in_phase \u00b6 Type probe Module chaosk8s.pod.probes Name pods_not_in_phase Return boolean Lookup a pod by label_selector in the namespace ns . Raises :exc: chaoslib.exceptions.ActivityFailed when the pod is in the given phase and should not have. Signature: def pods_not_in_phase ( label_selector : str , phase : str = 'Running' , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required label_selector string Yes phase string \u201cRunning\u201d No ns string \u201cdefault\u201d No Usage: { \"name\" : \"pods-not-in-phase\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.pod.probes\" , \"func\" : \"pods_not_in_phase\" , \"arguments\" : { \"label_selector\" : \"\" } } } name : pods-not-in-phase provider : arguments : label_selector : '' func : pods_not_in_phase module : chaosk8s.pod.probes type : python type : probe read_pod_logs \u00b6 Type probe Module chaosk8s.pod.probes Name read_pod_logs Return mapping Fetch logs for all the pods with the label \"name\" set to name and return a dictionary with the keys being the pod\u2019s name and the values the logs of said pod. If name is not provided, use only the label_selector instead. When your pod has several containers, you should also set container_name to clarify which container you want to read logs from. If you provide last , this returns the logs of the last N seconds until now. This can set to a fluent delta such as 10 minutes . You may also set from_previous to True to capture the logs of a previous pod\u2019s incarnation, if any. Signature: def read_pod_logs ( name : str = None , last : Union [ str , NoneType ] = None , ns : str = 'default' , from_previous : bool = False , label_selector : str = 'name in ( {name} )' , container_name : str = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , str ]: pass Arguments: Name Type Default Required name string null No last object null No ns string \u201cdefault\u201d No from_previous boolean false No label_selector string \u201cname in ({name})\u201d No container_name string null No Usage: { \"name\" : \"read-pod-logs\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.pod.probes\" , \"func\" : \"read_pod_logs\" } } name : read-pod-logs provider : func : read_pod_logs module : chaosk8s.pod.probes type : python type : probe terminate_pods \u00b6 Type action Module chaosk8s.pod.actions Name terminate_pods Return None Terminate a pod gracefully. Select the appropriate pods by label and/or name patterns. Whenever a pattern is provided for the name, all pods retrieved will be filtered out if their name do not match the given pattern. If neither label_selector nor name_pattern are provided, all pods in the namespace will be selected for termination. If all is set to True , all matching pods will be terminated. Value of qty varies based on mode . If mode is set to fixed , then qty refers to number of pods to be terminated. If mode is set to percentage , then qty refers to percentage of pods, from 1 to 100, to be terminated. Default mode is fixed and default qty is 1 . If order is set to oldest , the retrieved pods will be ordered by the pods creation_timestamp, with the oldest pod first in list. If rand is set to True , n random pods will be terminated Otherwise, the first retrieved n pods will be terminated. If grace_period is greater than or equal to 0, it will be used as the grace period (in seconds) to terminate the pods. Otherwise, the default pod\u2019s grace period will be used. Signature: def terminate_pods ( label_selector : str = None , name_pattern : str = None , all : bool = False , rand : bool = False , mode : str = 'fixed' , qty : int = 1 , grace_period : int = - 1 , ns : str = 'default' , order : str = 'alphabetic' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required label_selector string null No name_pattern string null No all boolean false No rand boolean false No mode string \u201cfixed\u201d No qty integer 1 No grace_period integer -1 No ns string \u201cdefault\u201d No order string \u201calphabetic\u201d No Usage: { \"name\" : \"terminate-pods\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.pod.actions\" , \"func\" : \"terminate_pods\" } } name : terminate-pods provider : func : terminate_pods module : chaosk8s.pod.actions type : python type : action probes \u00b6 all_microservices_healthy \u00b6 Type probe Module chaosk8s.probes Name all_microservices_healthy Return Tuple[Dict[str, Any], Dict[str, Any]] !!!DEPRECATED!!! Signature: def all_microservices_healthy ( ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Tuple [ Dict [ str , Any ], Dict [ str , Any ]]: pass Arguments: Name Type Default Required ns string \u201cdefault\u201d No Usage: { \"name\" : \"all-microservices-healthy\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.probes\" , \"func\" : \"all_microservices_healthy\" } } name : all-microservices-healthy provider : func : all_microservices_healthy module : chaosk8s.probes type : python type : probe deployment_is_fully_available \u00b6 Type probe Module chaosk8s.probes Name deployment_is_fully_available Return None !!!DEPRECATED!!! Signature: def deployment_is_fully_available ( name : str , ns : str = 'default' , label_selector : str = None , timeout : int = 30 , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string null No timeout integer 30 No Usage: { \"name\" : \"deployment-is-fully-available\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.probes\" , \"func\" : \"deployment_is_fully_available\" , \"arguments\" : { \"name\" : \"\" } } } name : deployment-is-fully-available provider : arguments : name : '' func : deployment_is_fully_available module : chaosk8s.probes type : python type : probe deployment_is_not_fully_available \u00b6 Type probe Module chaosk8s.probes Name deployment_is_not_fully_available Return None !!!DEPRECATED!!! Signature: def deployment_is_not_fully_available ( name : str , ns : str = 'default' , label_selector : str = None , timeout : int = 30 , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string null No timeout integer 30 No Usage: { \"name\" : \"deployment-is-not-fully-available\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.probes\" , \"func\" : \"deployment_is_not_fully_available\" , \"arguments\" : { \"name\" : \"\" } } } name : deployment-is-not-fully-available provider : arguments : name : '' func : deployment_is_not_fully_available module : chaosk8s.probes type : python type : probe microservice_available_and_healthy \u00b6 Type probe Module chaosk8s.probes Name microservice_available_and_healthy Return Union[bool, NoneType] !!!DEPRECATED!!! Signature: def microservice_available_and_healthy ( name : str , ns : str = 'default' , label_selector : str = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Union [ bool , NoneType ]: pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string null No Usage: { \"name\" : \"microservice-available-and-healthy\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.probes\" , \"func\" : \"microservice_available_and_healthy\" , \"arguments\" : { \"name\" : \"\" } } } name : microservice-available-and-healthy provider : arguments : name : '' func : microservice_available_and_healthy module : chaosk8s.probes type : python type : probe microservice_is_not_available \u00b6 Type probe Module chaosk8s.probes Name microservice_is_not_available Return boolean !!!DEPRECATED!!! Signature: def microservice_is_not_available ( name : str , ns : str = 'default' , label_selector : str = 'name in ( {name} )' , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string \u201cname in ({name})\u201d No Usage: { \"name\" : \"microservice-is-not-available\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.probes\" , \"func\" : \"microservice_is_not_available\" , \"arguments\" : { \"name\" : \"\" } } } name : microservice-is-not-available provider : arguments : name : '' func : microservice_is_not_available module : chaosk8s.probes type : python type : probe read_microservices_logs \u00b6 Type probe Module chaosk8s.probes Name read_microservices_logs Return mapping Fetch logs for all the pods with the label \"name\" set to name and return a dictionary with the keys being the pod\u2019s name and the values the logs of said pod. If name is not provided, use only the label_selector instead. When your pod has several containers, you should also set container_name to clarify which container you want to read logs from. If you provide last , this returns the logs of the last N seconds until now. This can set to a fluent delta such as 10 minutes . You may also set from_previous to True to capture the logs of a previous pod\u2019s incarnation, if any. Signature: def read_microservices_logs ( name : str = None , last : Union [ str , NoneType ] = None , ns : str = 'default' , from_previous : bool = False , label_selector : str = 'name in ( {name} )' , container_name : str = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , str ]: pass Arguments: Name Type Default Required name string null No last object null No ns string \u201cdefault\u201d No from_previous boolean false No label_selector string \u201cname in ({name})\u201d No container_name string null No Usage: { \"name\" : \"read-microservices-logs\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.probes\" , \"func\" : \"read_microservices_logs\" } } name : read-microservices-logs provider : func : read_microservices_logs module : chaosk8s.probes type : python type : probe service_endpoint_is_initialized \u00b6 Type probe Module chaosk8s.probes Name service_endpoint_is_initialized Return None !!!DEPRECATED!!! Signature: def service_endpoint_is_initialized ( name : str , ns : str = 'default' , label_selector : str = 'name in ( {name} )' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string \u201cname in ({name})\u201d No Usage: { \"name\" : \"service-endpoint-is-initialized\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.probes\" , \"func\" : \"service_endpoint_is_initialized\" , \"arguments\" : { \"name\" : \"\" } } } name : service-endpoint-is-initialized provider : arguments : name : '' func : service_endpoint_is_initialized module : chaosk8s.probes type : python type : probe replicaset \u00b6 delete_replica_set \u00b6 Type action Module chaosk8s.replicaset.actions Name delete_replica_set Return None Delete a replica set by name in the namespace ns . The replica set is deleted without a graceful period to trigger an abrupt termination. The selected resources are matched by the given label_selector . Signature: def delete_replica_set ( name : str , ns : str = 'default' , label_selector : str = 'name in ( {name} )' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string \u201cname in ({name})\u201d No Usage: { \"name\" : \"delete-replica-set\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.replicaset.actions\" , \"func\" : \"delete_replica_set\" , \"arguments\" : { \"name\" : \"\" } } } name : delete-replica-set provider : arguments : name : '' func : delete_replica_set module : chaosk8s.replicaset.actions type : python type : action service \u00b6 create_service_endpoint \u00b6 Type action Module chaosk8s.service.actions Name create_service_endpoint Return None Create a service endpoint described by the service config, which must be the path to the JSON or YAML representation of the service. Signature: def create_service_endpoint ( spec_path : str , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required spec_path string Yes ns string \u201cdefault\u201d No Usage: { \"name\" : \"create-service-endpoint\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.service.actions\" , \"func\" : \"create_service_endpoint\" , \"arguments\" : { \"spec_path\" : \"\" } } } name : create-service-endpoint provider : arguments : spec_path : '' func : create_service_endpoint module : chaosk8s.service.actions type : python type : action delete_service \u00b6 Type action Module chaosk8s.service.actions Name delete_service Return None Remove the given service Signature: def delete_service ( name : str , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No Usage: { \"name\" : \"delete-service\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.service.actions\" , \"func\" : \"delete_service\" , \"arguments\" : { \"name\" : \"\" } } } name : delete-service provider : arguments : name : '' func : delete_service module : chaosk8s.service.actions type : python type : action service_is_initialized \u00b6 Type probe Module chaosk8s.service.probes Name service_is_initialized Return boolean Lookup a service endpoint by its name and raises :exc: FailedProbe when the service was not found or not initialized. Signature: def service_is_initialized ( name : str = None , ns : str = 'default' , label_selector : str = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required name string null No ns string \u201cdefault\u201d No label_selector string null No Usage: { \"name\" : \"service-is-initialized\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.service.probes\" , \"func\" : \"service_is_initialized\" } } name : service-is-initialized provider : func : service_is_initialized module : chaosk8s.service.probes type : python type : probe statefulset \u00b6 create_statefulset \u00b6 Type action Module chaosk8s.statefulset.actions Name create_statefulset Return None Create a statefulset described by the service config, which must be the path to the JSON or YAML representation of the statefulset. Signature: def create_statefulset ( spec_path : str , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required spec_path string Yes ns string \u201cdefault\u201d No Usage: { \"name\" : \"create-statefulset\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.statefulset.actions\" , \"func\" : \"create_statefulset\" , \"arguments\" : { \"spec_path\" : \"\" } } } name : create-statefulset provider : arguments : spec_path : '' func : create_statefulset module : chaosk8s.statefulset.actions type : python type : action remove_statefulset \u00b6 Type action Module chaosk8s.statefulset.actions Name remove_statefulset Return None Remove a statefulset by name in the namespace ns . The statefulset is removed by deleting it without a graceful period to trigger an abrupt termination. The selected resources are matched by the given label_selector . Signature: def remove_statefulset ( name : str = None , ns : str = 'default' , label_selector : str = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string null No ns string \u201cdefault\u201d No label_selector string null No Usage: { \"name\" : \"remove-statefulset\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.statefulset.actions\" , \"func\" : \"remove_statefulset\" } } name : remove-statefulset provider : func : remove_statefulset module : chaosk8s.statefulset.actions type : python type : action scale_statefulset \u00b6 Type action Module chaosk8s.statefulset.actions Name scale_statefulset Return None Scale a stateful set up or down. The name is the name of the stateful set. Signature: def scale_statefulset ( name : str , replicas : int , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes replicas integer Yes ns string \u201cdefault\u201d No Usage: { \"name\" : \"scale-statefulset\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.statefulset.actions\" , \"func\" : \"scale_statefulset\" , \"arguments\" : { \"name\" : \"\" , \"replicas\" : 0 } } } name : scale-statefulset provider : arguments : name : '' replicas : 0 func : scale_statefulset module : chaosk8s.statefulset.actions type : python type : action statefulset_fully_available \u00b6 Type probe Module chaosk8s.statefulset.probes Name statefulset_fully_available Return None Wait until all the statefulSet expected replicas are available. Once this state is reached, return True . If the state is not reached after timeout seconds, a :exc: chaoslib.exceptions.ActivityFailed exception is raised. Signature: def statefulset_fully_available ( name : str , ns : str = 'default' , label_selector : str = None , timeout : int = 30 , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string null No timeout integer 30 No Usage: { \"name\" : \"statefulset-fully-available\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.statefulset.probes\" , \"func\" : \"statefulset_fully_available\" , \"arguments\" : { \"name\" : \"\" } } } name : statefulset-fully-available provider : arguments : name : '' func : statefulset_fully_available module : chaosk8s.statefulset.probes type : python type : probe statefulset_not_fully_available \u00b6 Type probe Module chaosk8s.statefulset.probes Name statefulset_not_fully_available Return None Wait until the statefulSet gets into an intermediate state where not all expected replicas are available. Once this state is reached, return True . If the state is not reached after timeout seconds, a :exc: chaoslib.exceptions.ActivityFailed exception is raised. Signature: def statefulset_not_fully_available ( name : str , ns : str = 'default' , label_selector : str = None , timeout : int = 30 , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string null No timeout integer 30 No Usage: { \"name\" : \"statefulset-not-fully-available\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.statefulset.probes\" , \"func\" : \"statefulset_not_fully_available\" , \"arguments\" : { \"name\" : \"\" } } } name : statefulset-not-fully-available provider : arguments : name : '' func : statefulset_not_fully_available module : chaosk8s.statefulset.probes type : python type : probe","title":"Kubernetes"},{"location":"drivers/kubernetes/#extension-chaosk8s","text":"Version 0.25.1 Repository https://github.com/chaostoolkit/chaostoolkit-kubernetes This project contains activities, such as probes and actions, you can call from your experiment through the Chaos Toolkit to perform Chaos Engineering against the Kubernetes API: killing a pod, removing a statefulset or node\u2026","title":"Extension chaosk8s"},{"location":"drivers/kubernetes/#install","text":"To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install chaostoolkit-kubernetes","title":"Install"},{"location":"drivers/kubernetes/#usage","text":"To use the probes and actions from this package, add the following to your experiment file: { \"title\" : \"Do we remain available in face of pod going down?\" , \"description\" : \"We expect Kubernetes to handle the situation gracefully when a pod goes down\" , \"tags\" : [ \"kubernetes\" ], \"steady-state-hypothesis\" : { \"title\" : \"Verifying service remains healthy\" , \"probes\" : [ { \"name\" : \"all-our-microservices-should-be-healthy\" , \"type\" : \"probe\" , \"tolerance\" : true , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.probes\" , \"func\" : \"microservice_available_and_healthy\" , \"arguments\" : { \"name\" : \"myapp\" } } } ] }, \"method\" : [ { \"type\" : \"action\" , \"name\" : \"terminate-db-pod\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.pod.actions\" , \"func\" : \"terminate_pods\" , \"arguments\" : { \"label_selector\" : \"app=my-app\" , \"name_pattern\" : \"my-app-[0-9]$\" , \"rand\" : true } }, \"pauses\" : { \"after\" : 5 } } ] } That\u2019s it! Notice how the action gives you the way to kill one pod randomly. Please explore the documentation to see existing probes and actions.","title":"Usage"},{"location":"drivers/kubernetes/#configuration","text":"","title":"Configuration"},{"location":"drivers/kubernetes/#use-kubeconfig","text":"If you have a valid entry in your ~/.kube/config file for the cluster you want to target, then there is nothing to be done. You may specify KUBECONFIG to specify a different location. $ export KUBECONFIG=/tmp/my-config","title":"Use ~/.kube/config"},{"location":"drivers/kubernetes/#specify-the-kubernetes-context","text":"Quite often, your Kubernetes configuration contains several entries and you need to define the one to use as a default context when not it isn\u2019t explicitely provided. You may of course change your default using kubectl config use-context KUBERNETES_CONTEXT but you can also be explicit in your experiment as follows: { \"title\" : \"Do we remain available in face of pod going down?\" , \"description\" : \"We expect Kubernetes to handle the situation gracefully when a pod goes down\" , \"tags\" : [ \"kubernetes\" ], \"secrets\" : { \"k8s\" : { \"KUBERNETES_CONTEXT\" : \"...\" } }, \"steady-state-hypothesis\" : { \"title\" : \"Verifying service remains healthy\" , \"probes\" : [ { \"name\" : \"all-our-microservices-should-be-healthy\" , \"type\" : \"probe\" , \"tolerance\" : true , \"secrets\" : [ \"k8s\" ], \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.probes\" , \"func\" : \"microservice_available_and_healthy\" , \"arguments\" : { \"name\" : \"myapp\" } } } ] }, \"method\" : [ { \"type\" : \"action\" , \"name\" : \"terminate-db-pod\" , \"secrets\" : [ \"k8s\" ], \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.pod.actions\" , \"func\" : \"terminate_pods\" , \"arguments\" : { \"label_selector\" : \"app=my-app\" , \"name_pattern\" : \"my-app-[0-9]$\" , \"rand\" : true } }, \"pauses\" : { \"after\" : 5 } } ] } You need to specify the KUBERNETES_CONTEXT secret key to the name of the context you want the experiment to use. Make sure to also inform the actions and probes about the secret entries they should be passed \"secrets\": [\"k8s\"] .","title":"Specify the Kubernetes context"},{"location":"drivers/kubernetes/#use-a-pods-service-account","text":"When running from a pod (not your local machine or a CI for instance), the ./.kube/config file does not exist. Instead, the credentials can be found at /var/run/secrets/kubernetes.io/serviceaccount/token . To let the extension know about this, simply set CHAOSTOOLKIT_IN_POD from the environment variable of the pod specification: env : - name : CHAOSTOOLKIT_IN_POD value : \"true\"","title":"Use a Pod's service account"},{"location":"drivers/kubernetes/#pass-all-credentials-in-the-experiment","text":"Finally, you may pass explicitely all required credentials information to the experiment as follows:","title":"Pass all credentials in the experiment"},{"location":"drivers/kubernetes/#using-an-api-key","text":"{ \"secrets\" : { \"kubernetes\" : { \"KUBERNETES_HOST\" : \"http://somehost\" , \"KUBERNETES_API_KEY\" : { \"type\" : \"env\" , \"key\" : \"SOME_ENV_VAR\" } } } }","title":"Using an API key"},{"location":"drivers/kubernetes/#using-a-usernamepassword","text":"{ \"secrets\" : { \"kubernetes\" : { \"KUBERNETES_HOST\" : \"http://somehost\" , \"KUBERNETES_USERNAME\" : { \"type\" : \"env\" , \"key\" : \"SOME_ENV_VAR\" }, \"KUBERNETES_PASSWORD\" : { \"type\" : \"env\" , \"key\" : \"SOME_ENV_VAR\" } } } }","title":"Using a username/password"},{"location":"drivers/kubernetes/#using-a-tls-keycertificate","text":"{ \"secrets\" : { \"kubernetes\" : { \"KUBERNETES_HOST\" : \"http://somehost\" , \"KUBERNETES_CERT_FILE\" : { \"type\" : \"env\" , \"key\" : \"SOME_ENV_VAR\" }, \"KUBERNETES_KEY_FILE\" : { \"type\" : \"env\" , \"key\" : \"SOME_ENV_VAR\" } } } }","title":"Using a TLS key/certificate"},{"location":"drivers/kubernetes/#managed-kubernetes-clusters-authentication","text":"On some managed Kubernetes clusters, you also need to authenticate against the platform itself because the Kubernetes authentication is delegated to it.","title":"Managed Kubernetes Clusters Authentication"},{"location":"drivers/kubernetes/#google-cloud-platform","text":"In addition to your Kubernetes credentials (via the ~/.kube/config file), you need to authenticate against the Google Cloud Platform itself. Usually this is done via : $ gcloud auth login But can also be achieved by defining the GOOGLE_APPLICATION_CREDENTIALS environment variable.","title":"Google Cloud Platform"},{"location":"drivers/kubernetes/#contribute","text":"If you wish to contribute more functions to this package, you are more than welcome to do so. Please fork this project, make your changes following the usual PEP 8 code style, add appropriate tests and submit a PR for review. The Chaos Toolkit projects require all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR.","title":"Contribute"},{"location":"drivers/kubernetes/#develop","text":"If you wish to develop on this project, make sure to install the development dependencies. But first, create a virtual environment and then install those dependencies. $ pip install -r requirements-dev.txt -r requirements.txt Then, point your environment to this directory: $ pip install -e . Now, you can edit the files and they will be automatically be seen by your environment, even when running from the chaos command locally.","title":"Develop"},{"location":"drivers/kubernetes/#test","text":"To run the tests for the project execute the following: $ pytest","title":"Test"},{"location":"drivers/kubernetes/#exported-activities","text":"","title":"Exported Activities"},{"location":"drivers/kubernetes/#actions","text":"","title":"actions"},{"location":"drivers/kubernetes/#kill_microservice","text":"Type action Module chaosk8s.actions Name kill_microservice Return None !!!DEPRECATED!!! Signature: def kill_microservice ( name : str , ns : str = 'default' , label_selector : str = 'name in ( {name} )' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string \u201cname in ({name})\u201d No Usage: { \"name\" : \"kill-microservice\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.actions\" , \"func\" : \"kill_microservice\" , \"arguments\" : { \"name\" : \"\" } } } name : kill-microservice provider : arguments : name : '' func : kill_microservice module : chaosk8s.actions type : python type : action","title":"kill_microservice"},{"location":"drivers/kubernetes/#remove_service_endpoint","text":"Type action Module chaosk8s.actions Name remove_service_endpoint Return None !!!DEPRECATED!!! Signature: def remove_service_endpoint ( name : str , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No Usage: { \"name\" : \"remove-service-endpoint\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.actions\" , \"func\" : \"remove_service_endpoint\" , \"arguments\" : { \"name\" : \"\" } } } name : remove-service-endpoint provider : arguments : name : '' func : remove_service_endpoint module : chaosk8s.actions type : python type : action","title":"remove_service_endpoint"},{"location":"drivers/kubernetes/#scale_microservice","text":"Type action Module chaosk8s.actions Name scale_microservice Return None !!!DEPRECATED!!! Signature: def scale_microservice ( name : str , replicas : int , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes replicas integer Yes ns string \u201cdefault\u201d No Usage: { \"name\" : \"scale-microservice\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.actions\" , \"func\" : \"scale_microservice\" , \"arguments\" : { \"name\" : \"\" , \"replicas\" : 0 } } } name : scale-microservice provider : arguments : name : '' replicas : 0 func : scale_microservice module : chaosk8s.actions type : python type : action","title":"scale_microservice"},{"location":"drivers/kubernetes/#start_microservice","text":"Type action Module chaosk8s.actions Name start_microservice Return None !!!DEPRECATED!!! Signature: def start_microservice ( spec_path : str , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required spec_path string Yes ns string \u201cdefault\u201d No Usage: { \"name\" : \"start-microservice\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.actions\" , \"func\" : \"start_microservice\" , \"arguments\" : { \"spec_path\" : \"\" } } } name : start-microservice provider : arguments : spec_path : '' func : start_microservice module : chaosk8s.actions type : python type : action","title":"start_microservice"},{"location":"drivers/kubernetes/#crd","text":"","title":"crd"},{"location":"drivers/kubernetes/#create_cluster_custom_object","text":"Type action Module chaosk8s.crd.actions Name create_cluster_custom_object Return mapping Delete a custom object in the given namespace. Read more about custom resources here: https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/ Signature: def create_cluster_custom_object ( group : str , version : str , plural : str , resource : Dict [ str , Any ] = None , resource_as_yaml_file : str = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required group string Yes version string Yes plural string Yes resource mapping null No resource_as_yaml_file string null No Usage: { \"name\" : \"create-cluster-custom-object\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.crd.actions\" , \"func\" : \"create_cluster_custom_object\" , \"arguments\" : { \"group\" : \"\" , \"version\" : \"\" , \"plural\" : \"\" } } } name : create-cluster-custom-object provider : arguments : group : '' plural : '' version : '' func : create_cluster_custom_object module : chaosk8s.crd.actions type : python type : action","title":"create_cluster_custom_object"},{"location":"drivers/kubernetes/#create_custom_object","text":"Type action Module chaosk8s.crd.actions Name create_custom_object Return mapping Create a custom object in the given namespace. Its custom resource definition must already exists or this will fail with a 404. Read more about custom resources here: https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/ Signature: def create_custom_object ( group : str , version : str , plural : str , ns : str = 'default' , resource : Dict [ str , Any ] = None , resource_as_yaml_file : str = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required group string Yes version string Yes plural string Yes ns string \u201cdefault\u201d No resource mapping null No resource_as_yaml_file string null No Usage: { \"name\" : \"create-custom-object\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.crd.actions\" , \"func\" : \"create_custom_object\" , \"arguments\" : { \"group\" : \"\" , \"version\" : \"\" , \"plural\" : \"\" } } } name : create-custom-object provider : arguments : group : '' plural : '' version : '' func : create_custom_object module : chaosk8s.crd.actions type : python type : action","title":"create_custom_object"},{"location":"drivers/kubernetes/#delete_cluster_custom_object","text":"Type action Module chaosk8s.crd.actions Name delete_cluster_custom_object Return mapping Delete a custom object cluster wide. Read more about custom resources here: https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/ Signature: def delete_cluster_custom_object ( group : str , version : str , plural : str , name : str , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required group string Yes version string Yes plural string Yes name string Yes Usage: { \"name\" : \"delete-cluster-custom-object\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.crd.actions\" , \"func\" : \"delete_cluster_custom_object\" , \"arguments\" : { \"group\" : \"\" , \"version\" : \"\" , \"plural\" : \"\" , \"name\" : \"\" } } } name : delete-cluster-custom-object provider : arguments : group : '' name : '' plural : '' version : '' func : delete_cluster_custom_object module : chaosk8s.crd.actions type : python type : action","title":"delete_cluster_custom_object"},{"location":"drivers/kubernetes/#delete_custom_object","text":"Type action Module chaosk8s.crd.actions Name delete_custom_object Return mapping Create a custom object cluster wide. Its custom resource definition must already exists or this will fail with a 404. Read more about custom resources here: https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/ Signature: def delete_custom_object ( group : str , version : str , plural : str , name : str , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required group string Yes version string Yes plural string Yes name string Yes ns string \u201cdefault\u201d No Usage: { \"name\" : \"delete-custom-object\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.crd.actions\" , \"func\" : \"delete_custom_object\" , \"arguments\" : { \"group\" : \"\" , \"version\" : \"\" , \"plural\" : \"\" , \"name\" : \"\" } } } name : delete-custom-object provider : arguments : group : '' name : '' plural : '' version : '' func : delete_custom_object module : chaosk8s.crd.actions type : python type : action","title":"delete_custom_object"},{"location":"drivers/kubernetes/#get_cluster_custom_object","text":"Type probe Module chaosk8s.crd.probes Name get_cluster_custom_object Return mapping Get a custom object cluster-wide. Read more about custom resources here: https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/ Signature: def get_cluster_custom_object ( group : str , version : str , plural : str , name : str , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required group string Yes version string Yes plural string Yes name string Yes Usage: { \"name\" : \"get-cluster-custom-object\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.crd.probes\" , \"func\" : \"get_cluster_custom_object\" , \"arguments\" : { \"group\" : \"\" , \"version\" : \"\" , \"plural\" : \"\" , \"name\" : \"\" } } } name : get-cluster-custom-object provider : arguments : group : '' name : '' plural : '' version : '' func : get_cluster_custom_object module : chaosk8s.crd.probes type : python type : probe","title":"get_cluster_custom_object"},{"location":"drivers/kubernetes/#get_custom_object","text":"Type probe Module chaosk8s.crd.probes Name get_custom_object Return mapping Get a custom object in the given namespace. Read more about custom resources here: https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/ Signature: def get_custom_object ( group : str , version : str , plural : str , name : str , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required group string Yes version string Yes plural string Yes name string Yes ns string \u201cdefault\u201d No Usage: { \"name\" : \"get-custom-object\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.crd.probes\" , \"func\" : \"get_custom_object\" , \"arguments\" : { \"group\" : \"\" , \"version\" : \"\" , \"plural\" : \"\" , \"name\" : \"\" } } } name : get-custom-object provider : arguments : group : '' name : '' plural : '' version : '' func : get_custom_object module : chaosk8s.crd.probes type : python type : probe","title":"get_custom_object"},{"location":"drivers/kubernetes/#list_cluster_custom_objects","text":"Type probe Module chaosk8s.crd.probes Name list_cluster_custom_objects Return list List custom objects cluster-wide. Read more about custom resources here: https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/ Signature: def list_cluster_custom_objects ( group : str , version : str , plural : str , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required group string Yes version string Yes plural string Yes Usage: { \"name\" : \"list-cluster-custom-objects\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.crd.probes\" , \"func\" : \"list_cluster_custom_objects\" , \"arguments\" : { \"group\" : \"\" , \"version\" : \"\" , \"plural\" : \"\" } } } name : list-cluster-custom-objects provider : arguments : group : '' plural : '' version : '' func : list_cluster_custom_objects module : chaosk8s.crd.probes type : python type : probe","title":"list_cluster_custom_objects"},{"location":"drivers/kubernetes/#list_custom_objects","text":"Type probe Module chaosk8s.crd.probes Name list_custom_objects Return list List custom objects in the given namespace. Read more about custom resources here: https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/ Signature: def list_custom_objects ( group : str , version : str , plural : str , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required group string Yes version string Yes plural string Yes ns string \u201cdefault\u201d No Usage: { \"name\" : \"list-custom-objects\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.crd.probes\" , \"func\" : \"list_custom_objects\" , \"arguments\" : { \"group\" : \"\" , \"version\" : \"\" , \"plural\" : \"\" } } } name : list-custom-objects provider : arguments : group : '' plural : '' version : '' func : list_custom_objects module : chaosk8s.crd.probes type : python type : probe","title":"list_custom_objects"},{"location":"drivers/kubernetes/#patch_cluster_custom_object","text":"Type action Module chaosk8s.crd.actions Name patch_cluster_custom_object Return mapping Patch a custom object cluster-wide. The resource must be the updated version to apply. Force will re-acquire conflicting fields owned by others. Read more about custom resources here: https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/ Signature: def patch_cluster_custom_object ( group : str , version : str , plural : str , name : str , force : bool = False , resource : Dict [ str , Any ] = None , resource_as_yaml_file : str = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required group string Yes version string Yes plural string Yes name string Yes force boolean false No resource mapping null No resource_as_yaml_file string null No Usage: { \"name\" : \"patch-cluster-custom-object\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.crd.actions\" , \"func\" : \"patch_cluster_custom_object\" , \"arguments\" : { \"group\" : \"\" , \"version\" : \"\" , \"plural\" : \"\" , \"name\" : \"\" } } } name : patch-cluster-custom-object provider : arguments : group : '' name : '' plural : '' version : '' func : patch_cluster_custom_object module : chaosk8s.crd.actions type : python type : action","title":"patch_cluster_custom_object"},{"location":"drivers/kubernetes/#patch_custom_object","text":"Type action Module chaosk8s.crd.actions Name patch_custom_object Return mapping Patch a custom object in the given namespace. The resource must be the updated version to apply. Force will re-acquire conflicting fields owned by others. Read more about custom resources here: https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/ Signature: def patch_custom_object ( group : str , version : str , plural : str , name : str , ns : str = 'default' , force : bool = False , resource : Dict [ str , Any ] = None , resource_as_yaml_file : str = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required group string Yes version string Yes plural string Yes name string Yes ns string \u201cdefault\u201d No force boolean false No resource mapping null No resource_as_yaml_file string null No Usage: { \"name\" : \"patch-custom-object\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.crd.actions\" , \"func\" : \"patch_custom_object\" , \"arguments\" : { \"group\" : \"\" , \"version\" : \"\" , \"plural\" : \"\" , \"name\" : \"\" } } } name : patch-custom-object provider : arguments : group : '' name : '' plural : '' version : '' func : patch_custom_object module : chaosk8s.crd.actions type : python type : action","title":"patch_custom_object"},{"location":"drivers/kubernetes/#replace_cluster_custom_object","text":"Type action Module chaosk8s.crd.actions Name replace_cluster_custom_object Return mapping Replace a custom object in the given namespace. The resource must be the new version to apply. Read more about custom resources here: https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/ Signature: def replace_cluster_custom_object ( group : str , version : str , plural : str , name : str , force : bool = False , resource : Dict [ str , Any ] = None , resource_as_yaml_file : str = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required group string Yes version string Yes plural string Yes name string Yes force boolean false No resource mapping null No resource_as_yaml_file string null No Usage: { \"name\" : \"replace-cluster-custom-object\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.crd.actions\" , \"func\" : \"replace_cluster_custom_object\" , \"arguments\" : { \"group\" : \"\" , \"version\" : \"\" , \"plural\" : \"\" , \"name\" : \"\" } } } name : replace-cluster-custom-object provider : arguments : group : '' name : '' plural : '' version : '' func : replace_cluster_custom_object module : chaosk8s.crd.actions type : python type : action","title":"replace_cluster_custom_object"},{"location":"drivers/kubernetes/#replace_custom_object","text":"Type action Module chaosk8s.crd.actions Name replace_custom_object Return mapping Replace a custom object in the given namespace. The resource must be the new version to apply. Read more about custom resources here: https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/ Signature: def replace_custom_object ( group : str , version : str , plural : str , name : str , ns : str = 'default' , force : bool = False , resource : Dict [ str , Any ] = None , resource_as_yaml_file : str = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required group string Yes version string Yes plural string Yes name string Yes ns string \u201cdefault\u201d No force boolean false No resource mapping null No resource_as_yaml_file string null No Usage: { \"name\" : \"replace-custom-object\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.crd.actions\" , \"func\" : \"replace_custom_object\" , \"arguments\" : { \"group\" : \"\" , \"version\" : \"\" , \"plural\" : \"\" , \"name\" : \"\" } } } name : replace-custom-object provider : arguments : group : '' name : '' plural : '' version : '' func : replace_custom_object module : chaosk8s.crd.actions type : python type : action","title":"replace_custom_object"},{"location":"drivers/kubernetes/#deployment","text":"","title":"deployment"},{"location":"drivers/kubernetes/#create_deployment","text":"Type action Module chaosk8s.deployment.actions Name create_deployment Return None Create a deployment described by the deployment config, which must be the path to the JSON or YAML representation of the deployment. Signature: def create_deployment ( spec_path : str , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required spec_path string Yes ns string \u201cdefault\u201d No Usage: { \"name\" : \"create-deployment\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.deployment.actions\" , \"func\" : \"create_deployment\" , \"arguments\" : { \"spec_path\" : \"\" } } } name : create-deployment provider : arguments : spec_path : '' func : create_deployment module : chaosk8s.deployment.actions type : python type : action","title":"create_deployment"},{"location":"drivers/kubernetes/#delete_deployment","text":"Type action Module chaosk8s.deployment.actions Name delete_deployment Return None Delete a deployment by name in the namespace ns . The deployment is deleted without a graceful period to trigger an abrupt termination. The selected resources are matched by the given label_selector . Signature: def delete_deployment ( name : str , ns : str = 'default' , label_selector : str = 'name in ( {name} )' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string \u201cname in ({name})\u201d No Usage: { \"name\" : \"delete-deployment\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.deployment.actions\" , \"func\" : \"delete_deployment\" , \"arguments\" : { \"name\" : \"\" } } } name : delete-deployment provider : arguments : name : '' func : delete_deployment module : chaosk8s.deployment.actions type : python type : action","title":"delete_deployment"},{"location":"drivers/kubernetes/#deployment_available_and_healthy","text":"Type probe Module chaosk8s.deployment.probes Name deployment_available_and_healthy Return Union[bool, NoneType] Lookup a deployment by name in the namespace ns . The selected resources are matched by the given label_selector . Raises :exc: chaoslib.exceptions.ActivityFailed when the state is not as expected. Signature: def deployment_available_and_healthy ( name : str , ns : str = 'default' , label_selector : str = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Union [ bool , NoneType ]: pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string null No Usage: { \"name\" : \"deployment-available-and-healthy\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.deployment.probes\" , \"func\" : \"deployment_available_and_healthy\" , \"arguments\" : { \"name\" : \"\" } } } name : deployment-available-and-healthy provider : arguments : name : '' func : deployment_available_and_healthy module : chaosk8s.deployment.probes type : python type : probe","title":"deployment_available_and_healthy"},{"location":"drivers/kubernetes/#deployment_fully_available","text":"Type probe Module chaosk8s.deployment.probes Name deployment_fully_available Return Union[bool, NoneType] Wait until all the deployment expected replicas are available. Once this state is reached, return True . If the state is not reached after timeout seconds, a :exc: chaoslib.exceptions.ActivityFailed exception is raised. Signature: def deployment_fully_available ( name : str , ns : str = 'default' , label_selector : str = None , timeout : int = 30 , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Union [ bool , NoneType ]: pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string null No timeout integer 30 No Usage: { \"name\" : \"deployment-fully-available\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.deployment.probes\" , \"func\" : \"deployment_fully_available\" , \"arguments\" : { \"name\" : \"\" } } } name : deployment-fully-available provider : arguments : name : '' func : deployment_fully_available module : chaosk8s.deployment.probes type : python type : probe","title":"deployment_fully_available"},{"location":"drivers/kubernetes/#deployment_not_fully_available","text":"Type probe Module chaosk8s.deployment.probes Name deployment_not_fully_available Return Union[bool, NoneType] Wait until the deployment gets into an intermediate state where not all expected replicas are available. Once this state is reached, return True . If the state is not reached after timeout seconds, a :exc: chaoslib.exceptions.ActivityFailed exception is raised. Signature: def deployment_not_fully_available ( name : str , ns : str = 'default' , label_selector : str = None , timeout : int = 30 , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Union [ bool , NoneType ]: pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string null No timeout integer 30 No Usage: { \"name\" : \"deployment-not-fully-available\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.deployment.probes\" , \"func\" : \"deployment_not_fully_available\" , \"arguments\" : { \"name\" : \"\" } } } name : deployment-not-fully-available provider : arguments : name : '' func : deployment_not_fully_available module : chaosk8s.deployment.probes type : python type : probe","title":"deployment_not_fully_available"},{"location":"drivers/kubernetes/#scale_deployment","text":"Type action Module chaosk8s.deployment.actions Name scale_deployment Return None Scale a deployment up or down. The name is the name of the deployment. Signature: def scale_deployment ( name : str , replicas : int , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes replicas integer Yes ns string \u201cdefault\u201d No Usage: { \"name\" : \"scale-deployment\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.deployment.actions\" , \"func\" : \"scale_deployment\" , \"arguments\" : { \"name\" : \"\" , \"replicas\" : 0 } } } name : scale-deployment provider : arguments : name : '' replicas : 0 func : scale_deployment module : chaosk8s.deployment.actions type : python type : action","title":"scale_deployment"},{"location":"drivers/kubernetes/#networking","text":"","title":"networking"},{"location":"drivers/kubernetes/#allow_dns_access","text":"Type action Module chaosk8s.networking.actions Name allow_dns_access Return None Convenient helper rule to DNS access from all pods in a namespace, unless `label_selectors, in which case, only matching pods will be impacted. Signature: def allow_dns_access ( label_selectors : Dict [ str , Any ] = None , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required label_selectors mapping null No ns string \u201cdefault\u201d No Usage: { \"name\" : \"allow-dns-access\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.networking.actions\" , \"func\" : \"allow_dns_access\" } } name : allow-dns-access provider : func : allow_dns_access module : chaosk8s.networking.actions type : python type : action","title":"allow_dns_access"},{"location":"drivers/kubernetes/#create_network_policy","text":"Type action Module chaosk8s.networking.actions Name create_network_policy Return None Create a network policy in the given namespace eitehr from the definition as spec or from a file containing the definition at spec_path . Signature: def create_network_policy ( spec : Dict [ str , Any ] = None , spec_path : str = None , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required spec mapping null No spec_path string null No ns string \u201cdefault\u201d No Usage: { \"name\" : \"create-network-policy\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.networking.actions\" , \"func\" : \"create_network_policy\" } } name : create-network-policy provider : func : create_network_policy module : chaosk8s.networking.actions type : python type : action","title":"create_network_policy"},{"location":"drivers/kubernetes/#deny_all_egress","text":"Type action Module chaosk8s.networking.actions Name deny_all_egress Return None Convenient helper rule to deny all egress network from all pods in a namespace, unless `label_selectors, in which case, only matching pods will be impacted. Signature: def deny_all_egress ( label_selectors : Dict [ str , Any ] = None , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required label_selectors mapping null No ns string \u201cdefault\u201d No Usage: { \"name\" : \"deny-all-egress\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.networking.actions\" , \"func\" : \"deny_all_egress\" } } name : deny-all-egress provider : func : deny_all_egress module : chaosk8s.networking.actions type : python type : action","title":"deny_all_egress"},{"location":"drivers/kubernetes/#deny_all_ingress","text":"Type action Module chaosk8s.networking.actions Name deny_all_ingress Return None Convenient helper policy to deny ingress network to all pods in a namespace, unless `label_selectors, in which case, only matching pods will be impacted. Signature: def deny_all_ingress ( label_selectors : Dict [ str , Any ] = None , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required label_selectors mapping null No ns string \u201cdefault\u201d No Usage: { \"name\" : \"deny-all-ingress\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.networking.actions\" , \"func\" : \"deny_all_ingress\" } } name : deny-all-ingress provider : func : deny_all_ingress module : chaosk8s.networking.actions type : python type : action","title":"deny_all_ingress"},{"location":"drivers/kubernetes/#remove_allow_dns_access","text":"Type action Module chaosk8s.networking.actions Name remove_allow_dns_access Return None Remove the rule set by the allow_dns_access action. Signature: def remove_allow_dns_access ( ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required ns string \u201cdefault\u201d No Usage: { \"name\" : \"remove-allow-dns-access\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.networking.actions\" , \"func\" : \"remove_allow_dns_access\" } } name : remove-allow-dns-access provider : func : remove_allow_dns_access module : chaosk8s.networking.actions type : python type : action","title":"remove_allow_dns_access"},{"location":"drivers/kubernetes/#remove_deny_all_egress","text":"Type action Module chaosk8s.networking.actions Name remove_deny_all_egress Return None Remove the rule set by the deny_all_egress action. Signature: def remove_deny_all_egress ( ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required ns string \u201cdefault\u201d No Usage: { \"name\" : \"remove-deny-all-egress\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.networking.actions\" , \"func\" : \"remove_deny_all_egress\" } } name : remove-deny-all-egress provider : func : remove_deny_all_egress module : chaosk8s.networking.actions type : python type : action","title":"remove_deny_all_egress"},{"location":"drivers/kubernetes/#remove_deny_all_ingress","text":"Type action Module chaosk8s.networking.actions Name remove_deny_all_ingress Return None Remove the rule set by the deny_all_ingress action. Signature: def remove_deny_all_ingress ( ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required ns string \u201cdefault\u201d No Usage: { \"name\" : \"remove-deny-all-ingress\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.networking.actions\" , \"func\" : \"remove_deny_all_ingress\" } } name : remove-deny-all-ingress provider : func : remove_deny_all_ingress module : chaosk8s.networking.actions type : python type : action","title":"remove_deny_all_ingress"},{"location":"drivers/kubernetes/#remove_network_policy","text":"Type action Module chaosk8s.networking.actions Name remove_network_policy Return None Create a network policy in the given namespace eitehr from the definition as spec or from a file containing the definition at spec_path . Signature: def remove_network_policy ( name : str , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No Usage: { \"name\" : \"remove-network-policy\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.networking.actions\" , \"func\" : \"remove_network_policy\" , \"arguments\" : { \"name\" : \"\" } } } name : remove-network-policy provider : arguments : name : '' func : remove_network_policy module : chaosk8s.networking.actions type : python type : action","title":"remove_network_policy"},{"location":"drivers/kubernetes/#node","text":"","title":"node"},{"location":"drivers/kubernetes/#cordon_node","text":"Type action Module chaosk8s.node.actions Name cordon_node Return None Cordon nodes matching the given label or name, so that no pods are scheduled on them any longer. Signature: def cordon_node ( name : str = None , label_selector : str = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string null No label_selector string null No Usage: { \"name\" : \"cordon-node\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.node.actions\" , \"func\" : \"cordon_node\" } } name : cordon-node provider : func : cordon_node module : chaosk8s.node.actions type : python type : action","title":"cordon_node"},{"location":"drivers/kubernetes/#create_node","text":"Type action Module chaosk8s.node.actions Name create_node Return kubernetes.client.models.v1_node.V1Node Create one new node in the cluster. Due to the way things work on certain cloud providers, you won\u2019t be able to use this meaningfully on them. For instance on GCE, this will likely fail. See also: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#idempotency Signature: def create_node ( meta : Dict [ str , Any ] = None , spec : Dict [ str , Any ] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> kubernetes . client . models . v1_node . V1Node : pass Arguments: Name Type Default Required meta mapping null No spec mapping null No Usage: { \"name\" : \"create-node\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.node.actions\" , \"func\" : \"create_node\" } } name : create-node provider : func : create_node module : chaosk8s.node.actions type : python type : action","title":"create_node"},{"location":"drivers/kubernetes/#delete_nodes","text":"Type action Module chaosk8s.node.actions Name delete_nodes Return None Delete nodes gracefully. Select the appropriate nodes by label. Nodes are not drained beforehand so we can see how cluster behaves. Nodes cannot be restarted, they are really deleted. Please be careful when using this action. On certain cloud providers, you also need to delete the underneath VM instance as well afterwards. This is the case on GCE for instance. If all is set to True , all nodes will be terminated. If rand is set to True , one random node will be terminated. If \u0300 count is set to a positive number, only a upto count nodes (randomly picked) will be terminated. Otherwise, the first retrieved node will be terminated. Signature: def delete_nodes ( label_selector : str = None , all : bool = False , rand : bool = False , count : int = None , grace_period_seconds : int = None , secrets : Dict [ str , Dict [ str , str ]] = None , pod_label_selector : str = None , pod_namespace : str = None ): pass Arguments: Name Type Default Required label_selector string null No all boolean false No rand boolean false No count integer null No grace_period_seconds integer null No pod_label_selector string null No pod_namespace string null No Usage: { \"name\" : \"delete-nodes\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.node.actions\" , \"func\" : \"delete_nodes\" } } name : delete-nodes provider : func : delete_nodes module : chaosk8s.node.actions type : python type : action","title":"delete_nodes"},{"location":"drivers/kubernetes/#drain_nodes","text":"Type action Module chaosk8s.node.actions Name drain_nodes Return boolean Drain nodes matching the given label or name, so that no pods are scheduled on them any longer and running pods are evicted. It does a similar job to kubectl drain --ignore-daemonsets or kubectl drain --delete-local-data --ignore-daemonsets if delete_pods_with_local_storage is set to True . There is no equivalent to the kubectl drain --force flag. You probably want to call uncordon from in your experiment\u2019s rollbacks. Signature: def drain_nodes ( name : str = None , label_selector : str = None , delete_pods_with_local_storage : bool = False , timeout : int = 120 , secrets : Dict [ str , Dict [ str , str ]] = None , count : int = None , pod_label_selector : str = None , pod_namespace : str = None ) -> bool : pass Arguments: Name Type Default Required name string null No label_selector string null No delete_pods_with_local_storage boolean false No timeout integer 120 No count integer null No pod_label_selector string null No pod_namespace string null No Usage: { \"name\" : \"drain-nodes\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.node.actions\" , \"func\" : \"drain_nodes\" } } name : drain-nodes provider : func : drain_nodes module : chaosk8s.node.actions type : python type : action","title":"drain_nodes"},{"location":"drivers/kubernetes/#get_nodes","text":"Type probe Module chaosk8s.node.probes Name get_nodes Return None List all Kubernetes worker nodes in your cluster. You may filter nodes by specifying a label selector. Signature: def get_nodes ( label_selector : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required label_selector string null No Usage: { \"name\" : \"get-nodes\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.node.probes\" , \"func\" : \"get_nodes\" } } name : get-nodes provider : func : get_nodes module : chaosk8s.node.probes type : python type : probe","title":"get_nodes"},{"location":"drivers/kubernetes/#uncordon_node","text":"Type action Module chaosk8s.node.actions Name uncordon_node Return None Uncordon nodes matching the given label name, so that pods can be scheduled on them again. Signature: def uncordon_node ( name : str = None , label_selector : str = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string null No label_selector string null No Usage: { \"name\" : \"uncordon-node\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.node.actions\" , \"func\" : \"uncordon_node\" } } name : uncordon-node provider : func : uncordon_node module : chaosk8s.node.actions type : python type : action","title":"uncordon_node"},{"location":"drivers/kubernetes/#pod","text":"","title":"pod"},{"location":"drivers/kubernetes/#count_pods","text":"Type probe Module chaosk8s.pod.probes Name count_pods Return integer Count the number of pods matching the given selector in a given phase , if one is given. Signature: def count_pods ( label_selector : str , phase : str = None , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required label_selector string Yes phase string null No ns string \u201cdefault\u201d No Usage: { \"name\" : \"count-pods\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.pod.probes\" , \"func\" : \"count_pods\" , \"arguments\" : { \"label_selector\" : \"\" } } } name : count-pods provider : arguments : label_selector : '' func : count_pods module : chaosk8s.pod.probes type : python type : probe","title":"count_pods"},{"location":"drivers/kubernetes/#delete_pods","text":"Type action Module chaosk8s.pod.actions Name delete_pods Return None Delete pods by name in the namespace ns . The pods are deleted without a graceful period to trigger an abrupt termination. The selected resources are matched by the given label_selector . Signature: def delete_pods ( name : str , ns : str = 'default' , label_selector : str = 'name in ( {name} )' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string \u201cname in ({name})\u201d No Usage: { \"name\" : \"delete-pods\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.pod.actions\" , \"func\" : \"delete_pods\" , \"arguments\" : { \"name\" : \"\" } } } name : delete-pods provider : arguments : name : '' func : delete_pods module : chaosk8s.pod.actions type : python type : action","title":"delete_pods"},{"location":"drivers/kubernetes/#exec_in_pods","text":"Type action Module chaosk8s.pod.actions Name exec_in_pods Return list Execute the command cmd in the specified pod\u2019s container. Select the appropriate pods by label and/or name patterns. Whenever a pattern is provided for the name, all pods retrieved will be filtered out if their name do not match the given pattern. If neither label_selector nor name_pattern are provided, all pods in the namespace will be selected for termination. If all is set to True , all matching pods will be affected. Value of qty varies based on mode . If mode is set to fixed , then qty refers to number of pods affected. If mode is set to percentage , then qty refers to percentage of pods, from 1 to 100, to be affected. Default mode is fixed and default qty is 1 . If order is set to oldest , the retrieved pods will be ordered by the pods creation_timestamp, with the oldest pod first in list. If rand is set to True , n random pods will be affected Otherwise, the first retrieved n pods will be used Signature: def exec_in_pods ( cmd : str , label_selector : str = None , name_pattern : str = None , all : bool = False , rand : bool = False , mode : str = 'fixed' , qty : int = 1 , ns : str = 'default' , order : str = 'alphabetic' , container_name : str = None , request_timeout : int = 60 , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict [ str , Any ]]: pass Arguments: Name Type Default Required cmd string Yes label_selector string null No name_pattern string null No all boolean false No rand boolean false No mode string \u201cfixed\u201d No qty integer 1 No ns string \u201cdefault\u201d No order string \u201calphabetic\u201d No container_name string null No request_timeout integer 60 No Usage: { \"name\" : \"exec-in-pods\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.pod.actions\" , \"func\" : \"exec_in_pods\" , \"arguments\" : { \"cmd\" : \"\" } } } name : exec-in-pods provider : arguments : cmd : '' func : exec_in_pods module : chaosk8s.pod.actions type : python type : action","title":"exec_in_pods"},{"location":"drivers/kubernetes/#pod_is_not_available","text":"Type probe Module chaosk8s.pod.probes Name pod_is_not_available Return boolean Lookup pods with a name label set to the given name in the specified ns . Raises :exc: chaoslib.exceptions.ActivityFailed when one of the pods with the specified name is in the \"Running\" phase. Signature: def pod_is_not_available ( name : str , ns : str = 'default' , label_selector : str = 'name in ( {name} )' , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string \u201cname in ({name})\u201d No Usage: { \"name\" : \"pod-is-not-available\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.pod.probes\" , \"func\" : \"pod_is_not_available\" , \"arguments\" : { \"name\" : \"\" } } } name : pod-is-not-available provider : arguments : name : '' func : pod_is_not_available module : chaosk8s.pod.probes type : python type : probe","title":"pod_is_not_available"},{"location":"drivers/kubernetes/#pods_in_conditions","text":"Type probe Module chaosk8s.pod.probes Name pods_in_conditions Return boolean Lookup a pod by label_selector in the namespace ns . Raises :exc: chaoslib.exceptions.ActivityFailed if one of the given conditions type/status is not as expected Signature: def pods_in_conditions ( label_selector : str , conditions : List [ Dict [ str , str ]], ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required label_selector string Yes conditions list Yes ns string \u201cdefault\u201d No Usage: { \"name\" : \"pods-in-conditions\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.pod.probes\" , \"func\" : \"pods_in_conditions\" , \"arguments\" : { \"label_selector\" : \"\" , \"conditions\" : [] } } } name : pods-in-conditions provider : arguments : conditions : [] label_selector : '' func : pods_in_conditions module : chaosk8s.pod.probes type : python type : probe","title":"pods_in_conditions"},{"location":"drivers/kubernetes/#pods_in_phase","text":"Type probe Module chaosk8s.pod.probes Name pods_in_phase Return boolean Lookup a pod by label_selector in the namespace ns . Raises :exc: chaoslib.exceptions.ActivityFailed when the state is not as expected. Signature: def pods_in_phase ( label_selector : str , phase : str = 'Running' , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required label_selector string Yes phase string \u201cRunning\u201d No ns string \u201cdefault\u201d No Usage: { \"name\" : \"pods-in-phase\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.pod.probes\" , \"func\" : \"pods_in_phase\" , \"arguments\" : { \"label_selector\" : \"\" } } } name : pods-in-phase provider : arguments : label_selector : '' func : pods_in_phase module : chaosk8s.pod.probes type : python type : probe","title":"pods_in_phase"},{"location":"drivers/kubernetes/#pods_not_in_phase","text":"Type probe Module chaosk8s.pod.probes Name pods_not_in_phase Return boolean Lookup a pod by label_selector in the namespace ns . Raises :exc: chaoslib.exceptions.ActivityFailed when the pod is in the given phase and should not have. Signature: def pods_not_in_phase ( label_selector : str , phase : str = 'Running' , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required label_selector string Yes phase string \u201cRunning\u201d No ns string \u201cdefault\u201d No Usage: { \"name\" : \"pods-not-in-phase\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.pod.probes\" , \"func\" : \"pods_not_in_phase\" , \"arguments\" : { \"label_selector\" : \"\" } } } name : pods-not-in-phase provider : arguments : label_selector : '' func : pods_not_in_phase module : chaosk8s.pod.probes type : python type : probe","title":"pods_not_in_phase"},{"location":"drivers/kubernetes/#read_pod_logs","text":"Type probe Module chaosk8s.pod.probes Name read_pod_logs Return mapping Fetch logs for all the pods with the label \"name\" set to name and return a dictionary with the keys being the pod\u2019s name and the values the logs of said pod. If name is not provided, use only the label_selector instead. When your pod has several containers, you should also set container_name to clarify which container you want to read logs from. If you provide last , this returns the logs of the last N seconds until now. This can set to a fluent delta such as 10 minutes . You may also set from_previous to True to capture the logs of a previous pod\u2019s incarnation, if any. Signature: def read_pod_logs ( name : str = None , last : Union [ str , NoneType ] = None , ns : str = 'default' , from_previous : bool = False , label_selector : str = 'name in ( {name} )' , container_name : str = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , str ]: pass Arguments: Name Type Default Required name string null No last object null No ns string \u201cdefault\u201d No from_previous boolean false No label_selector string \u201cname in ({name})\u201d No container_name string null No Usage: { \"name\" : \"read-pod-logs\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.pod.probes\" , \"func\" : \"read_pod_logs\" } } name : read-pod-logs provider : func : read_pod_logs module : chaosk8s.pod.probes type : python type : probe","title":"read_pod_logs"},{"location":"drivers/kubernetes/#terminate_pods","text":"Type action Module chaosk8s.pod.actions Name terminate_pods Return None Terminate a pod gracefully. Select the appropriate pods by label and/or name patterns. Whenever a pattern is provided for the name, all pods retrieved will be filtered out if their name do not match the given pattern. If neither label_selector nor name_pattern are provided, all pods in the namespace will be selected for termination. If all is set to True , all matching pods will be terminated. Value of qty varies based on mode . If mode is set to fixed , then qty refers to number of pods to be terminated. If mode is set to percentage , then qty refers to percentage of pods, from 1 to 100, to be terminated. Default mode is fixed and default qty is 1 . If order is set to oldest , the retrieved pods will be ordered by the pods creation_timestamp, with the oldest pod first in list. If rand is set to True , n random pods will be terminated Otherwise, the first retrieved n pods will be terminated. If grace_period is greater than or equal to 0, it will be used as the grace period (in seconds) to terminate the pods. Otherwise, the default pod\u2019s grace period will be used. Signature: def terminate_pods ( label_selector : str = None , name_pattern : str = None , all : bool = False , rand : bool = False , mode : str = 'fixed' , qty : int = 1 , grace_period : int = - 1 , ns : str = 'default' , order : str = 'alphabetic' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required label_selector string null No name_pattern string null No all boolean false No rand boolean false No mode string \u201cfixed\u201d No qty integer 1 No grace_period integer -1 No ns string \u201cdefault\u201d No order string \u201calphabetic\u201d No Usage: { \"name\" : \"terminate-pods\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.pod.actions\" , \"func\" : \"terminate_pods\" } } name : terminate-pods provider : func : terminate_pods module : chaosk8s.pod.actions type : python type : action","title":"terminate_pods"},{"location":"drivers/kubernetes/#probes","text":"","title":"probes"},{"location":"drivers/kubernetes/#all_microservices_healthy","text":"Type probe Module chaosk8s.probes Name all_microservices_healthy Return Tuple[Dict[str, Any], Dict[str, Any]] !!!DEPRECATED!!! Signature: def all_microservices_healthy ( ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Tuple [ Dict [ str , Any ], Dict [ str , Any ]]: pass Arguments: Name Type Default Required ns string \u201cdefault\u201d No Usage: { \"name\" : \"all-microservices-healthy\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.probes\" , \"func\" : \"all_microservices_healthy\" } } name : all-microservices-healthy provider : func : all_microservices_healthy module : chaosk8s.probes type : python type : probe","title":"all_microservices_healthy"},{"location":"drivers/kubernetes/#deployment_is_fully_available","text":"Type probe Module chaosk8s.probes Name deployment_is_fully_available Return None !!!DEPRECATED!!! Signature: def deployment_is_fully_available ( name : str , ns : str = 'default' , label_selector : str = None , timeout : int = 30 , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string null No timeout integer 30 No Usage: { \"name\" : \"deployment-is-fully-available\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.probes\" , \"func\" : \"deployment_is_fully_available\" , \"arguments\" : { \"name\" : \"\" } } } name : deployment-is-fully-available provider : arguments : name : '' func : deployment_is_fully_available module : chaosk8s.probes type : python type : probe","title":"deployment_is_fully_available"},{"location":"drivers/kubernetes/#deployment_is_not_fully_available","text":"Type probe Module chaosk8s.probes Name deployment_is_not_fully_available Return None !!!DEPRECATED!!! Signature: def deployment_is_not_fully_available ( name : str , ns : str = 'default' , label_selector : str = None , timeout : int = 30 , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string null No timeout integer 30 No Usage: { \"name\" : \"deployment-is-not-fully-available\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.probes\" , \"func\" : \"deployment_is_not_fully_available\" , \"arguments\" : { \"name\" : \"\" } } } name : deployment-is-not-fully-available provider : arguments : name : '' func : deployment_is_not_fully_available module : chaosk8s.probes type : python type : probe","title":"deployment_is_not_fully_available"},{"location":"drivers/kubernetes/#microservice_available_and_healthy","text":"Type probe Module chaosk8s.probes Name microservice_available_and_healthy Return Union[bool, NoneType] !!!DEPRECATED!!! Signature: def microservice_available_and_healthy ( name : str , ns : str = 'default' , label_selector : str = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Union [ bool , NoneType ]: pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string null No Usage: { \"name\" : \"microservice-available-and-healthy\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.probes\" , \"func\" : \"microservice_available_and_healthy\" , \"arguments\" : { \"name\" : \"\" } } } name : microservice-available-and-healthy provider : arguments : name : '' func : microservice_available_and_healthy module : chaosk8s.probes type : python type : probe","title":"microservice_available_and_healthy"},{"location":"drivers/kubernetes/#microservice_is_not_available","text":"Type probe Module chaosk8s.probes Name microservice_is_not_available Return boolean !!!DEPRECATED!!! Signature: def microservice_is_not_available ( name : str , ns : str = 'default' , label_selector : str = 'name in ( {name} )' , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string \u201cname in ({name})\u201d No Usage: { \"name\" : \"microservice-is-not-available\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.probes\" , \"func\" : \"microservice_is_not_available\" , \"arguments\" : { \"name\" : \"\" } } } name : microservice-is-not-available provider : arguments : name : '' func : microservice_is_not_available module : chaosk8s.probes type : python type : probe","title":"microservice_is_not_available"},{"location":"drivers/kubernetes/#read_microservices_logs","text":"Type probe Module chaosk8s.probes Name read_microservices_logs Return mapping Fetch logs for all the pods with the label \"name\" set to name and return a dictionary with the keys being the pod\u2019s name and the values the logs of said pod. If name is not provided, use only the label_selector instead. When your pod has several containers, you should also set container_name to clarify which container you want to read logs from. If you provide last , this returns the logs of the last N seconds until now. This can set to a fluent delta such as 10 minutes . You may also set from_previous to True to capture the logs of a previous pod\u2019s incarnation, if any. Signature: def read_microservices_logs ( name : str = None , last : Union [ str , NoneType ] = None , ns : str = 'default' , from_previous : bool = False , label_selector : str = 'name in ( {name} )' , container_name : str = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , str ]: pass Arguments: Name Type Default Required name string null No last object null No ns string \u201cdefault\u201d No from_previous boolean false No label_selector string \u201cname in ({name})\u201d No container_name string null No Usage: { \"name\" : \"read-microservices-logs\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.probes\" , \"func\" : \"read_microservices_logs\" } } name : read-microservices-logs provider : func : read_microservices_logs module : chaosk8s.probes type : python type : probe","title":"read_microservices_logs"},{"location":"drivers/kubernetes/#service_endpoint_is_initialized","text":"Type probe Module chaosk8s.probes Name service_endpoint_is_initialized Return None !!!DEPRECATED!!! Signature: def service_endpoint_is_initialized ( name : str , ns : str = 'default' , label_selector : str = 'name in ( {name} )' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string \u201cname in ({name})\u201d No Usage: { \"name\" : \"service-endpoint-is-initialized\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.probes\" , \"func\" : \"service_endpoint_is_initialized\" , \"arguments\" : { \"name\" : \"\" } } } name : service-endpoint-is-initialized provider : arguments : name : '' func : service_endpoint_is_initialized module : chaosk8s.probes type : python type : probe","title":"service_endpoint_is_initialized"},{"location":"drivers/kubernetes/#replicaset","text":"","title":"replicaset"},{"location":"drivers/kubernetes/#delete_replica_set","text":"Type action Module chaosk8s.replicaset.actions Name delete_replica_set Return None Delete a replica set by name in the namespace ns . The replica set is deleted without a graceful period to trigger an abrupt termination. The selected resources are matched by the given label_selector . Signature: def delete_replica_set ( name : str , ns : str = 'default' , label_selector : str = 'name in ( {name} )' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string \u201cname in ({name})\u201d No Usage: { \"name\" : \"delete-replica-set\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.replicaset.actions\" , \"func\" : \"delete_replica_set\" , \"arguments\" : { \"name\" : \"\" } } } name : delete-replica-set provider : arguments : name : '' func : delete_replica_set module : chaosk8s.replicaset.actions type : python type : action","title":"delete_replica_set"},{"location":"drivers/kubernetes/#service","text":"","title":"service"},{"location":"drivers/kubernetes/#create_service_endpoint","text":"Type action Module chaosk8s.service.actions Name create_service_endpoint Return None Create a service endpoint described by the service config, which must be the path to the JSON or YAML representation of the service. Signature: def create_service_endpoint ( spec_path : str , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required spec_path string Yes ns string \u201cdefault\u201d No Usage: { \"name\" : \"create-service-endpoint\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.service.actions\" , \"func\" : \"create_service_endpoint\" , \"arguments\" : { \"spec_path\" : \"\" } } } name : create-service-endpoint provider : arguments : spec_path : '' func : create_service_endpoint module : chaosk8s.service.actions type : python type : action","title":"create_service_endpoint"},{"location":"drivers/kubernetes/#delete_service","text":"Type action Module chaosk8s.service.actions Name delete_service Return None Remove the given service Signature: def delete_service ( name : str , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No Usage: { \"name\" : \"delete-service\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.service.actions\" , \"func\" : \"delete_service\" , \"arguments\" : { \"name\" : \"\" } } } name : delete-service provider : arguments : name : '' func : delete_service module : chaosk8s.service.actions type : python type : action","title":"delete_service"},{"location":"drivers/kubernetes/#service_is_initialized","text":"Type probe Module chaosk8s.service.probes Name service_is_initialized Return boolean Lookup a service endpoint by its name and raises :exc: FailedProbe when the service was not found or not initialized. Signature: def service_is_initialized ( name : str = None , ns : str = 'default' , label_selector : str = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required name string null No ns string \u201cdefault\u201d No label_selector string null No Usage: { \"name\" : \"service-is-initialized\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.service.probes\" , \"func\" : \"service_is_initialized\" } } name : service-is-initialized provider : func : service_is_initialized module : chaosk8s.service.probes type : python type : probe","title":"service_is_initialized"},{"location":"drivers/kubernetes/#statefulset","text":"","title":"statefulset"},{"location":"drivers/kubernetes/#create_statefulset","text":"Type action Module chaosk8s.statefulset.actions Name create_statefulset Return None Create a statefulset described by the service config, which must be the path to the JSON or YAML representation of the statefulset. Signature: def create_statefulset ( spec_path : str , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required spec_path string Yes ns string \u201cdefault\u201d No Usage: { \"name\" : \"create-statefulset\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.statefulset.actions\" , \"func\" : \"create_statefulset\" , \"arguments\" : { \"spec_path\" : \"\" } } } name : create-statefulset provider : arguments : spec_path : '' func : create_statefulset module : chaosk8s.statefulset.actions type : python type : action","title":"create_statefulset"},{"location":"drivers/kubernetes/#remove_statefulset","text":"Type action Module chaosk8s.statefulset.actions Name remove_statefulset Return None Remove a statefulset by name in the namespace ns . The statefulset is removed by deleting it without a graceful period to trigger an abrupt termination. The selected resources are matched by the given label_selector . Signature: def remove_statefulset ( name : str = None , ns : str = 'default' , label_selector : str = None , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string null No ns string \u201cdefault\u201d No label_selector string null No Usage: { \"name\" : \"remove-statefulset\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.statefulset.actions\" , \"func\" : \"remove_statefulset\" } } name : remove-statefulset provider : func : remove_statefulset module : chaosk8s.statefulset.actions type : python type : action","title":"remove_statefulset"},{"location":"drivers/kubernetes/#scale_statefulset","text":"Type action Module chaosk8s.statefulset.actions Name scale_statefulset Return None Scale a stateful set up or down. The name is the name of the stateful set. Signature: def scale_statefulset ( name : str , replicas : int , ns : str = 'default' , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes replicas integer Yes ns string \u201cdefault\u201d No Usage: { \"name\" : \"scale-statefulset\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.statefulset.actions\" , \"func\" : \"scale_statefulset\" , \"arguments\" : { \"name\" : \"\" , \"replicas\" : 0 } } } name : scale-statefulset provider : arguments : name : '' replicas : 0 func : scale_statefulset module : chaosk8s.statefulset.actions type : python type : action","title":"scale_statefulset"},{"location":"drivers/kubernetes/#statefulset_fully_available","text":"Type probe Module chaosk8s.statefulset.probes Name statefulset_fully_available Return None Wait until all the statefulSet expected replicas are available. Once this state is reached, return True . If the state is not reached after timeout seconds, a :exc: chaoslib.exceptions.ActivityFailed exception is raised. Signature: def statefulset_fully_available ( name : str , ns : str = 'default' , label_selector : str = None , timeout : int = 30 , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string null No timeout integer 30 No Usage: { \"name\" : \"statefulset-fully-available\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.statefulset.probes\" , \"func\" : \"statefulset_fully_available\" , \"arguments\" : { \"name\" : \"\" } } } name : statefulset-fully-available provider : arguments : name : '' func : statefulset_fully_available module : chaosk8s.statefulset.probes type : python type : probe","title":"statefulset_fully_available"},{"location":"drivers/kubernetes/#statefulset_not_fully_available","text":"Type probe Module chaosk8s.statefulset.probes Name statefulset_not_fully_available Return None Wait until the statefulSet gets into an intermediate state where not all expected replicas are available. Once this state is reached, return True . If the state is not reached after timeout seconds, a :exc: chaoslib.exceptions.ActivityFailed exception is raised. Signature: def statefulset_not_fully_available ( name : str , ns : str = 'default' , label_selector : str = None , timeout : int = 30 , secrets : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required name string Yes ns string \u201cdefault\u201d No label_selector string null No timeout integer 30 No Usage: { \"name\" : \"statefulset-not-fully-available\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.statefulset.probes\" , \"func\" : \"statefulset_not_fully_available\" , \"arguments\" : { \"name\" : \"\" } } } name : statefulset-not-fully-available provider : arguments : name : '' func : statefulset_not_fully_available module : chaosk8s.statefulset.probes type : python type : probe","title":"statefulset_not_fully_available"},{"location":"drivers/opentracing/","text":"Extension chaostracing \u00b6 Version 0.2.1 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-opentracing This project is an extension for the Chaos Toolkit for [OpenTracing 2][]. Here is an example of what it could look like with the Jaeger backend. Install \u00b6 This package requires Python 3.5+ To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install -U chaostoolkit-opentracing Usage \u00b6 Currently, this extension only provides control support to send traces to your provider during the execution of the experiment. It does not yet expose any probes or actions per-se. Declare within the experiment \u00b6 To use this control, you can declare it on a per experiment basis like this: { \"configuration\" : { \"tracing_provider\" : \"jaeger\" , \"tracing_host\" : \"127.0.0.1\" , \"tracing_port\" : 6831 , \"tracing_propagation\" : \"b3\" }, \"controls\" : [ { \"name\" : \"opentracing\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostracing.control\" } } ] } This will automatically create a Jaeger client to emit traces onto the address 127.0.0.1:6831 (over UDP). Declare within the settings \u00b6 You may also declare the control to be applied to all experiments by declaring the control from within the Chaos Toolkit settings file . In that case, you do not need to set the configuration or the controls at the experiment level and the control will be applied to every experiments you run. controls : opentracing : provider : type : python module : chaostracing.control arguments : provider : jaeger host : 127.0.0.1 port : 6831 propagation : b3 Send traces from other extensions \u00b6 You may also access the tracer from other extensions as follows. For instance, assuming you have an extension that makes a HTTP call you want to trace specifically, you could do this from your extension\u2019s code: from chaoslib import Configuration , Secrets import requests import opentracing def some_function ( configuration : Configuration , secrets : Secrets ): tracer = opentracing . global_tracer () scope = tracer . scope_manager . active parent = scope . span with tracer . start_span ( \"call-service1\" , child_of = parent ) as span : span . set_tag ( 'http.method' , 'GET' ) span . set_tag ( 'http.url' , url ) span . set_tag ( 'span.kind' , 'client' ) span . tracer . inject ( span , 'http_headers' , headers ) r = requests . get ( url , headers = headers ) span . set_tag ( 'http.status_code' , r . status_code ) Because the opentracing exposes a noop tracer when non has been initialized, it should be safe to have that code in your extensions without having to determine if the extension has been enabled in the experiment. Please note that, Open Tracing scope cannot be shared across threads (while spans can). So, when running this in a background activity, the tracer will not actually be set to the one that was initialized. Open Tracing Provider Support \u00b6 For now, only the Jaeger tracer is supported but other backends will be added as need be in the future. Jaeger tracer \u00b6 To install the necessary dependencies for the Jaeger tracer, please run: $ pip install -U jaeger-client~=4.1 Test \u00b6 To run the tests for the project execute the following: $ pytest Contribute \u00b6 If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. The Chaos Toolkit projects require all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR. Exported Controls \u00b6 This package exports controls covering the following phases of the execution of an experiment: Level Before After Experiment True True Steady-state Hypothesis True True Method True True Rollback True True Activities True True To use this control module, please add the following section to your experiment: { \"name\" : \"chaostracing\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostracing.control\" } } name : chaostracing provider : module : chaostracing.control type : python This block may also be enabled at any other level (steady-state hypothesis or activity) to focus only on that level. When enabled at the experiment level, by default, all sub-levels are also applied unless you set the automatic properties to false .","title":"Open Tracing"},{"location":"drivers/opentracing/#extension-chaostracing","text":"Version 0.2.1 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-opentracing This project is an extension for the Chaos Toolkit for [OpenTracing 2][]. Here is an example of what it could look like with the Jaeger backend.","title":"Extension chaostracing"},{"location":"drivers/opentracing/#install","text":"This package requires Python 3.5+ To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install -U chaostoolkit-opentracing","title":"Install"},{"location":"drivers/opentracing/#usage","text":"Currently, this extension only provides control support to send traces to your provider during the execution of the experiment. It does not yet expose any probes or actions per-se.","title":"Usage"},{"location":"drivers/opentracing/#declare-within-the-experiment","text":"To use this control, you can declare it on a per experiment basis like this: { \"configuration\" : { \"tracing_provider\" : \"jaeger\" , \"tracing_host\" : \"127.0.0.1\" , \"tracing_port\" : 6831 , \"tracing_propagation\" : \"b3\" }, \"controls\" : [ { \"name\" : \"opentracing\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostracing.control\" } } ] } This will automatically create a Jaeger client to emit traces onto the address 127.0.0.1:6831 (over UDP).","title":"Declare within the experiment"},{"location":"drivers/opentracing/#declare-within-the-settings","text":"You may also declare the control to be applied to all experiments by declaring the control from within the Chaos Toolkit settings file . In that case, you do not need to set the configuration or the controls at the experiment level and the control will be applied to every experiments you run. controls : opentracing : provider : type : python module : chaostracing.control arguments : provider : jaeger host : 127.0.0.1 port : 6831 propagation : b3","title":"Declare within the settings"},{"location":"drivers/opentracing/#send-traces-from-other-extensions","text":"You may also access the tracer from other extensions as follows. For instance, assuming you have an extension that makes a HTTP call you want to trace specifically, you could do this from your extension\u2019s code: from chaoslib import Configuration , Secrets import requests import opentracing def some_function ( configuration : Configuration , secrets : Secrets ): tracer = opentracing . global_tracer () scope = tracer . scope_manager . active parent = scope . span with tracer . start_span ( \"call-service1\" , child_of = parent ) as span : span . set_tag ( 'http.method' , 'GET' ) span . set_tag ( 'http.url' , url ) span . set_tag ( 'span.kind' , 'client' ) span . tracer . inject ( span , 'http_headers' , headers ) r = requests . get ( url , headers = headers ) span . set_tag ( 'http.status_code' , r . status_code ) Because the opentracing exposes a noop tracer when non has been initialized, it should be safe to have that code in your extensions without having to determine if the extension has been enabled in the experiment. Please note that, Open Tracing scope cannot be shared across threads (while spans can). So, when running this in a background activity, the tracer will not actually be set to the one that was initialized.","title":"Send traces from other extensions"},{"location":"drivers/opentracing/#open-tracing-provider-support","text":"For now, only the Jaeger tracer is supported but other backends will be added as need be in the future.","title":"Open Tracing Provider Support"},{"location":"drivers/opentracing/#jaeger-tracer","text":"To install the necessary dependencies for the Jaeger tracer, please run: $ pip install -U jaeger-client~=4.1","title":"Jaeger tracer"},{"location":"drivers/opentracing/#test","text":"To run the tests for the project execute the following: $ pytest","title":"Test"},{"location":"drivers/opentracing/#contribute","text":"If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. The Chaos Toolkit projects require all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR.","title":"Contribute"},{"location":"drivers/opentracing/#exported-controls","text":"This package exports controls covering the following phases of the execution of an experiment: Level Before After Experiment True True Steady-state Hypothesis True True Method True True Rollback True True Activities True True To use this control module, please add the following section to your experiment: { \"name\" : \"chaostracing\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostracing.control\" } } name : chaostracing provider : module : chaostracing.control type : python This block may also be enabled at any other level (steady-state hypothesis or activity) to focus only on that level. When enabled at the experiment level, by default, all sub-levels are also applied unless you set the automatic properties to false .","title":"Exported Controls"},{"location":"drivers/overview/","text":"Drivers Overview \u00b6 Chaos Toolkit drivers extend the toolkit to be able to cause chaos and probe different types of systems.","title":"Overview"},{"location":"drivers/overview/#drivers-overview","text":"Chaos Toolkit drivers extend the toolkit to be able to cause chaos and probe different types of systems.","title":"Drivers Overview"},{"location":"drivers/prometheus/","text":"Extension chaosprometheus \u00b6 Version 0.3.0 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-prometheus Prometheus support for the Chaos Toolkit . Install \u00b6 To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install chaostoolkit-prometheus Usage \u00b6 To use this package, you must create have access to a Prometheus instance via HTTP and be allowed to connect to it. This package only exports probes to query for some aspects of your system as monitored by Prometheus. Here is an example of querying Prometheus at a given moment { \"type\" : \"probe\" , \"name\" : \"fetch-cpu-just-2mn-ago\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosprometheus.probes\" , \"func\" : \"query\" , \"arguments\" : { \"query\" : \"process_cpu_seconds_total{job='websvc'}\" , \"when\" : \"2 minutes ago\" } } } You can also ask for an interval as follows: { \"type\" : \"probe\" , \"name\" : \"fetch-cpu-over-interval\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosprometheus.probes\" , \"func\" : \"query_interval\" , \"arguments\" : { \"query\" : \"process_cpu_seconds_total{job='websvc'}\" , \"start\" : \"2 minutes ago\" , \"end\" : \"now\" , \"step\" : 5 } } } In both cases, the probe returns the JSON payload as-is from Prometheus or raises an exception when an error is met. The result is not further process and should be found in the generated report of the experiment run. Contribute \u00b6 If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. Exported Activities \u00b6 probes \u00b6 query \u00b6 Type probe Module chaosprometheus.probes Name query Return mapping Run an instant query against a Prometheus server and returns its result as-is. Signature: def query ( query : str , when : str = None , timeout : float = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required query string Yes when string null No timeout number null No Usage: { \"name\" : \"query\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosprometheus.probes\" , \"func\" : \"query\" , \"arguments\" : { \"query\" : \"\" } } } name : query provider : arguments : query : '' func : query module : chaosprometheus.probes type : python type : probe query_interval \u00b6 Type probe Module chaosprometheus.probes Name query_interval Return mapping Run a range query against a Prometheus server and returns its result as-is. The start and end arguments can be a RFC 3339 date or expressed more colloquially such as \"5 minutes ago\" . Signature: def query_interval ( query : str , start : str , end : str , step : int = 1 , timeout : float = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required query string Yes start string Yes end string Yes step integer 1 No timeout number null No Usage: { \"name\" : \"query-interval\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosprometheus.probes\" , \"func\" : \"query_interval\" , \"arguments\" : { \"query\" : \"\" , \"start\" : \"\" , \"end\" : \"\" } } } name : query-interval provider : arguments : end : '' query : '' start : '' func : query_interval module : chaosprometheus.probes type : python type : probe","title":"Prometheus"},{"location":"drivers/prometheus/#extension-chaosprometheus","text":"Version 0.3.0 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-prometheus Prometheus support for the Chaos Toolkit .","title":"Extension chaosprometheus"},{"location":"drivers/prometheus/#install","text":"To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install chaostoolkit-prometheus","title":"Install"},{"location":"drivers/prometheus/#usage","text":"To use this package, you must create have access to a Prometheus instance via HTTP and be allowed to connect to it. This package only exports probes to query for some aspects of your system as monitored by Prometheus. Here is an example of querying Prometheus at a given moment { \"type\" : \"probe\" , \"name\" : \"fetch-cpu-just-2mn-ago\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosprometheus.probes\" , \"func\" : \"query\" , \"arguments\" : { \"query\" : \"process_cpu_seconds_total{job='websvc'}\" , \"when\" : \"2 minutes ago\" } } } You can also ask for an interval as follows: { \"type\" : \"probe\" , \"name\" : \"fetch-cpu-over-interval\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosprometheus.probes\" , \"func\" : \"query_interval\" , \"arguments\" : { \"query\" : \"process_cpu_seconds_total{job='websvc'}\" , \"start\" : \"2 minutes ago\" , \"end\" : \"now\" , \"step\" : 5 } } } In both cases, the probe returns the JSON payload as-is from Prometheus or raises an exception when an error is met. The result is not further process and should be found in the generated report of the experiment run.","title":"Usage"},{"location":"drivers/prometheus/#contribute","text":"If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review.","title":"Contribute"},{"location":"drivers/prometheus/#exported-activities","text":"","title":"Exported Activities"},{"location":"drivers/prometheus/#probes","text":"","title":"probes"},{"location":"drivers/prometheus/#query","text":"Type probe Module chaosprometheus.probes Name query Return mapping Run an instant query against a Prometheus server and returns its result as-is. Signature: def query ( query : str , when : str = None , timeout : float = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required query string Yes when string null No timeout number null No Usage: { \"name\" : \"query\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosprometheus.probes\" , \"func\" : \"query\" , \"arguments\" : { \"query\" : \"\" } } } name : query provider : arguments : query : '' func : query module : chaosprometheus.probes type : python type : probe","title":"query"},{"location":"drivers/prometheus/#query_interval","text":"Type probe Module chaosprometheus.probes Name query_interval Return mapping Run a range query against a Prometheus server and returns its result as-is. The start and end arguments can be a RFC 3339 date or expressed more colloquially such as \"5 minutes ago\" . Signature: def query_interval ( query : str , start : str , end : str , step : int = 1 , timeout : float = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required query string Yes start string Yes end string Yes step integer 1 No timeout number null No Usage: { \"name\" : \"query-interval\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosprometheus.probes\" , \"func\" : \"query_interval\" , \"arguments\" : { \"query\" : \"\" , \"start\" : \"\" , \"end\" : \"\" } } } name : query-interval provider : arguments : end : '' query : '' start : '' func : query_interval module : chaosprometheus.probes type : python type : probe","title":"query_interval"},{"location":"drivers/reliably/","text":"Extension chaosreliably \u00b6 Version 0.2.2 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-reliably Reliably support for the Chaos Toolkit . Install \u00b6 To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install chaostoolkit-reliably Authentication \u00b6 To use this package, you must create have registered with Reliably services through their CLI . You have two ways to pass on the credentials information. The first one by specifying the path to the Reliably\u2019s configuration file, which defaults to $HOME/.config/reliably/config.yaml . The simplest way to achieve this is by running $ reliably login as this will generate the appropriate file. { \"configuration\" : { \"reliably_config_path\" : \"~/.config/reliably/config.yaml\" } } Because we use the default path, you may omit this configuration\u2019s entry altogether unless you need a specific different path. The second one is by setting some environment variables as secrets. This is for specific use case and usually not required. RELIABLY_TOKEN : the token to authenticate against Reliably\u2019s API RELIABLY_ORG : the Reliably organisation to use RELIABLY_HOST: : the hostname to connect to, default to reliably.com { \"secrets\" : { \"reliably\" : { \"token\" : { \"type\" : \"env\" , \"key\" : \"RELIABLY_TOKEN\" }, \"org\" : { \"type\" : \"env\" , \"key\" : \"RELIABLY_ORG\" }, \"host\" : { \"type\" : \"env\" , \"key\" : \"RELIABLY_HOST\" , \"default\" : \"reliably.com\" } } } } Usage \u00b6 As Steady Steate Hypothesis \u00b6 You can use Reliably\u2019s SLO as a mechanism to determine if your system has deviated during a Chaos Toolkit experiment. Here is a simple example: \"steady-state-hypothesis\" : { \"title\" : \"We do not consume all of our error budgets during the experiment\" , \"probes\" : [ { \"name\" : \"Our 'Must be good' SLO results must be OK\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosreliably.slo.probes\" , \"func\" : \"slo_is_met\" , \"arguments\" : { \"labels\" : { \"name\" : \"must-be-good\" , \"service\" : \"must-be-good-service\" }, \"limit\" : 5 } }, \"tolerance\" : true , } ] } This above example will get the last 5 Objective Results for our Must be good SLO and determine if they were all okay or whether we\u2019ve spent our error budget they are allowed. As Safeguards \u00b6 Safeguards, provided by the Chaos Toolkit addons extension gives you a nice way to interrupt an experiment as soon as error budgets have been consumed. This is orthogonal to the steady-state hypothesis as it is a mechanism to protect your system from being harmed too harshly by an experiment. \"controls\" : [ { \"name\" : \"safeguard\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaddons.controls.safeguards\" , \"arguments\" : { \"probes\" : [ { \"name\" : \"we-do-not-have-enough-error-budget-left-to-carry-on\" , \"type\" : \"probe\" , \"frequency\" : 5 , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosreliably.slo.probes\" , \"func\" : \"slo_is_met\" , \"arguments\" : { \"labels\" : { \"name\" : \"must-be-good\" , \"service\" : \"must-be-good-service\" }, \"limit\" : 5 } }, \"tolerance\" : true } ] } } } ] As you can notice it is the same construct as for the steady-state, it\u2019s merely used with a different purpose. Here these probes will be executed every 5s during the experiment (this frequence is for demo purposes, you would usually only run it once every minute or less). Contribute \u00b6 If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. Develop \u00b6 If you wish to develop on this project, make sure to install the development dependencies. But first, create a virtual environment and then install those dependencies. $ pip install -r requirements-dev.txt -r requirements.txt Then, point your environment to this directory: $ python setup.py develop Now, you can edit the files and they will be automatically be seen by your environment, even when running from the chaos command locally. Test \u00b6 To run the tests for the project execute the following: $ pytest Linting & Formatting \u00b6 A Makefile is provided to abstract away the linting and formatting commands. To lint the project, run: $ make lint To format the project, run: $ make format Exported Activities \u00b6 slo \u00b6 all_objective_results_ok \u00b6 Type tolerance Module chaosreliably.slo.tolerances Name all_objective_results_ok Return boolean Determines if any of the objective results provided had a remainingPercent of less than 0. This means the SLO failed: Take a case where an objective is set at 99% and the actual percent is 90%, the remaining percent from the two is -9% and it has therefore failed. If an objective is set to 90% and the actual percent is 99% then the remaining percent is 9% and the SLO has passed. :param value: List[Dict] representing the Objective Results to check :returns: bool representing whether all the Objective Results were OK or not Signature: def all_objective_results_ok ( value : List [ Dict ] = None ) -> bool : pass Arguments: Name Type Default Required value list null No Tolerances declare the value argument which is automatically injected by Chaos Toolkit as the output of the probe they are evaluating. Usage: { \"steady-state-hypothesis\" : { \"title\" : \"...\" , \"probes\" : [ { \"type\" : \"probe\" , \"tolerance\" : { \"name\" : \"all-objective-results-ok\" , \"type\" : \"tolerance\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosreliably.slo.tolerances\" , \"func\" : \"all_objective_results_ok\" } }, \"...\" : \"...\" } ] } } steady-state-hypothesis : probes : - '...' : '...' tolerance : name : all-objective-results-ok provider : func : all_objective_results_ok module : chaosreliably.slo.tolerances type : python type : tolerance type : probe title : '...' get_objective_results_by_labels \u00b6 Type probe Module chaosreliably.slo.probes Name get_objective_results_by_labels Return list For a given set of Objective labels, return all of the Ojective Results :param labels: Dict[str, str] representing the Objective Labels for the Objective to retrieve results for :param limit: int representing how many results to retrieve - Default 1 :param configuration: Configuration object provided by Chaos Toolkit :param secrets: Secret object provided by Chaos Toolkit :returns: List[Dict] representing the Objective Results for the given Objective Signature: def get_objective_results_by_labels ( labels : Dict [ str , str ], limit : int = 1 , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict ]: pass Arguments: Name Type Default Required labels mapping Yes limit integer 1 No Usage: { \"name\" : \"get-objective-results-by-labels\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosreliably.slo.probes\" , \"func\" : \"get_objective_results_by_labels\" , \"arguments\" : { \"labels\" : {} } } } name : get-objective-results-by-labels provider : arguments : labels : {} func : get_objective_results_by_labels module : chaosreliably.slo.probes type : python type : probe slo_is_met \u00b6 Type probe Module chaosreliably.slo.probes Name slo_is_met Return boolean For a given set of Objective labels, return whether the Objective was met :param labels: Dict[str, str] representing the Objective Labels for the Objective to retrieve results for :param limit: int representing how many results to retrieve - Default 1 :param configuration: Configuration object provided by Chaos Toolkit :param secrets: Secret object provided by Chaos Toolkit :returns: bool representing whether the SLO was met or not Signature: def slo_is_met ( labels : Dict [ str , str ], limit : int = 1 , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required labels mapping Yes limit integer 1 No Usage: { \"name\" : \"slo-is-met\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosreliably.slo.probes\" , \"func\" : \"slo_is_met\" , \"arguments\" : { \"labels\" : {} } } } name : slo-is-met provider : arguments : labels : {} func : slo_is_met module : chaosreliably.slo.probes type : python type : probe","title":"Reliably"},{"location":"drivers/reliably/#extension-chaosreliably","text":"Version 0.2.2 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-reliably Reliably support for the Chaos Toolkit .","title":"Extension chaosreliably"},{"location":"drivers/reliably/#install","text":"To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install chaostoolkit-reliably","title":"Install"},{"location":"drivers/reliably/#authentication","text":"To use this package, you must create have registered with Reliably services through their CLI . You have two ways to pass on the credentials information. The first one by specifying the path to the Reliably\u2019s configuration file, which defaults to $HOME/.config/reliably/config.yaml . The simplest way to achieve this is by running $ reliably login as this will generate the appropriate file. { \"configuration\" : { \"reliably_config_path\" : \"~/.config/reliably/config.yaml\" } } Because we use the default path, you may omit this configuration\u2019s entry altogether unless you need a specific different path. The second one is by setting some environment variables as secrets. This is for specific use case and usually not required. RELIABLY_TOKEN : the token to authenticate against Reliably\u2019s API RELIABLY_ORG : the Reliably organisation to use RELIABLY_HOST: : the hostname to connect to, default to reliably.com { \"secrets\" : { \"reliably\" : { \"token\" : { \"type\" : \"env\" , \"key\" : \"RELIABLY_TOKEN\" }, \"org\" : { \"type\" : \"env\" , \"key\" : \"RELIABLY_ORG\" }, \"host\" : { \"type\" : \"env\" , \"key\" : \"RELIABLY_HOST\" , \"default\" : \"reliably.com\" } } } }","title":"Authentication"},{"location":"drivers/reliably/#usage","text":"","title":"Usage"},{"location":"drivers/reliably/#as-steady-steate-hypothesis","text":"You can use Reliably\u2019s SLO as a mechanism to determine if your system has deviated during a Chaos Toolkit experiment. Here is a simple example: \"steady-state-hypothesis\" : { \"title\" : \"We do not consume all of our error budgets during the experiment\" , \"probes\" : [ { \"name\" : \"Our 'Must be good' SLO results must be OK\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosreliably.slo.probes\" , \"func\" : \"slo_is_met\" , \"arguments\" : { \"labels\" : { \"name\" : \"must-be-good\" , \"service\" : \"must-be-good-service\" }, \"limit\" : 5 } }, \"tolerance\" : true , } ] } This above example will get the last 5 Objective Results for our Must be good SLO and determine if they were all okay or whether we\u2019ve spent our error budget they are allowed.","title":"As Steady Steate Hypothesis"},{"location":"drivers/reliably/#as-safeguards","text":"Safeguards, provided by the Chaos Toolkit addons extension gives you a nice way to interrupt an experiment as soon as error budgets have been consumed. This is orthogonal to the steady-state hypothesis as it is a mechanism to protect your system from being harmed too harshly by an experiment. \"controls\" : [ { \"name\" : \"safeguard\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosaddons.controls.safeguards\" , \"arguments\" : { \"probes\" : [ { \"name\" : \"we-do-not-have-enough-error-budget-left-to-carry-on\" , \"type\" : \"probe\" , \"frequency\" : 5 , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosreliably.slo.probes\" , \"func\" : \"slo_is_met\" , \"arguments\" : { \"labels\" : { \"name\" : \"must-be-good\" , \"service\" : \"must-be-good-service\" }, \"limit\" : 5 } }, \"tolerance\" : true } ] } } } ] As you can notice it is the same construct as for the steady-state, it\u2019s merely used with a different purpose. Here these probes will be executed every 5s during the experiment (this frequence is for demo purposes, you would usually only run it once every minute or less).","title":"As Safeguards"},{"location":"drivers/reliably/#contribute","text":"If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review.","title":"Contribute"},{"location":"drivers/reliably/#develop","text":"If you wish to develop on this project, make sure to install the development dependencies. But first, create a virtual environment and then install those dependencies. $ pip install -r requirements-dev.txt -r requirements.txt Then, point your environment to this directory: $ python setup.py develop Now, you can edit the files and they will be automatically be seen by your environment, even when running from the chaos command locally.","title":"Develop"},{"location":"drivers/reliably/#test","text":"To run the tests for the project execute the following: $ pytest","title":"Test"},{"location":"drivers/reliably/#linting-formatting","text":"A Makefile is provided to abstract away the linting and formatting commands. To lint the project, run: $ make lint To format the project, run: $ make format","title":"Linting &amp; Formatting"},{"location":"drivers/reliably/#exported-activities","text":"","title":"Exported Activities"},{"location":"drivers/reliably/#slo","text":"","title":"slo"},{"location":"drivers/reliably/#all_objective_results_ok","text":"Type tolerance Module chaosreliably.slo.tolerances Name all_objective_results_ok Return boolean Determines if any of the objective results provided had a remainingPercent of less than 0. This means the SLO failed: Take a case where an objective is set at 99% and the actual percent is 90%, the remaining percent from the two is -9% and it has therefore failed. If an objective is set to 90% and the actual percent is 99% then the remaining percent is 9% and the SLO has passed. :param value: List[Dict] representing the Objective Results to check :returns: bool representing whether all the Objective Results were OK or not Signature: def all_objective_results_ok ( value : List [ Dict ] = None ) -> bool : pass Arguments: Name Type Default Required value list null No Tolerances declare the value argument which is automatically injected by Chaos Toolkit as the output of the probe they are evaluating. Usage: { \"steady-state-hypothesis\" : { \"title\" : \"...\" , \"probes\" : [ { \"type\" : \"probe\" , \"tolerance\" : { \"name\" : \"all-objective-results-ok\" , \"type\" : \"tolerance\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosreliably.slo.tolerances\" , \"func\" : \"all_objective_results_ok\" } }, \"...\" : \"...\" } ] } } steady-state-hypothesis : probes : - '...' : '...' tolerance : name : all-objective-results-ok provider : func : all_objective_results_ok module : chaosreliably.slo.tolerances type : python type : tolerance type : probe title : '...'","title":"all_objective_results_ok"},{"location":"drivers/reliably/#get_objective_results_by_labels","text":"Type probe Module chaosreliably.slo.probes Name get_objective_results_by_labels Return list For a given set of Objective labels, return all of the Ojective Results :param labels: Dict[str, str] representing the Objective Labels for the Objective to retrieve results for :param limit: int representing how many results to retrieve - Default 1 :param configuration: Configuration object provided by Chaos Toolkit :param secrets: Secret object provided by Chaos Toolkit :returns: List[Dict] representing the Objective Results for the given Objective Signature: def get_objective_results_by_labels ( labels : Dict [ str , str ], limit : int = 1 , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> List [ Dict ]: pass Arguments: Name Type Default Required labels mapping Yes limit integer 1 No Usage: { \"name\" : \"get-objective-results-by-labels\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosreliably.slo.probes\" , \"func\" : \"get_objective_results_by_labels\" , \"arguments\" : { \"labels\" : {} } } } name : get-objective-results-by-labels provider : arguments : labels : {} func : get_objective_results_by_labels module : chaosreliably.slo.probes type : python type : probe","title":"get_objective_results_by_labels"},{"location":"drivers/reliably/#slo_is_met","text":"Type probe Module chaosreliably.slo.probes Name slo_is_met Return boolean For a given set of Objective labels, return whether the Objective was met :param labels: Dict[str, str] representing the Objective Labels for the Objective to retrieve results for :param limit: int representing how many results to retrieve - Default 1 :param configuration: Configuration object provided by Chaos Toolkit :param secrets: Secret object provided by Chaos Toolkit :returns: bool representing whether the SLO was met or not Signature: def slo_is_met ( labels : Dict [ str , str ], limit : int = 1 , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required labels mapping Yes limit integer 1 No Usage: { \"name\" : \"slo-is-met\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosreliably.slo.probes\" , \"func\" : \"slo_is_met\" , \"arguments\" : { \"labels\" : {} } } } name : slo-is-met provider : arguments : labels : {} func : slo_is_met module : chaosreliably.slo.probes type : python type : probe","title":"slo_is_met"},{"location":"drivers/service-fabric/","text":"Extension chaosservicefabric \u00b6 Version 0.1.0 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-service-fabric This project is a collection of actions and probes , gathered as an extension to the Chaos Toolkit . It targets the Microsoft Service Fabric platform. Install \u00b6 This package requires Python 3.5+ To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install -U chaostoolkit-service-fabric Usage \u00b6 To use the probes and actions from this package, add the following to your experiment file: { \"type\" : \"action\" , \"name\" : \"start-service-factory-chaos\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosservicefabric.factory.actions\" , \"func\" : \"start_chaos\" , \"secrets\" : [ \"azure\" ], \"arguments\" : { \"parameters\" : { \"TimeToRunInSeconds\" : 45 } } } }, { \"type\" : \"action\" , \"name\" : \"stop-service-factory-chaos\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosservicefabric.factory.actions\" , \"func\" : \"stop_chaos\" , \"secrets\" : [ \"azure\" ] } } That\u2019s it! Please explore the code to see existing probes and actions. Configuration \u00b6 Credentials \u00b6 This extension uses the requests library under the hood. The requests library expects that you have a PFX certificate, converted as to the PEM format, that allows you to authenticate with the Service Factory endpoint. Generally speaking, there are two ways of doing this: you have created a configuration file where you will run the experiment from (so with a ~/.sfctl/config file) you explicitly pass the correct environment variables to the experiment definition as follows: Configuration section: { \"endpoint\" : \"https://XYZ.westus.cloudapp.azure.com:19080\" , \"verify_tls\" : false , \"use_ca\" : false } Secrets section: { \"azure\" : { \"security\" : \"pem\" , \"pem_path\" : \"./cluster-client-cert.pem\" } } The PEM can also be passed as an environment variable: { \"azure\" : { \"security\" : \"pem\" , \"pem_content\" : { \"type\" : \"env\" , \"key\" : \"AZURE_PEM\" } } } The environment variable name can be anything. Putting it all together \u00b6 Here is a full example: { \"version\" : \"1.0.0\" , \"title\" : \"...\" , \"description\" : \"...\" , \"configuration\" : { \"endpoint\" : \"https://XYZ.westus.cloudapp.azure.com:19080\" , \"verify_tls\" : false , \"use_ca\" : false }, \"secrets\" : { \"azure\" : { \"security\" : \"pem\" , \"pem_path\" : \"./cluster-client-cert.pem\" } }, \"steady-state-hypothesis\" : { \"title\" : \"Services is healthy\" , \"probes\" : [ { \"type\" : \"probe\" , \"name\" : \"application-must-respond\" , \"tolerance\" : 200 , \"provider\" : { \"type\" : \"http\" , \"verify_tls\" : false , \"url\" : \"https://some-url-in-cluster/\" } } ] }, \"method\" : [ { \"type\" : \"action\" , \"name\" : \"start-service-factory-chaos\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosservicefabric.factory.actions\" , \"func\" : \"start_chaos\" , \"secrets\" : [ \"azure\" ], \"arguments\" : { \"parameters\" : { \"TimeToRunInSeconds\" : 45 } } }, \"pauses\" : { \"after\" : 30 } }, { \"type\" : \"probe\" , \"ref\" : \"application-must-respond\" }, { \"type\" : \"action\" , \"name\" : \"stop-service-factory-chaos\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosservicefabric.factory.actions\" , \"func\" : \"stop_chaos\" , \"secrets\" : [ \"azure\" ] }, \"pauses\" : { \"after\" : 5 } }, { \"type\" : \"probe\" , \"name\" : \"get-service-factory-chaos-report\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosservicefabric.factory.probes\" , \"func\" : \"chaos_report\" , \"secrets\" : [ \"azure\" ], \"arguments\" : { \"start_time_utc\" : \"1 minute ago\" , \"end_time_utc\" : \"now\" } } } ] } Contribute \u00b6 If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. The Chaos Toolkit projects require all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR. Develop \u00b6 If you wish to develop on this project, make sure to install the development dependencies. But first, create a virtual environment and then install those dependencies. $ pip install -r requirements-dev.txt -r requirements.txt Then, point your environment to this directory: $ python setup.py develop Now, you can edit the files and they will be automatically be seen by your environment, even when running from the chaos command locally. Test \u00b6 To run the tests for the project execute the following: $ pytest Exported Activities \u00b6 cluster \u00b6 chaos_report \u00b6 Type probe Module chaosservicefabric.cluster.probes Name chaos_report Return mapping Get Chaos report using following the Service Fabric API: https://docs.microsoft.com/en-us/rest/api/servicefabric/sfclient-v60-model-chaosparameters Please see the :func: chaosazure.fabric.auth help for more information on authenticating with the service. Signature: def chaos_report ( timeout : int = 60 , start_time_utc : str = None , end_time_utc : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required timeout integer 60 No start_time_utc string null No end_time_utc string null No Usage: { \"name\" : \"chaos-report\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosservicefabric.cluster.probes\" , \"func\" : \"chaos_report\" } } name : chaos-report provider : func : chaos_report module : chaosservicefabric.cluster.probes type : python type : probe start_chaos \u00b6 Type action Module chaosservicefabric.cluster.actions Name start_chaos Return mapping Start Chaos in your cluster using the given parameters . This is a mapping of keys as declared in the Service Fabric API: https://docs.microsoft.com/en-us/rest/api/servicefabric/sfclient-v60-model-chaosparameters Please see the :func: chaosservicefabric.fabric.auth help for more information on authenticating with the service. Signature: def start_chaos ( parameters : Dict [ str , Any ], timeout : int = 60 , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required parameters mapping Yes timeout integer 60 No Usage: { \"name\" : \"start-chaos\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosservicefabric.cluster.actions\" , \"func\" : \"start_chaos\" , \"arguments\" : { \"parameters\" : {} } } } name : start-chaos provider : arguments : parameters : {} func : start_chaos module : chaosservicefabric.cluster.actions type : python type : action stop_chaos \u00b6 Type action Module chaosservicefabric.cluster.actions Name stop_chaos Return mapping Stop Chaos in your cluster. Please see the :func: chaosservicefabric.fabric.auth help for more information on authenticating with the service. Signature: def stop_chaos ( timeout : int = 60 , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required timeout integer 60 No Usage: { \"name\" : \"stop-chaos\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosservicefabric.cluster.actions\" , \"func\" : \"stop_chaos\" } } name : stop-chaos provider : func : stop_chaos module : chaosservicefabric.cluster.actions type : python type : action","title":"Service Fabric"},{"location":"drivers/service-fabric/#extension-chaosservicefabric","text":"Version 0.1.0 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-service-fabric This project is a collection of actions and probes , gathered as an extension to the Chaos Toolkit . It targets the Microsoft Service Fabric platform.","title":"Extension chaosservicefabric"},{"location":"drivers/service-fabric/#install","text":"This package requires Python 3.5+ To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install -U chaostoolkit-service-fabric","title":"Install"},{"location":"drivers/service-fabric/#usage","text":"To use the probes and actions from this package, add the following to your experiment file: { \"type\" : \"action\" , \"name\" : \"start-service-factory-chaos\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosservicefabric.factory.actions\" , \"func\" : \"start_chaos\" , \"secrets\" : [ \"azure\" ], \"arguments\" : { \"parameters\" : { \"TimeToRunInSeconds\" : 45 } } } }, { \"type\" : \"action\" , \"name\" : \"stop-service-factory-chaos\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosservicefabric.factory.actions\" , \"func\" : \"stop_chaos\" , \"secrets\" : [ \"azure\" ] } } That\u2019s it! Please explore the code to see existing probes and actions.","title":"Usage"},{"location":"drivers/service-fabric/#configuration","text":"","title":"Configuration"},{"location":"drivers/service-fabric/#credentials","text":"This extension uses the requests library under the hood. The requests library expects that you have a PFX certificate, converted as to the PEM format, that allows you to authenticate with the Service Factory endpoint. Generally speaking, there are two ways of doing this: you have created a configuration file where you will run the experiment from (so with a ~/.sfctl/config file) you explicitly pass the correct environment variables to the experiment definition as follows: Configuration section: { \"endpoint\" : \"https://XYZ.westus.cloudapp.azure.com:19080\" , \"verify_tls\" : false , \"use_ca\" : false } Secrets section: { \"azure\" : { \"security\" : \"pem\" , \"pem_path\" : \"./cluster-client-cert.pem\" } } The PEM can also be passed as an environment variable: { \"azure\" : { \"security\" : \"pem\" , \"pem_content\" : { \"type\" : \"env\" , \"key\" : \"AZURE_PEM\" } } } The environment variable name can be anything.","title":"Credentials"},{"location":"drivers/service-fabric/#putting-it-all-together","text":"Here is a full example: { \"version\" : \"1.0.0\" , \"title\" : \"...\" , \"description\" : \"...\" , \"configuration\" : { \"endpoint\" : \"https://XYZ.westus.cloudapp.azure.com:19080\" , \"verify_tls\" : false , \"use_ca\" : false }, \"secrets\" : { \"azure\" : { \"security\" : \"pem\" , \"pem_path\" : \"./cluster-client-cert.pem\" } }, \"steady-state-hypothesis\" : { \"title\" : \"Services is healthy\" , \"probes\" : [ { \"type\" : \"probe\" , \"name\" : \"application-must-respond\" , \"tolerance\" : 200 , \"provider\" : { \"type\" : \"http\" , \"verify_tls\" : false , \"url\" : \"https://some-url-in-cluster/\" } } ] }, \"method\" : [ { \"type\" : \"action\" , \"name\" : \"start-service-factory-chaos\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosservicefabric.factory.actions\" , \"func\" : \"start_chaos\" , \"secrets\" : [ \"azure\" ], \"arguments\" : { \"parameters\" : { \"TimeToRunInSeconds\" : 45 } } }, \"pauses\" : { \"after\" : 30 } }, { \"type\" : \"probe\" , \"ref\" : \"application-must-respond\" }, { \"type\" : \"action\" , \"name\" : \"stop-service-factory-chaos\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosservicefabric.factory.actions\" , \"func\" : \"stop_chaos\" , \"secrets\" : [ \"azure\" ] }, \"pauses\" : { \"after\" : 5 } }, { \"type\" : \"probe\" , \"name\" : \"get-service-factory-chaos-report\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosservicefabric.factory.probes\" , \"func\" : \"chaos_report\" , \"secrets\" : [ \"azure\" ], \"arguments\" : { \"start_time_utc\" : \"1 minute ago\" , \"end_time_utc\" : \"now\" } } } ] }","title":"Putting it all together"},{"location":"drivers/service-fabric/#contribute","text":"If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. The Chaos Toolkit projects require all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR.","title":"Contribute"},{"location":"drivers/service-fabric/#develop","text":"If you wish to develop on this project, make sure to install the development dependencies. But first, create a virtual environment and then install those dependencies. $ pip install -r requirements-dev.txt -r requirements.txt Then, point your environment to this directory: $ python setup.py develop Now, you can edit the files and they will be automatically be seen by your environment, even when running from the chaos command locally.","title":"Develop"},{"location":"drivers/service-fabric/#test","text":"To run the tests for the project execute the following: $ pytest","title":"Test"},{"location":"drivers/service-fabric/#exported-activities","text":"","title":"Exported Activities"},{"location":"drivers/service-fabric/#cluster","text":"","title":"cluster"},{"location":"drivers/service-fabric/#chaos_report","text":"Type probe Module chaosservicefabric.cluster.probes Name chaos_report Return mapping Get Chaos report using following the Service Fabric API: https://docs.microsoft.com/en-us/rest/api/servicefabric/sfclient-v60-model-chaosparameters Please see the :func: chaosazure.fabric.auth help for more information on authenticating with the service. Signature: def chaos_report ( timeout : int = 60 , start_time_utc : str = None , end_time_utc : str = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required timeout integer 60 No start_time_utc string null No end_time_utc string null No Usage: { \"name\" : \"chaos-report\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosservicefabric.cluster.probes\" , \"func\" : \"chaos_report\" } } name : chaos-report provider : func : chaos_report module : chaosservicefabric.cluster.probes type : python type : probe","title":"chaos_report"},{"location":"drivers/service-fabric/#start_chaos","text":"Type action Module chaosservicefabric.cluster.actions Name start_chaos Return mapping Start Chaos in your cluster using the given parameters . This is a mapping of keys as declared in the Service Fabric API: https://docs.microsoft.com/en-us/rest/api/servicefabric/sfclient-v60-model-chaosparameters Please see the :func: chaosservicefabric.fabric.auth help for more information on authenticating with the service. Signature: def start_chaos ( parameters : Dict [ str , Any ], timeout : int = 60 , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required parameters mapping Yes timeout integer 60 No Usage: { \"name\" : \"start-chaos\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosservicefabric.cluster.actions\" , \"func\" : \"start_chaos\" , \"arguments\" : { \"parameters\" : {} } } } name : start-chaos provider : arguments : parameters : {} func : start_chaos module : chaosservicefabric.cluster.actions type : python type : action","title":"start_chaos"},{"location":"drivers/service-fabric/#stop_chaos","text":"Type action Module chaosservicefabric.cluster.actions Name stop_chaos Return mapping Stop Chaos in your cluster. Please see the :func: chaosservicefabric.fabric.auth help for more information on authenticating with the service. Signature: def stop_chaos ( timeout : int = 60 , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required timeout integer 60 No Usage: { \"name\" : \"stop-chaos\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosservicefabric.cluster.actions\" , \"func\" : \"stop_chaos\" } } name : stop-chaos provider : func : stop_chaos module : chaosservicefabric.cluster.actions type : python type : action","title":"stop_chaos"},{"location":"drivers/spring/","text":"Extension chaosspring \u00b6 Version 0.2.0 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-spring This project is a collection of actions and probes , gathered as an extension to the Chaos Toolkit . Install \u00b6 This package requires Python 3.5+ To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install -U chaostoolkit-spring Usage \u00b6 Currently this driver supports interactions with a Spring Boot-based service that has included the 2.0.0.-SNAPSHOT release of the Chaos Monkey for Spring Boot . This snapshot includes the necessary Spring Boot Actuator HTTP endpoints so that the Chaos Toolkit to interact with the chaos features at runtime. Once you have added the Chaos Monkey for Spring Boot and enabled the Spring Boot Actuator HTTP endpoints you can then use the probes and actions from this driver. To use the probes and actions from this package, add the following to your experiment file: { \"name\" : \"enable_chaosmonkey\" , \"provider\" : { \"arguments\" : { \"base_url\" : \"http://localhost:8080/actuator\" }, \"func\" : \"enable_chaosmonkey\" , \"module\" : \"chaosspring.actions\" , \"type\" : \"python\" }, \"type\" : \"action\" } This will interact with the specified service and enable the Chaos Monkey features. You can also turn off the Chaos Monkey if you wish by specifying the following action: { \"name\" : \"disable_chaosmonkey\" , \"provider\" : { \"arguments\" : { \"base_url\" : \"http://localhost:8080/actuator\" }, \"func\" : \"disable_chaosmonkey\" , \"module\" : \"chaosspring.actions\" , \"type\" : \"python\" }, \"type\" : \"action\" } You can then manipulate the Chaos Monkey assaults active on your service by specifing the following action: { \"name\" : \"configure_assaults\" , \"provider\" : { \"arguments\" : { \"base_url\" : \"http://localhost:8080/actuator\" , \"assaults_configuration\" : { \"level\" : 5 , \"latencyRangeStart\" : 2000 , \"latencyRangeEnd\" : 5000 , \"latencyActive\" : false , \"exceptionsActive\" : false , \"killApplicationActive\" : true , \"restartApplicationActive\" : false } }, \"func\" : \"change_assaults_configuration\" , \"module\" : \"chaosspring.actions\" , \"type\" : \"python\" }, \"type\" : \"action\" } That\u2019s it! Please explore the code to use further probes and actions. Contribute \u00b6 If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. The Chaos Toolkit projects require all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR. Develop \u00b6 If you wish to develop on this project, make sure to install the development dependencies. But first, create a virtual environment and then install those dependencies. $ pip install -r requirements-dev.txt -r requirements.txt Then, point your environment to this directory: $ python setup.py develop Now, you can edit the files and they will be automatically be seen by your environment, even when running from the chaos command locally. Test \u00b6 To run the tests for the project execute the following: $ pytest Exported Activities \u00b6 actions \u00b6 change_assaults_configuration \u00b6 Type action Module chaosspring.actions Name change_assaults_configuration Return string Change Assaults configuration on a specific service. Signature: def change_assaults_configuration ( base_url : str , assaults_configuration : Dict [ str , Any ], headers : Dict [ str , Any ] = None , timeout : float = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> str : pass Arguments: Name Type Default Required base_url string Yes assaults_configuration mapping Yes headers mapping null No timeout number null No Usage: { \"name\" : \"change-assaults-configuration\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosspring.actions\" , \"func\" : \"change_assaults_configuration\" , \"arguments\" : { \"base_url\" : \"\" , \"assaults_configuration\" : {} } } } name : change-assaults-configuration provider : arguments : assaults_configuration : {} base_url : '' func : change_assaults_configuration module : chaosspring.actions type : python type : action disable_chaosmonkey \u00b6 Type action Module chaosspring.actions Name disable_chaosmonkey Return string Disable Chaos Monkey on a specific service. Signature: def disable_chaosmonkey ( base_url : str , headers : Dict [ str , Any ] = None , timeout : float = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> str : pass Arguments: Name Type Default Required base_url string Yes headers mapping null No timeout number null No Usage: { \"name\" : \"disable-chaosmonkey\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosspring.actions\" , \"func\" : \"disable_chaosmonkey\" , \"arguments\" : { \"base_url\" : \"\" } } } name : disable-chaosmonkey provider : arguments : base_url : '' func : disable_chaosmonkey module : chaosspring.actions type : python type : action enable_chaosmonkey \u00b6 Type action Module chaosspring.actions Name enable_chaosmonkey Return string Enable Chaos Monkey on a specific service. Signature: def enable_chaosmonkey ( base_url : str , headers : Dict [ str , Any ] = None , timeout : float = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> str : pass Arguments: Name Type Default Required base_url string Yes headers mapping null No timeout number null No Usage: { \"name\" : \"enable-chaosmonkey\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosspring.actions\" , \"func\" : \"enable_chaosmonkey\" , \"arguments\" : { \"base_url\" : \"\" } } } name : enable-chaosmonkey provider : arguments : base_url : '' func : enable_chaosmonkey module : chaosspring.actions type : python type : action probes \u00b6 assaults_configuration \u00b6 Type probe Module chaosspring.probes Name assaults_configuration Return mapping Get the current assaults configuraton from the specified service. Signature: def assaults_configuration ( base_url : str , headers : Dict [ str , Any ] = None , timeout : float = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required base_url string Yes headers mapping null No timeout number null No Usage: { \"name\" : \"assaults-configuration\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosspring.probes\" , \"func\" : \"assaults_configuration\" , \"arguments\" : { \"base_url\" : \"\" } } } name : assaults-configuration provider : arguments : base_url : '' func : assaults_configuration module : chaosspring.probes type : python type : probe chaosmonkey_enabled \u00b6 Type probe Module chaosspring.probes Name chaosmonkey_enabled Return boolean Enquire whether Chaos Monkey is enabled on the specified service. Signature: def chaosmonkey_enabled ( base_url : str , headers : Dict [ str , Any ] = None , timeout : float = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required base_url string Yes headers mapping null No timeout number null No Usage: { \"name\" : \"chaosmonkey-enabled\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosspring.probes\" , \"func\" : \"chaosmonkey_enabled\" , \"arguments\" : { \"base_url\" : \"\" } } } name : chaosmonkey-enabled provider : arguments : base_url : '' func : chaosmonkey_enabled module : chaosspring.probes type : python type : probe watcher_configuration \u00b6 Type probe Module chaosspring.probes Name watcher_configuration Return mapping Get the current watcher configuraton from the specified service. Signature: def watcher_configuration ( base_url : str , headers : Dict [ str , Any ] = None , timeout : float = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required base_url string Yes headers mapping null No timeout number null No Usage: { \"name\" : \"watcher-configuration\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosspring.probes\" , \"func\" : \"watcher_configuration\" , \"arguments\" : { \"base_url\" : \"\" } } } name : watcher-configuration provider : arguments : base_url : '' func : watcher_configuration module : chaosspring.probes type : python type : probe","title":"Spring"},{"location":"drivers/spring/#extension-chaosspring","text":"Version 0.2.0 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-spring This project is a collection of actions and probes , gathered as an extension to the Chaos Toolkit .","title":"Extension chaosspring"},{"location":"drivers/spring/#install","text":"This package requires Python 3.5+ To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install -U chaostoolkit-spring","title":"Install"},{"location":"drivers/spring/#usage","text":"Currently this driver supports interactions with a Spring Boot-based service that has included the 2.0.0.-SNAPSHOT release of the Chaos Monkey for Spring Boot . This snapshot includes the necessary Spring Boot Actuator HTTP endpoints so that the Chaos Toolkit to interact with the chaos features at runtime. Once you have added the Chaos Monkey for Spring Boot and enabled the Spring Boot Actuator HTTP endpoints you can then use the probes and actions from this driver. To use the probes and actions from this package, add the following to your experiment file: { \"name\" : \"enable_chaosmonkey\" , \"provider\" : { \"arguments\" : { \"base_url\" : \"http://localhost:8080/actuator\" }, \"func\" : \"enable_chaosmonkey\" , \"module\" : \"chaosspring.actions\" , \"type\" : \"python\" }, \"type\" : \"action\" } This will interact with the specified service and enable the Chaos Monkey features. You can also turn off the Chaos Monkey if you wish by specifying the following action: { \"name\" : \"disable_chaosmonkey\" , \"provider\" : { \"arguments\" : { \"base_url\" : \"http://localhost:8080/actuator\" }, \"func\" : \"disable_chaosmonkey\" , \"module\" : \"chaosspring.actions\" , \"type\" : \"python\" }, \"type\" : \"action\" } You can then manipulate the Chaos Monkey assaults active on your service by specifing the following action: { \"name\" : \"configure_assaults\" , \"provider\" : { \"arguments\" : { \"base_url\" : \"http://localhost:8080/actuator\" , \"assaults_configuration\" : { \"level\" : 5 , \"latencyRangeStart\" : 2000 , \"latencyRangeEnd\" : 5000 , \"latencyActive\" : false , \"exceptionsActive\" : false , \"killApplicationActive\" : true , \"restartApplicationActive\" : false } }, \"func\" : \"change_assaults_configuration\" , \"module\" : \"chaosspring.actions\" , \"type\" : \"python\" }, \"type\" : \"action\" } That\u2019s it! Please explore the code to use further probes and actions.","title":"Usage"},{"location":"drivers/spring/#contribute","text":"If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. The Chaos Toolkit projects require all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR.","title":"Contribute"},{"location":"drivers/spring/#develop","text":"If you wish to develop on this project, make sure to install the development dependencies. But first, create a virtual environment and then install those dependencies. $ pip install -r requirements-dev.txt -r requirements.txt Then, point your environment to this directory: $ python setup.py develop Now, you can edit the files and they will be automatically be seen by your environment, even when running from the chaos command locally.","title":"Develop"},{"location":"drivers/spring/#test","text":"To run the tests for the project execute the following: $ pytest","title":"Test"},{"location":"drivers/spring/#exported-activities","text":"","title":"Exported Activities"},{"location":"drivers/spring/#actions","text":"","title":"actions"},{"location":"drivers/spring/#change_assaults_configuration","text":"Type action Module chaosspring.actions Name change_assaults_configuration Return string Change Assaults configuration on a specific service. Signature: def change_assaults_configuration ( base_url : str , assaults_configuration : Dict [ str , Any ], headers : Dict [ str , Any ] = None , timeout : float = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> str : pass Arguments: Name Type Default Required base_url string Yes assaults_configuration mapping Yes headers mapping null No timeout number null No Usage: { \"name\" : \"change-assaults-configuration\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosspring.actions\" , \"func\" : \"change_assaults_configuration\" , \"arguments\" : { \"base_url\" : \"\" , \"assaults_configuration\" : {} } } } name : change-assaults-configuration provider : arguments : assaults_configuration : {} base_url : '' func : change_assaults_configuration module : chaosspring.actions type : python type : action","title":"change_assaults_configuration"},{"location":"drivers/spring/#disable_chaosmonkey","text":"Type action Module chaosspring.actions Name disable_chaosmonkey Return string Disable Chaos Monkey on a specific service. Signature: def disable_chaosmonkey ( base_url : str , headers : Dict [ str , Any ] = None , timeout : float = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> str : pass Arguments: Name Type Default Required base_url string Yes headers mapping null No timeout number null No Usage: { \"name\" : \"disable-chaosmonkey\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosspring.actions\" , \"func\" : \"disable_chaosmonkey\" , \"arguments\" : { \"base_url\" : \"\" } } } name : disable-chaosmonkey provider : arguments : base_url : '' func : disable_chaosmonkey module : chaosspring.actions type : python type : action","title":"disable_chaosmonkey"},{"location":"drivers/spring/#enable_chaosmonkey","text":"Type action Module chaosspring.actions Name enable_chaosmonkey Return string Enable Chaos Monkey on a specific service. Signature: def enable_chaosmonkey ( base_url : str , headers : Dict [ str , Any ] = None , timeout : float = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> str : pass Arguments: Name Type Default Required base_url string Yes headers mapping null No timeout number null No Usage: { \"name\" : \"enable-chaosmonkey\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosspring.actions\" , \"func\" : \"enable_chaosmonkey\" , \"arguments\" : { \"base_url\" : \"\" } } } name : enable-chaosmonkey provider : arguments : base_url : '' func : enable_chaosmonkey module : chaosspring.actions type : python type : action","title":"enable_chaosmonkey"},{"location":"drivers/spring/#probes","text":"","title":"probes"},{"location":"drivers/spring/#assaults_configuration","text":"Type probe Module chaosspring.probes Name assaults_configuration Return mapping Get the current assaults configuraton from the specified service. Signature: def assaults_configuration ( base_url : str , headers : Dict [ str , Any ] = None , timeout : float = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required base_url string Yes headers mapping null No timeout number null No Usage: { \"name\" : \"assaults-configuration\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosspring.probes\" , \"func\" : \"assaults_configuration\" , \"arguments\" : { \"base_url\" : \"\" } } } name : assaults-configuration provider : arguments : base_url : '' func : assaults_configuration module : chaosspring.probes type : python type : probe","title":"assaults_configuration"},{"location":"drivers/spring/#chaosmonkey_enabled","text":"Type probe Module chaosspring.probes Name chaosmonkey_enabled Return boolean Enquire whether Chaos Monkey is enabled on the specified service. Signature: def chaosmonkey_enabled ( base_url : str , headers : Dict [ str , Any ] = None , timeout : float = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required base_url string Yes headers mapping null No timeout number null No Usage: { \"name\" : \"chaosmonkey-enabled\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosspring.probes\" , \"func\" : \"chaosmonkey_enabled\" , \"arguments\" : { \"base_url\" : \"\" } } } name : chaosmonkey-enabled provider : arguments : base_url : '' func : chaosmonkey_enabled module : chaosspring.probes type : python type : probe","title":"chaosmonkey_enabled"},{"location":"drivers/spring/#watcher_configuration","text":"Type probe Module chaosspring.probes Name watcher_configuration Return mapping Get the current watcher configuraton from the specified service. Signature: def watcher_configuration ( base_url : str , headers : Dict [ str , Any ] = None , timeout : float = None , configuration : Dict [ str , Dict [ str , str ]] = None , secrets : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required base_url string Yes headers mapping null No timeout number null No Usage: { \"name\" : \"watcher-configuration\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosspring.probes\" , \"func\" : \"watcher_configuration\" , \"arguments\" : { \"base_url\" : \"\" } } } name : watcher-configuration provider : arguments : base_url : '' func : watcher_configuration module : chaosspring.probes type : python type : probe","title":"watcher_configuration"},{"location":"drivers/toxiproxy/","text":"Extension chaostoxi \u00b6 Version 0.3.0 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-toxiproxy Welcome to the Chaos Toolkit driver for Toxiproxy ! This extension allows you to setup toxy proxy probes and methods from chaostoolkit by leveraging the toxyproxy http management api . Install \u00b6 Install the Toxiproxy base client Install the Toxiproxy CLI Driver \u00b6 This package requires Python 3.5+ To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install -U chaostoolkit-toxiproxy Usage \u00b6 Configuration \u00b6 First, run the Toxiproxy base client locally to create a localhost:8474 host on your computer. Then create a proxy . Next, to start using the actions and probes all you need to do is add the toxiproxy host with \u201ctoxiproxy_host\u201d as the key, and optionally the port with \u201ctoxiproxy_port\u201d as the key, to the configuration section in your experiment json. If not provided the port defaults to 8474. Alternatively, if toxiproxy api is accessible using a reverse proxy, you can use toxiproxy_url setting. Example using toxiproxy_host in experiment.json \"configuration\" : { \"toxiproxy_host\" : \"10.124.23.183\" , \"some_environment_variable\" : { \"type\" : \"environment\" , \"key\" : \"ENVIRONMENT_VARIABLE\" } }, Example using toxiproxy_url in experiment.json \"configuration\" : { \"toxiproxy_url\" : \"http://mydomain.com:8080/path-to-toxiproxy-api\" , \"some_environment_variable\" : { \"type\" : \"environment\" , \"key\" : \"ENVIRONMENT_VARIABLE\" } }, This extension follows the toxiproxy rules. A proxy is the channel where toxicity can be added. For this reason the extension is broken into proxy management and toxic management. All actions and probes in the extension are of python type and are used like any other python extension. Proxy actions \u00b6 create_proxy \u00b6 Creates a proxy to which toxics can be added. In toxiproxy a listen port of value 0 tells the API to assign a random available port. The value where the proxy is listenting will be attached to the chaostoolkit configuration object as \\<proxyname>_PORT . Should the creation of the proxy fail, an assertion error is raised stopping all subsequent actions. Argument Description Required Default proxy_name name for the proxy Yes None upstream_host ip address of the host to send traffic to Yes None upstream_port port of the application to send traffic to Yes None listen_host IP address to bind where toxiproxy listens No 0.0.0.0 listen_port port to listen for requests, 0 means pick random value No 0 enabled Whether to start listening or not No True modify_proxy \u00b6 Modify the configuration of a given proxy. Useful to change the upstream configiuration. Only arguments supplied result in modification of the proxy. Argument Description Required Default proxy_name name for the proxy Yes None listen_addres ip:port address to modify No None upstream_addres ip:port of the upstream No None enabled Toggle enabled/disabled state No None disable_proxy \u00b6 Disables the proxy, this is useful to simulate a proxied service being down. Argument Description Required Default proxy_name name for the proxy to disable Yes None enable_proxy \u00b6 Enables a disabled proxy. Argument Description Required Default proxy_name name for the proxy to enable Yes None delete_proxy \u00b6 Removes the proxy from the system. Example usage \"method\" : [ { \"type\" : \"action\" , \"name\" : \"setup_toxiproxy_proxy\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostoxi.proxy.actions\" , \"func\" : \"create_proxy\" , \"arguments\" : { \"proxy_name\" : \"myproxy\" , \"listen_port\" : 6666 , \"upstream_host\" : \"10.28.188.118\" , \"upstream_port\" : 6040 } }, \"pauses\" : { \"after\" : 1 } } ] reset \u00b6 Enable all proxies and remove all active toxics. Example usage: \"method\" : [ { \"type\" : \"action\" , \"name\" : \"reset all proxies\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostoxi.proxy.actions\" , \"func\" : \"reset\" }, \"pauses\" : { \"after\" : 1 } } ] Proxy pobes \u00b6 proxy_exist \u00b6 Returns True of False if a given proxy exists. Argument Description Required Default proxy_name name for the proxy Yes None Toxic actions \u00b6 All actions provided by this extension match the types and attributes of toxics . create_toxic \u00b6 Allows you to create any of the supported types of toxics with their attributes. Argument Description Required Default for_proxy name for the proxy to attach the toxy Yes None toxic_name name for this toxy Yes None toxic_type A valid toxic type Yes None stream The direction of the toxic \u201cupstream\u201d or \u201cdownstream\u201d No downstream toxicity Percentage of toxiciy 1.0 is 100%, 0.5 is 50% etc No 1.0 attributes Dictionary of attributes for the type of toxic No None create_latency_toxic \u00b6 Add a delay to all data going through the proxy using a downstream with a toxicity of 100%. Argument Description Required Default for_proxy name for the proxy to attach the toxy Yes None toxic_name name for this toxy Yes None latency time in milliseconds to add for latency Yes None jitter time in milliseconds to jitter No 0 create_bandwith_degradation_toxic \u00b6 Limit the bandwith of a downstream connection with a toxicity of 100%. Argument Description Required Default for_proxy name for the proxy to attach the toxy Yes None toxic_name name for this toxy Yes None rate desired bandwith rate in KB/s Yes None create_slow_connection_close_toxic \u00b6 Generate as downstream delayed TCP close with a toxicity of 100%. Argument Description Required Default for_proxy name for the proxy to attach the toxy Yes None toxic_name name for this toxy Yes None delay desired close delay in milliseconds Yes None create_slicer_toxic \u00b6 Slices TCP data up into small bits, optionally adding a delay between each sliced \u201cpacket\u201d with a toxicity of 100%. Argument Description Required Default for_proxy name for the proxy to attach the toxy Yes None toxic_name name for this toxy Yes None average_size size in bytes for the average package Yes None size_variation variation in bytes of an average pkg (should be smaller than average_size) Yes None delay time in microseconds to delay each packet by Yes None create_limiter_toxic \u00b6 Closes connections when transmitted data after the limit, sets it up as a dowsntream, 100% toxicity. Argument Description Required Default for_proxy name for the proxy to attach the toxy Yes None toxic_name name for this toxy Yes None bytes number of bytes to transmit before connection is closed Yes None delete_toxic \u00b6 Deletes the a given toxic. Argument Description Required Default for_proxy name for the proxy to attach the toxy Yes None toxic_name name for this toxy Yes None Example usage: \"method\" : [ { \"type\" : \"action\" , \"name\" : \"create_latency_toxic\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"toxiproxy.toxic.actions\" , \"func\" : \"create_dowsntream_latency_toxic\" , \"arguments\" : { \"for_proxy\" : \"edsproxy\" , \"toxic_name\" : \"latency_toxic\" , \"latency\" : 5000 , \"jitter\" : 200 } }, \"pauses\" : { \"after\" : 1 } } ] Contribute \u00b6 If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. The Chaos Toolkit projects require all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR. Develop \u00b6 If you wish to develop on this project, make sure to install the development dependencies. But first, create a virtual environment and then install those dependencies. $ pip install -r requirements-dev.txt -r requirements.txt Then, point your environment to this directory: $ python setup.py develop Now, you can edit the files and they will be automatically be seen by your environment, even when running from the chaos command locally. Test \u00b6 To run the unit tests for the project execute the following: $ pytest To run the integration tests for the project execute the following: $ tox Exported Activities \u00b6 proxy \u00b6 create_proxy \u00b6 Type action Module chaostoxi.proxy.actions Name create_proxy Return None Creates a proxy to which toxics can be added. Signature: def create_proxy ( proxy_name : str , upstream_host : str , upstream_port : int , listen_host : str = '0.0.0.0' , listen_port : int = 0 , enabled : bool = True , configuration : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required proxy_name string Yes upstream_host string Yes upstream_port integer Yes listen_host string \u201c0.0.0.0\u201d No listen_port integer 0 No enabled boolean true No Usage: { \"name\" : \"create-proxy\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostoxi.proxy.actions\" , \"func\" : \"create_proxy\" , \"arguments\" : { \"proxy_name\" : \"\" , \"upstream_host\" : \"\" , \"upstream_port\" : 0 } } } name : create-proxy provider : arguments : proxy_name : '' upstream_host : '' upstream_port : 0 func : create_proxy module : chaostoxi.proxy.actions type : python type : action delete_proxy \u00b6 Type action Module chaostoxi.proxy.actions Name delete_proxy Return None Removes the proxy from the system. Signature: def delete_proxy ( proxy_name : str , configuration : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required proxy_name string Yes Usage: { \"name\" : \"delete-proxy\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostoxi.proxy.actions\" , \"func\" : \"delete_proxy\" , \"arguments\" : { \"proxy_name\" : \"\" } } } name : delete-proxy provider : arguments : proxy_name : '' func : delete_proxy module : chaostoxi.proxy.actions type : python type : action disable_proxy \u00b6 Type action Module chaostoxi.proxy.actions Name disable_proxy Return None Disables the proxy, this is useful to simulate a proxied service being down. Signature: def disable_proxy ( proxy_name : str , configuration : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required proxy_name string Yes Usage: { \"name\" : \"disable-proxy\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostoxi.proxy.actions\" , \"func\" : \"disable_proxy\" , \"arguments\" : { \"proxy_name\" : \"\" } } } name : disable-proxy provider : arguments : proxy_name : '' func : disable_proxy module : chaostoxi.proxy.actions type : python type : action enable_proxy \u00b6 Type action Module chaostoxi.proxy.actions Name enable_proxy Return None Enables a disabled proxy. Signature: def enable_proxy ( proxy_name : str , configuration : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required proxy_name string Yes Usage: { \"name\" : \"enable-proxy\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostoxi.proxy.actions\" , \"func\" : \"enable_proxy\" , \"arguments\" : { \"proxy_name\" : \"\" } } } name : enable-proxy provider : arguments : proxy_name : '' func : enable_proxy module : chaostoxi.proxy.actions type : python type : action get_proxy_attribute \u00b6 Type probe Module chaostoxi.proxy.probes Name get_proxy_attribute Return None Returns an attribute of a specified proxy. Signature: def get_proxy_attribute ( proxy_name : str , attribute : str , configuration : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required proxy_name string Yes attribute string Yes Usage: { \"name\" : \"get-proxy-attribute\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostoxi.proxy.probes\" , \"func\" : \"get_proxy_attribute\" , \"arguments\" : { \"proxy_name\" : \"\" , \"attribute\" : \"\" } } } name : get-proxy-attribute provider : arguments : attribute : '' proxy_name : '' func : get_proxy_attribute module : chaostoxi.proxy.probes type : python type : probe modify_proxy \u00b6 Type action Module chaostoxi.proxy.actions Name modify_proxy Return None Modify the configuration of a given proxy. Useful to change the upstream configiuration. Only arguments supplied result in modification of the proxy. Signature: def modify_proxy ( proxy_name : str , listen_address : str = None , upstream_address : str = None , enabled : bool = None , configuration : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required proxy_name string Yes listen_address string null No upstream_address string null No enabled boolean null No Usage: { \"name\" : \"modify-proxy\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostoxi.proxy.actions\" , \"func\" : \"modify_proxy\" , \"arguments\" : { \"proxy_name\" : \"\" } } } name : modify-proxy provider : arguments : proxy_name : '' func : modify_proxy module : chaostoxi.proxy.actions type : python type : action proxy_exist \u00b6 Type probe Module chaostoxi.proxy.probes Name proxy_exist Return None Returns True of False if a given proxy exists. Signature: def proxy_exist ( proxy_name : str , configuration : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required proxy_name string Yes Usage: { \"name\" : \"proxy-exist\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostoxi.proxy.probes\" , \"func\" : \"proxy_exist\" , \"arguments\" : { \"proxy_name\" : \"\" } } } name : proxy-exist provider : arguments : proxy_name : '' func : proxy_exist module : chaostoxi.proxy.probes type : python type : probe reset \u00b6 Type action Module chaostoxi.proxy.actions Name reset Return None Enable all proxies and remove all active toxics Signature: def reset ( configuration : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required Usage: { \"name\" : \"reset\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostoxi.proxy.actions\" , \"func\" : \"reset\" } } name : reset provider : func : reset module : chaostoxi.proxy.actions type : python type : action toxic \u00b6 create_bandwith_degradation_toxic \u00b6 Type action Module chaostoxi.toxic.actions Name create_bandwith_degradation_toxic Return mapping Limit the bandwith of a downstream connection with a toxicity of 100%. Signature: def create_bandwith_degradation_toxic ( for_proxy : str , toxic_name : str , rate : int , configuration : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required for_proxy string Yes toxic_name string Yes rate integer Yes Usage: { \"name\" : \"create-bandwith-degradation-toxic\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostoxi.toxic.actions\" , \"func\" : \"create_bandwith_degradation_toxic\" , \"arguments\" : { \"for_proxy\" : \"\" , \"toxic_name\" : \"\" , \"rate\" : 0 } } } name : create-bandwith-degradation-toxic provider : arguments : for_proxy : '' rate : 0 toxic_name : '' func : create_bandwith_degradation_toxic module : chaostoxi.toxic.actions type : python type : action create_latency_toxic \u00b6 Type action Module chaostoxi.toxic.actions Name create_latency_toxic Return mapping Add a delay to all data going through the proxy using a downstream with a toxicity of 100%. Signature: def create_latency_toxic ( for_proxy : str , toxic_name : str , latency : int , jitter : int = 0 , configuration : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required for_proxy string Yes toxic_name string Yes latency integer Yes jitter integer 0 No Usage: { \"name\" : \"create-latency-toxic\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostoxi.toxic.actions\" , \"func\" : \"create_latency_toxic\" , \"arguments\" : { \"for_proxy\" : \"\" , \"toxic_name\" : \"\" , \"latency\" : 0 } } } name : create-latency-toxic provider : arguments : for_proxy : '' latency : 0 toxic_name : '' func : create_latency_toxic module : chaostoxi.toxic.actions type : python type : action create_limiter_toxic \u00b6 Type action Module chaostoxi.toxic.actions Name create_limiter_toxic Return mapping Closes connections when transmitted data after the limit, sets it up as a dowsntream, 100% toxicity. Signature: def create_limiter_toxic ( for_proxy : str , toxic_name : str , bytes_limit : int , configuration : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required for_proxy string Yes toxic_name string Yes bytes_limit integer Yes Usage: { \"name\" : \"create-limiter-toxic\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostoxi.toxic.actions\" , \"func\" : \"create_limiter_toxic\" , \"arguments\" : { \"for_proxy\" : \"\" , \"toxic_name\" : \"\" , \"bytes_limit\" : 0 } } } name : create-limiter-toxic provider : arguments : bytes_limit : 0 for_proxy : '' toxic_name : '' func : create_limiter_toxic module : chaostoxi.toxic.actions type : python type : action create_slicer_toxic \u00b6 Type action Module chaostoxi.toxic.actions Name create_slicer_toxic Return mapping Slices TCP data up into small bits, optionally adding a delay between each sliced \u201cpacket\u201d with a toxicity of 100%. Signature: def create_slicer_toxic ( for_proxy : str , toxic_name : str , average_size : int , size_variation : int , delay : int , configuration : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required for_proxy string Yes toxic_name string Yes average_size integer Yes size_variation integer Yes delay integer Yes Usage: { \"name\" : \"create-slicer-toxic\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostoxi.toxic.actions\" , \"func\" : \"create_slicer_toxic\" , \"arguments\" : { \"for_proxy\" : \"\" , \"toxic_name\" : \"\" , \"average_size\" : 0 , \"size_variation\" : 0 , \"delay\" : 0 } } } name : create-slicer-toxic provider : arguments : average_size : 0 delay : 0 for_proxy : '' size_variation : 0 toxic_name : '' func : create_slicer_toxic module : chaostoxi.toxic.actions type : python type : action create_slow_connection_close_toxic \u00b6 Type action Module chaostoxi.toxic.actions Name create_slow_connection_close_toxic Return mapping Limit the bandwith of a downstream connection with a toxicity of 100%. Signature: def create_slow_connection_close_toxic ( for_proxy : str , toxic_name : str , delay : int , configuration : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required for_proxy string Yes toxic_name string Yes delay integer Yes Usage: { \"name\" : \"create-slow-connection-close-toxic\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostoxi.toxic.actions\" , \"func\" : \"create_slow_connection_close_toxic\" , \"arguments\" : { \"for_proxy\" : \"\" , \"toxic_name\" : \"\" , \"delay\" : 0 } } } name : create-slow-connection-close-toxic provider : arguments : delay : 0 for_proxy : '' toxic_name : '' func : create_slow_connection_close_toxic module : chaostoxi.toxic.actions type : python type : action create_timeout_toxic \u00b6 Type action Module chaostoxi.toxic.actions Name create_timeout_toxic Return mapping Generate as downstream delayed TCP close with a toxicity of 100%. Signature: def create_timeout_toxic ( for_proxy : str , toxic_name : str , timeout : int , configuration : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required for_proxy string Yes toxic_name string Yes timeout integer Yes Usage: { \"name\" : \"create-timeout-toxic\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostoxi.toxic.actions\" , \"func\" : \"create_timeout_toxic\" , \"arguments\" : { \"for_proxy\" : \"\" , \"toxic_name\" : \"\" , \"timeout\" : 0 } } } name : create-timeout-toxic provider : arguments : for_proxy : '' timeout : 0 toxic_name : '' func : create_timeout_toxic module : chaostoxi.toxic.actions type : python type : action create_toxic \u00b6 Type action Module chaostoxi.toxic.actions Name create_toxic Return boolean Allows you to create any of the supported types of toxics with their attributes. Signature: def create_toxic ( for_proxy : str , toxic_name : str , toxic_type : str , stream : str = 'downstream' , toxicity : float = 1.0 , attributes : Dict [ str , Any ] = None , configuration : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required for_proxy string Yes toxic_name string Yes toxic_type string Yes stream string \u201cdownstream\u201d No toxicity number 1.0 No attributes mapping null No Usage: { \"name\" : \"create-toxic\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostoxi.toxic.actions\" , \"func\" : \"create_toxic\" , \"arguments\" : { \"for_proxy\" : \"\" , \"toxic_name\" : \"\" , \"toxic_type\" : \"\" } } } name : create-toxic provider : arguments : for_proxy : '' toxic_name : '' toxic_type : '' func : create_toxic module : chaostoxi.toxic.actions type : python type : action delete_toxic \u00b6 Type action Module chaostoxi.toxic.actions Name delete_toxic Return None Deletes the a given toxic. Signature: def delete_toxic ( for_proxy : str , toxic_name : str , configuration : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required for_proxy string Yes toxic_name string Yes Usage: { \"name\" : \"delete-toxic\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostoxi.toxic.actions\" , \"func\" : \"delete_toxic\" , \"arguments\" : { \"for_proxy\" : \"\" , \"toxic_name\" : \"\" } } } name : delete-toxic provider : arguments : for_proxy : '' toxic_name : '' func : delete_toxic module : chaostoxi.toxic.actions type : python type : action","title":"ToxiProxy"},{"location":"drivers/toxiproxy/#extension-chaostoxi","text":"Version 0.3.0 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-toxiproxy Welcome to the Chaos Toolkit driver for Toxiproxy ! This extension allows you to setup toxy proxy probes and methods from chaostoolkit by leveraging the toxyproxy http management api .","title":"Extension chaostoxi"},{"location":"drivers/toxiproxy/#install","text":"Install the Toxiproxy base client Install the Toxiproxy CLI","title":"Install"},{"location":"drivers/toxiproxy/#driver","text":"This package requires Python 3.5+ To be used from your experiment, this package must be installed in the Python environment where chaostoolkit already lives. $ pip install -U chaostoolkit-toxiproxy","title":"Driver"},{"location":"drivers/toxiproxy/#usage","text":"","title":"Usage"},{"location":"drivers/toxiproxy/#configuration","text":"First, run the Toxiproxy base client locally to create a localhost:8474 host on your computer. Then create a proxy . Next, to start using the actions and probes all you need to do is add the toxiproxy host with \u201ctoxiproxy_host\u201d as the key, and optionally the port with \u201ctoxiproxy_port\u201d as the key, to the configuration section in your experiment json. If not provided the port defaults to 8474. Alternatively, if toxiproxy api is accessible using a reverse proxy, you can use toxiproxy_url setting. Example using toxiproxy_host in experiment.json \"configuration\" : { \"toxiproxy_host\" : \"10.124.23.183\" , \"some_environment_variable\" : { \"type\" : \"environment\" , \"key\" : \"ENVIRONMENT_VARIABLE\" } }, Example using toxiproxy_url in experiment.json \"configuration\" : { \"toxiproxy_url\" : \"http://mydomain.com:8080/path-to-toxiproxy-api\" , \"some_environment_variable\" : { \"type\" : \"environment\" , \"key\" : \"ENVIRONMENT_VARIABLE\" } }, This extension follows the toxiproxy rules. A proxy is the channel where toxicity can be added. For this reason the extension is broken into proxy management and toxic management. All actions and probes in the extension are of python type and are used like any other python extension.","title":"Configuration"},{"location":"drivers/toxiproxy/#proxy-actions","text":"","title":"Proxy actions"},{"location":"drivers/toxiproxy/#create_proxy","text":"Creates a proxy to which toxics can be added. In toxiproxy a listen port of value 0 tells the API to assign a random available port. The value where the proxy is listenting will be attached to the chaostoolkit configuration object as \\<proxyname>_PORT . Should the creation of the proxy fail, an assertion error is raised stopping all subsequent actions. Argument Description Required Default proxy_name name for the proxy Yes None upstream_host ip address of the host to send traffic to Yes None upstream_port port of the application to send traffic to Yes None listen_host IP address to bind where toxiproxy listens No 0.0.0.0 listen_port port to listen for requests, 0 means pick random value No 0 enabled Whether to start listening or not No True","title":"create_proxy"},{"location":"drivers/toxiproxy/#modify_proxy","text":"Modify the configuration of a given proxy. Useful to change the upstream configiuration. Only arguments supplied result in modification of the proxy. Argument Description Required Default proxy_name name for the proxy Yes None listen_addres ip:port address to modify No None upstream_addres ip:port of the upstream No None enabled Toggle enabled/disabled state No None","title":"modify_proxy"},{"location":"drivers/toxiproxy/#disable_proxy","text":"Disables the proxy, this is useful to simulate a proxied service being down. Argument Description Required Default proxy_name name for the proxy to disable Yes None","title":"disable_proxy"},{"location":"drivers/toxiproxy/#enable_proxy","text":"Enables a disabled proxy. Argument Description Required Default proxy_name name for the proxy to enable Yes None","title":"enable_proxy"},{"location":"drivers/toxiproxy/#delete_proxy","text":"Removes the proxy from the system. Example usage \"method\" : [ { \"type\" : \"action\" , \"name\" : \"setup_toxiproxy_proxy\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostoxi.proxy.actions\" , \"func\" : \"create_proxy\" , \"arguments\" : { \"proxy_name\" : \"myproxy\" , \"listen_port\" : 6666 , \"upstream_host\" : \"10.28.188.118\" , \"upstream_port\" : 6040 } }, \"pauses\" : { \"after\" : 1 } } ]","title":"delete_proxy"},{"location":"drivers/toxiproxy/#reset","text":"Enable all proxies and remove all active toxics. Example usage: \"method\" : [ { \"type\" : \"action\" , \"name\" : \"reset all proxies\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostoxi.proxy.actions\" , \"func\" : \"reset\" }, \"pauses\" : { \"after\" : 1 } } ]","title":"reset"},{"location":"drivers/toxiproxy/#proxy-pobes","text":"","title":"Proxy pobes"},{"location":"drivers/toxiproxy/#proxy_exist","text":"Returns True of False if a given proxy exists. Argument Description Required Default proxy_name name for the proxy Yes None","title":"proxy_exist"},{"location":"drivers/toxiproxy/#toxic-actions","text":"All actions provided by this extension match the types and attributes of toxics .","title":"Toxic actions"},{"location":"drivers/toxiproxy/#create_toxic","text":"Allows you to create any of the supported types of toxics with their attributes. Argument Description Required Default for_proxy name for the proxy to attach the toxy Yes None toxic_name name for this toxy Yes None toxic_type A valid toxic type Yes None stream The direction of the toxic \u201cupstream\u201d or \u201cdownstream\u201d No downstream toxicity Percentage of toxiciy 1.0 is 100%, 0.5 is 50% etc No 1.0 attributes Dictionary of attributes for the type of toxic No None","title":"create_toxic"},{"location":"drivers/toxiproxy/#create_latency_toxic","text":"Add a delay to all data going through the proxy using a downstream with a toxicity of 100%. Argument Description Required Default for_proxy name for the proxy to attach the toxy Yes None toxic_name name for this toxy Yes None latency time in milliseconds to add for latency Yes None jitter time in milliseconds to jitter No 0","title":"create_latency_toxic"},{"location":"drivers/toxiproxy/#create_bandwith_degradation_toxic","text":"Limit the bandwith of a downstream connection with a toxicity of 100%. Argument Description Required Default for_proxy name for the proxy to attach the toxy Yes None toxic_name name for this toxy Yes None rate desired bandwith rate in KB/s Yes None","title":"create_bandwith_degradation_toxic"},{"location":"drivers/toxiproxy/#create_slow_connection_close_toxic","text":"Generate as downstream delayed TCP close with a toxicity of 100%. Argument Description Required Default for_proxy name for the proxy to attach the toxy Yes None toxic_name name for this toxy Yes None delay desired close delay in milliseconds Yes None","title":"create_slow_connection_close_toxic"},{"location":"drivers/toxiproxy/#create_slicer_toxic","text":"Slices TCP data up into small bits, optionally adding a delay between each sliced \u201cpacket\u201d with a toxicity of 100%. Argument Description Required Default for_proxy name for the proxy to attach the toxy Yes None toxic_name name for this toxy Yes None average_size size in bytes for the average package Yes None size_variation variation in bytes of an average pkg (should be smaller than average_size) Yes None delay time in microseconds to delay each packet by Yes None","title":"create_slicer_toxic"},{"location":"drivers/toxiproxy/#create_limiter_toxic","text":"Closes connections when transmitted data after the limit, sets it up as a dowsntream, 100% toxicity. Argument Description Required Default for_proxy name for the proxy to attach the toxy Yes None toxic_name name for this toxy Yes None bytes number of bytes to transmit before connection is closed Yes None","title":"create_limiter_toxic"},{"location":"drivers/toxiproxy/#delete_toxic","text":"Deletes the a given toxic. Argument Description Required Default for_proxy name for the proxy to attach the toxy Yes None toxic_name name for this toxy Yes None Example usage: \"method\" : [ { \"type\" : \"action\" , \"name\" : \"create_latency_toxic\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"toxiproxy.toxic.actions\" , \"func\" : \"create_dowsntream_latency_toxic\" , \"arguments\" : { \"for_proxy\" : \"edsproxy\" , \"toxic_name\" : \"latency_toxic\" , \"latency\" : 5000 , \"jitter\" : 200 } }, \"pauses\" : { \"after\" : 1 } } ]","title":"delete_toxic"},{"location":"drivers/toxiproxy/#contribute","text":"If you wish to contribute more functions to this package, you are more than welcome to do so. Please, fork this project, make your changes following the usual PEP 8 code style, sprinkling with tests and submit a PR for review. The Chaos Toolkit projects require all contributors must sign a Developer Certificate of Origin on each commit they would like to merge into the master branch of the repository. Please, make sure you can abide by the rules of the DCO before submitting a PR.","title":"Contribute"},{"location":"drivers/toxiproxy/#develop","text":"If you wish to develop on this project, make sure to install the development dependencies. But first, create a virtual environment and then install those dependencies. $ pip install -r requirements-dev.txt -r requirements.txt Then, point your environment to this directory: $ python setup.py develop Now, you can edit the files and they will be automatically be seen by your environment, even when running from the chaos command locally.","title":"Develop"},{"location":"drivers/toxiproxy/#test","text":"To run the unit tests for the project execute the following: $ pytest To run the integration tests for the project execute the following: $ tox","title":"Test"},{"location":"drivers/toxiproxy/#exported-activities","text":"","title":"Exported Activities"},{"location":"drivers/toxiproxy/#proxy","text":"","title":"proxy"},{"location":"drivers/toxiproxy/#create_proxy_1","text":"Type action Module chaostoxi.proxy.actions Name create_proxy Return None Creates a proxy to which toxics can be added. Signature: def create_proxy ( proxy_name : str , upstream_host : str , upstream_port : int , listen_host : str = '0.0.0.0' , listen_port : int = 0 , enabled : bool = True , configuration : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required proxy_name string Yes upstream_host string Yes upstream_port integer Yes listen_host string \u201c0.0.0.0\u201d No listen_port integer 0 No enabled boolean true No Usage: { \"name\" : \"create-proxy\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostoxi.proxy.actions\" , \"func\" : \"create_proxy\" , \"arguments\" : { \"proxy_name\" : \"\" , \"upstream_host\" : \"\" , \"upstream_port\" : 0 } } } name : create-proxy provider : arguments : proxy_name : '' upstream_host : '' upstream_port : 0 func : create_proxy module : chaostoxi.proxy.actions type : python type : action","title":"create_proxy"},{"location":"drivers/toxiproxy/#delete_proxy_1","text":"Type action Module chaostoxi.proxy.actions Name delete_proxy Return None Removes the proxy from the system. Signature: def delete_proxy ( proxy_name : str , configuration : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required proxy_name string Yes Usage: { \"name\" : \"delete-proxy\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostoxi.proxy.actions\" , \"func\" : \"delete_proxy\" , \"arguments\" : { \"proxy_name\" : \"\" } } } name : delete-proxy provider : arguments : proxy_name : '' func : delete_proxy module : chaostoxi.proxy.actions type : python type : action","title":"delete_proxy"},{"location":"drivers/toxiproxy/#disable_proxy_1","text":"Type action Module chaostoxi.proxy.actions Name disable_proxy Return None Disables the proxy, this is useful to simulate a proxied service being down. Signature: def disable_proxy ( proxy_name : str , configuration : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required proxy_name string Yes Usage: { \"name\" : \"disable-proxy\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostoxi.proxy.actions\" , \"func\" : \"disable_proxy\" , \"arguments\" : { \"proxy_name\" : \"\" } } } name : disable-proxy provider : arguments : proxy_name : '' func : disable_proxy module : chaostoxi.proxy.actions type : python type : action","title":"disable_proxy"},{"location":"drivers/toxiproxy/#enable_proxy_1","text":"Type action Module chaostoxi.proxy.actions Name enable_proxy Return None Enables a disabled proxy. Signature: def enable_proxy ( proxy_name : str , configuration : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required proxy_name string Yes Usage: { \"name\" : \"enable-proxy\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostoxi.proxy.actions\" , \"func\" : \"enable_proxy\" , \"arguments\" : { \"proxy_name\" : \"\" } } } name : enable-proxy provider : arguments : proxy_name : '' func : enable_proxy module : chaostoxi.proxy.actions type : python type : action","title":"enable_proxy"},{"location":"drivers/toxiproxy/#get_proxy_attribute","text":"Type probe Module chaostoxi.proxy.probes Name get_proxy_attribute Return None Returns an attribute of a specified proxy. Signature: def get_proxy_attribute ( proxy_name : str , attribute : str , configuration : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required proxy_name string Yes attribute string Yes Usage: { \"name\" : \"get-proxy-attribute\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostoxi.proxy.probes\" , \"func\" : \"get_proxy_attribute\" , \"arguments\" : { \"proxy_name\" : \"\" , \"attribute\" : \"\" } } } name : get-proxy-attribute provider : arguments : attribute : '' proxy_name : '' func : get_proxy_attribute module : chaostoxi.proxy.probes type : python type : probe","title":"get_proxy_attribute"},{"location":"drivers/toxiproxy/#modify_proxy_1","text":"Type action Module chaostoxi.proxy.actions Name modify_proxy Return None Modify the configuration of a given proxy. Useful to change the upstream configiuration. Only arguments supplied result in modification of the proxy. Signature: def modify_proxy ( proxy_name : str , listen_address : str = None , upstream_address : str = None , enabled : bool = None , configuration : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required proxy_name string Yes listen_address string null No upstream_address string null No enabled boolean null No Usage: { \"name\" : \"modify-proxy\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostoxi.proxy.actions\" , \"func\" : \"modify_proxy\" , \"arguments\" : { \"proxy_name\" : \"\" } } } name : modify-proxy provider : arguments : proxy_name : '' func : modify_proxy module : chaostoxi.proxy.actions type : python type : action","title":"modify_proxy"},{"location":"drivers/toxiproxy/#proxy_exist_1","text":"Type probe Module chaostoxi.proxy.probes Name proxy_exist Return None Returns True of False if a given proxy exists. Signature: def proxy_exist ( proxy_name : str , configuration : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required proxy_name string Yes Usage: { \"name\" : \"proxy-exist\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostoxi.proxy.probes\" , \"func\" : \"proxy_exist\" , \"arguments\" : { \"proxy_name\" : \"\" } } } name : proxy-exist provider : arguments : proxy_name : '' func : proxy_exist module : chaostoxi.proxy.probes type : python type : probe","title":"proxy_exist"},{"location":"drivers/toxiproxy/#reset_1","text":"Type action Module chaostoxi.proxy.actions Name reset Return None Enable all proxies and remove all active toxics Signature: def reset ( configuration : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required Usage: { \"name\" : \"reset\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostoxi.proxy.actions\" , \"func\" : \"reset\" } } name : reset provider : func : reset module : chaostoxi.proxy.actions type : python type : action","title":"reset"},{"location":"drivers/toxiproxy/#toxic","text":"","title":"toxic"},{"location":"drivers/toxiproxy/#create_bandwith_degradation_toxic_1","text":"Type action Module chaostoxi.toxic.actions Name create_bandwith_degradation_toxic Return mapping Limit the bandwith of a downstream connection with a toxicity of 100%. Signature: def create_bandwith_degradation_toxic ( for_proxy : str , toxic_name : str , rate : int , configuration : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required for_proxy string Yes toxic_name string Yes rate integer Yes Usage: { \"name\" : \"create-bandwith-degradation-toxic\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostoxi.toxic.actions\" , \"func\" : \"create_bandwith_degradation_toxic\" , \"arguments\" : { \"for_proxy\" : \"\" , \"toxic_name\" : \"\" , \"rate\" : 0 } } } name : create-bandwith-degradation-toxic provider : arguments : for_proxy : '' rate : 0 toxic_name : '' func : create_bandwith_degradation_toxic module : chaostoxi.toxic.actions type : python type : action","title":"create_bandwith_degradation_toxic"},{"location":"drivers/toxiproxy/#create_latency_toxic_1","text":"Type action Module chaostoxi.toxic.actions Name create_latency_toxic Return mapping Add a delay to all data going through the proxy using a downstream with a toxicity of 100%. Signature: def create_latency_toxic ( for_proxy : str , toxic_name : str , latency : int , jitter : int = 0 , configuration : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required for_proxy string Yes toxic_name string Yes latency integer Yes jitter integer 0 No Usage: { \"name\" : \"create-latency-toxic\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostoxi.toxic.actions\" , \"func\" : \"create_latency_toxic\" , \"arguments\" : { \"for_proxy\" : \"\" , \"toxic_name\" : \"\" , \"latency\" : 0 } } } name : create-latency-toxic provider : arguments : for_proxy : '' latency : 0 toxic_name : '' func : create_latency_toxic module : chaostoxi.toxic.actions type : python type : action","title":"create_latency_toxic"},{"location":"drivers/toxiproxy/#create_limiter_toxic_1","text":"Type action Module chaostoxi.toxic.actions Name create_limiter_toxic Return mapping Closes connections when transmitted data after the limit, sets it up as a dowsntream, 100% toxicity. Signature: def create_limiter_toxic ( for_proxy : str , toxic_name : str , bytes_limit : int , configuration : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required for_proxy string Yes toxic_name string Yes bytes_limit integer Yes Usage: { \"name\" : \"create-limiter-toxic\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostoxi.toxic.actions\" , \"func\" : \"create_limiter_toxic\" , \"arguments\" : { \"for_proxy\" : \"\" , \"toxic_name\" : \"\" , \"bytes_limit\" : 0 } } } name : create-limiter-toxic provider : arguments : bytes_limit : 0 for_proxy : '' toxic_name : '' func : create_limiter_toxic module : chaostoxi.toxic.actions type : python type : action","title":"create_limiter_toxic"},{"location":"drivers/toxiproxy/#create_slicer_toxic_1","text":"Type action Module chaostoxi.toxic.actions Name create_slicer_toxic Return mapping Slices TCP data up into small bits, optionally adding a delay between each sliced \u201cpacket\u201d with a toxicity of 100%. Signature: def create_slicer_toxic ( for_proxy : str , toxic_name : str , average_size : int , size_variation : int , delay : int , configuration : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required for_proxy string Yes toxic_name string Yes average_size integer Yes size_variation integer Yes delay integer Yes Usage: { \"name\" : \"create-slicer-toxic\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostoxi.toxic.actions\" , \"func\" : \"create_slicer_toxic\" , \"arguments\" : { \"for_proxy\" : \"\" , \"toxic_name\" : \"\" , \"average_size\" : 0 , \"size_variation\" : 0 , \"delay\" : 0 } } } name : create-slicer-toxic provider : arguments : average_size : 0 delay : 0 for_proxy : '' size_variation : 0 toxic_name : '' func : create_slicer_toxic module : chaostoxi.toxic.actions type : python type : action","title":"create_slicer_toxic"},{"location":"drivers/toxiproxy/#create_slow_connection_close_toxic_1","text":"Type action Module chaostoxi.toxic.actions Name create_slow_connection_close_toxic Return mapping Limit the bandwith of a downstream connection with a toxicity of 100%. Signature: def create_slow_connection_close_toxic ( for_proxy : str , toxic_name : str , delay : int , configuration : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required for_proxy string Yes toxic_name string Yes delay integer Yes Usage: { \"name\" : \"create-slow-connection-close-toxic\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostoxi.toxic.actions\" , \"func\" : \"create_slow_connection_close_toxic\" , \"arguments\" : { \"for_proxy\" : \"\" , \"toxic_name\" : \"\" , \"delay\" : 0 } } } name : create-slow-connection-close-toxic provider : arguments : delay : 0 for_proxy : '' toxic_name : '' func : create_slow_connection_close_toxic module : chaostoxi.toxic.actions type : python type : action","title":"create_slow_connection_close_toxic"},{"location":"drivers/toxiproxy/#create_timeout_toxic","text":"Type action Module chaostoxi.toxic.actions Name create_timeout_toxic Return mapping Generate as downstream delayed TCP close with a toxicity of 100%. Signature: def create_timeout_toxic ( for_proxy : str , toxic_name : str , timeout : int , configuration : Dict [ str , Dict [ str , str ]] = None ) -> Dict [ str , Any ]: pass Arguments: Name Type Default Required for_proxy string Yes toxic_name string Yes timeout integer Yes Usage: { \"name\" : \"create-timeout-toxic\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostoxi.toxic.actions\" , \"func\" : \"create_timeout_toxic\" , \"arguments\" : { \"for_proxy\" : \"\" , \"toxic_name\" : \"\" , \"timeout\" : 0 } } } name : create-timeout-toxic provider : arguments : for_proxy : '' timeout : 0 toxic_name : '' func : create_timeout_toxic module : chaostoxi.toxic.actions type : python type : action","title":"create_timeout_toxic"},{"location":"drivers/toxiproxy/#create_toxic_1","text":"Type action Module chaostoxi.toxic.actions Name create_toxic Return boolean Allows you to create any of the supported types of toxics with their attributes. Signature: def create_toxic ( for_proxy : str , toxic_name : str , toxic_type : str , stream : str = 'downstream' , toxicity : float = 1.0 , attributes : Dict [ str , Any ] = None , configuration : Dict [ str , Dict [ str , str ]] = None ) -> bool : pass Arguments: Name Type Default Required for_proxy string Yes toxic_name string Yes toxic_type string Yes stream string \u201cdownstream\u201d No toxicity number 1.0 No attributes mapping null No Usage: { \"name\" : \"create-toxic\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostoxi.toxic.actions\" , \"func\" : \"create_toxic\" , \"arguments\" : { \"for_proxy\" : \"\" , \"toxic_name\" : \"\" , \"toxic_type\" : \"\" } } } name : create-toxic provider : arguments : for_proxy : '' toxic_name : '' toxic_type : '' func : create_toxic module : chaostoxi.toxic.actions type : python type : action","title":"create_toxic"},{"location":"drivers/toxiproxy/#delete_toxic_1","text":"Type action Module chaostoxi.toxic.actions Name delete_toxic Return None Deletes the a given toxic. Signature: def delete_toxic ( for_proxy : str , toxic_name : str , configuration : Dict [ str , Dict [ str , str ]] = None ): pass Arguments: Name Type Default Required for_proxy string Yes toxic_name string Yes Usage: { \"name\" : \"delete-toxic\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostoxi.toxic.actions\" , \"func\" : \"delete_toxic\" , \"arguments\" : { \"for_proxy\" : \"\" , \"toxic_name\" : \"\" } } } name : delete-toxic provider : arguments : for_proxy : '' toxic_name : '' func : delete_toxic module : chaostoxi.toxic.actions type : python type : action","title":"delete_toxic"},{"location":"drivers/wiremock/","text":"Extension chaoswm \u00b6 Version 0.1.2 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-wiremock ===================== Chaos Toolkit driver for WireMock . Package installation \u00b6 To install the package from pypi.org: pip install -U chaostoolkit-wiremock Installation from source \u00b6 In order to use it, you need python 3.5+ in your environment. Once downloaded the project, cd into it and run: pip install -r requirements.txt -r requirements-dev.txt make clean && make test && make install Configuration \u00b6 The following keys can be configured in the experiment global configuration section, under the \"wiremock\" key: host : the wiremock server host port : the wiremock server port contextPath : the contextPath for your wiremock server (optional) timeout : accepted timeout (defaults to 1 sec) down : the delayDistribution section used by the down action Configuration example: { \"configuration\": { \"wiremock\": { \"host\": \"localhost\", \"port\": 8080, \"contextPath\": \"/wiremock\", \"timeout\": 10, \"down\": { \"type\": \"lognormal\", \"median\": 3000, \"sigma\": 0.2 } } } } Exported Actions \u00b6 Adding a list of mappings: { \"method\": [ { \"type\": \"action\", \"name\": \"adding a mapping\", \"provider\": { \"type\": \"python\", \"module\": \"chaoswm.actions\", \"func\": \"add_mappings\", \"arguments\": { \"mappings\": [{ \"request\": { \"method\": \"GET\", \"url\": \"/hello\" }, \"response\": { \"status\": 200, \"body\": \"Hello world!\", \"headers\": { \"Content-Type\": \"text/plain\" } } }] } } } ] } Deleting a list of mappings: { \"method\": [ { \"type\": \"action\", \"name\": \"deleting a mapping\", \"provider\": { \"type\": \"python\", \"module\": \"chaoswm.actions\", \"func\": \"delete_mappings\", \"arguments\": { \"filter\": [{ \"method\": \"GET\", \"url\": \"/hello\" }] } } } ] } Adding a global fixed delay: { \"method\": [ { \"type\": \"action\", \"name\": \"Adding a global fixed delay\", \"provider\": { \"type\": \"python\", \"module\": \"chaoswm.actions\", \"func\": \"global_fixed_delay\", \"arguments\": { \"fixedDelay\": 10 } } } ] } Adding a global random delay: { \"method\": [ { \"type\": \"action\", \"name\": \"Adding a global random delay\", \"provider\": { \"type\": \"python\", \"module\": \"chaoswm.actions\", \"func\": \"global_random_delay\", \"arguments\": { \"delayDistribution\": { \"type\": \"lognormal\", \"median\": 20, \"sigma\": 0.1 } } } } ] } Adding a fixed delay to a list of mappings: { \"method\": [ { \"type\": \"action\", \"name\": \"Adding a fixed delay to a mapping\", \"provider\": { \"type\": \"python\", \"module\": \"chaoswm.actions\", \"func\": \"fixed_delay\", \"arguments\": { \"filter\": [{ \"method\": \"GET\", \"url\": \"/hello1\" }], \"fixedDelayMilliseconds\": 1000 } } } ] } Adding a random delay to a list of mappings: { \"method\": [ { \"type\": \"action\", \"name\": \"Adding a random delay to a mapping\", \"provider\": { \"type\": \"python\", \"module\": \"chaoswm.actions\", \"func\": \"random_delay\", \"arguments\": { \"filter\": [{ \"method\": \"GET\", \"url\": \"/hello2\" }], \"delayDistribution\": { \"type\": \"lognormal\", \"median\": 2000, \"sigma\": 0.5 } } } } ] } Adding a ChunkedDribbleDelay to a list of mappings: { \"method\": [ { \"type\": \"action\", \"name\": \"Adding a ChunkedDribbleDelay to a mapping\", \"provider\": { \"type\": \"python\", \"module\": \"chaoswm.actions\", \"func\": \"chunked_dribble_delay\", \"arguments\": { \"filter\": [{ \"method\": \"GET\", \"url\": \"/hello\" }], \"chunkedDribbleDelay\": { \"numberOfChunks\": 5, \"totalDuration\": 1000 } } } } ] } Taking a list of mappings down (heavy distribution delay). This action will use the parameters specified in the \"down\" key of the configuration section: { \"method\": [ { \"type\": \"action\", \"name\": \"Taking a mapping down\", \"provider\": { \"type\": \"python\", \"module\": \"chaoswm.actions\", \"func\": \"down\", \"arguments\": { \"filter\": [{ \"method\": \"GET\", \"url\": \"/hello\" }] } } } ] } Taking a list of mappings up back again: { \"method\": [ { \"type\": \"action\", \"name\": \"Taking a mapping down\", \"provider\": { \"type\": \"python\", \"module\": \"chaoswm.actions\", \"func\": \"up\", \"arguments\": { \"filter\": [{ \"method\": \"GET\", \"url\": \"/hello\" }] } } } ] } Resetting the wiremock server (deleting all mappings): { \"method\": [ { \"type\": \"action\", \"name\": \"Taking a mapping down\", \"provider\": { \"type\": \"python\", \"module\": \"chaoswm.actions\", \"func\": \"reset\" } } ] } Experiments \u00b6 The driver comes with an experiments directory where you can find snippets to test all APIs against a WireMock server listening on localhost:8080. Discovery \u00b6 You may use the Chaos Toolkit to discover the capabilities of this extension: $ chaos discover chaostoolkit-wiremock --no-install Credits \u00b6 This package was created with Cookiecutter and the audreyr/cookiecutter-pypackage project template. Exported Activities \u00b6 actions \u00b6 add_mappings \u00b6 Type action Module chaoswm.actions Name add_mappings Return list adds more mappings to wiremock returns the list of ids of the mappings added Signature: def add_mappings ( mappings : List [ Any ], configuration : Dict [ str , Dict [ str , str ]] = None ) -> List [ Any ]: pass Arguments: Name Type Default Required mappings list Yes Usage: { \"name\" : \"add-mappings\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoswm.actions\" , \"func\" : \"add_mappings\" , \"arguments\" : { \"mappings\" : [] } } } name : add-mappings provider : arguments : mappings : [] func : add_mappings module : chaoswm.actions type : python type : action chunked_dribble_delay \u00b6 Type action Module chaoswm.actions Name chunked_dribble_delay Return list adds a chunked dribble delay to a list of mappings Signature: def chunked_dribble_delay ( filter : List [ Any ], chunkedDribbleDelay : Mapping [ str , Any ], configuration : Dict [ str , Dict [ str , str ]] = None ) -> List [ Any ]: pass Arguments: Name Type Default Required filter list Yes chunkedDribbleDelay object Yes Usage: { \"name\" : \"chunked-dribble-delay\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoswm.actions\" , \"func\" : \"chunked_dribble_delay\" , \"arguments\" : { \"filter\" : [], \"chunkedDribbleDelay\" : null } } } name : chunked-dribble-delay provider : arguments : chunkedDribbleDelay : null filter : [] func : chunked_dribble_delay module : chaoswm.actions type : python type : action delete_mappings \u00b6 Type action Module chaoswm.actions Name delete_mappings Return list deletes a list of mappings returns the list of ids of the mappings deleted Signature: def delete_mappings ( filter : List [ Any ], configuration : Dict [ str , Dict [ str , str ]] = None ) -> List [ Any ]: pass Arguments: Name Type Default Required filter list Yes Usage: { \"name\" : \"delete-mappings\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoswm.actions\" , \"func\" : \"delete_mappings\" , \"arguments\" : { \"filter\" : [] } } } name : delete-mappings provider : arguments : filter : [] func : delete_mappings module : chaoswm.actions type : python type : action down \u00b6 Type action Module chaoswm.actions Name down Return list set a list of services down more correctly it adds a chunked dribble delay to the mapping as defined in the configuration section (or action attributes) Returns the list of delayed mappings Signature: def down ( filter : List [ Any ], configuration : Dict [ str , Dict [ str , str ]] = None ) -> List [ Any ]: pass Arguments: Name Type Default Required filter list Yes Usage: { \"name\" : \"down\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoswm.actions\" , \"func\" : \"down\" , \"arguments\" : { \"filter\" : [] } } } name : down provider : arguments : filter : [] func : down module : chaoswm.actions type : python type : action fixed_delay \u00b6 Type action Module chaoswm.actions Name fixed_delay Return list adds a fixed delay to a list of mappings Signature: def fixed_delay ( filter : List [ Any ], fixedDelayMilliseconds : int , configuration : Dict [ str , Dict [ str , str ]] = None ) -> List [ Any ]: pass Arguments: Name Type Default Required filter list Yes fixedDelayMilliseconds integer Yes Usage: { \"name\" : \"fixed-delay\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoswm.actions\" , \"func\" : \"fixed_delay\" , \"arguments\" : { \"filter\" : [], \"fixedDelayMilliseconds\" : 0 } } } name : fixed-delay provider : arguments : filter : [] fixedDelayMilliseconds : 0 func : fixed_delay module : chaoswm.actions type : python type : action global_fixed_delay \u00b6 Type action Module chaoswm.actions Name global_fixed_delay Return integer add a fixed delay to all mappings Signature: def global_fixed_delay ( fixedDelay : int = 0 , configuration : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required fixedDelay integer 0 No Usage: { \"name\" : \"global-fixed-delay\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoswm.actions\" , \"func\" : \"global_fixed_delay\" } } name : global-fixed-delay provider : func : global_fixed_delay module : chaoswm.actions type : python type : action global_random_delay \u00b6 Type action Module chaoswm.actions Name global_random_delay Return integer adds a random delay to all mappings Signature: def global_random_delay ( delayDistribution : Mapping [ str , Any ], configuration : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required delayDistribution object Yes Usage: { \"name\" : \"global-random-delay\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoswm.actions\" , \"func\" : \"global_random_delay\" , \"arguments\" : { \"delayDistribution\" : null } } } name : global-random-delay provider : arguments : delayDistribution : null func : global_random_delay module : chaoswm.actions type : python type : action populate_from_dir \u00b6 Type action Module chaoswm.actions Name populate_from_dir Return list adds all mappings found in the passed folder returns the list of ids of the mappings added Signature: def populate_from_dir ( dir : str = '.' , configuration : Dict [ str , Dict [ str , str ]] = None ) -> List [ Any ]: pass Arguments: Name Type Default Required dir string \u201d.\u201d No Usage: { \"name\" : \"populate-from-dir\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoswm.actions\" , \"func\" : \"populate_from_dir\" } } name : populate-from-dir provider : func : populate_from_dir module : chaoswm.actions type : python type : action random_delay \u00b6 Type action Module chaoswm.actions Name random_delay Return list adds a random delay to a list of mapppings Signature: def random_delay ( filter : List [ Any ], delayDistribution : Mapping [ str , Any ], configuration : Dict [ str , Dict [ str , str ]] = None ) -> List [ Any ]: pass Arguments: Name Type Default Required filter list Yes delayDistribution object Yes Usage: { \"name\" : \"random-delay\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoswm.actions\" , \"func\" : \"random_delay\" , \"arguments\" : { \"filter\" : [], \"delayDistribution\" : null } } } name : random-delay provider : arguments : delayDistribution : null filter : [] func : random_delay module : chaoswm.actions type : python type : action reset \u00b6 Type action Module chaoswm.actions Name reset Return integer resets the wiremock server: deletes all mappings! Signature: def reset ( configuration : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required Usage: { \"name\" : \"reset\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoswm.actions\" , \"func\" : \"reset\" } } name : reset provider : func : reset module : chaoswm.actions type : python type : action up \u00b6 Type action Module chaoswm.actions Name up Return list deletes all delays connected with a list of mappings Signature: def up ( filter : List [ Any ], configuration : Dict [ str , Dict [ str , str ]] = None ) -> List [ Any ]: pass Arguments: Name Type Default Required filter list Yes Usage: { \"name\" : \"up\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoswm.actions\" , \"func\" : \"up\" , \"arguments\" : { \"filter\" : [] } } } name : up provider : arguments : filter : [] func : up module : chaoswm.actions type : python type : action probes \u00b6 mappings \u00b6 Type probe Module chaoswm.probes Name mappings Return list Signature: def mappings ( c : Dict [ str , Dict [ str , str ]] = None ) -> List [ Any ]: pass Arguments: Name Type Default Required c mapping null No Usage: { \"name\" : \"mappings\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoswm.probes\" , \"func\" : \"mappings\" } } name : mappings provider : func : mappings module : chaoswm.probes type : python type : probe server_running \u00b6 Type probe Module chaoswm.probes Name server_running Return integer Signature: def server_running ( c : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required c mapping null No Usage: { \"name\" : \"server-running\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoswm.probes\" , \"func\" : \"server_running\" } } name : server-running provider : func : server_running module : chaoswm.probes type : python type : probe utils \u00b6 can_connect_to \u00b6 Type Module chaoswm.utils Name can_connect_to Return boolean Test a connection to a host/port Signature: def can_connect_to ( host : str , port : int ) -> bool : pass Arguments: Name Type Default Required host string Yes port integer Yes Usage: { \"name\" : \"can-connect-to\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoswm.utils\" , \"func\" : \"can_connect_to\" , \"arguments\" : { \"host\" : \"\" , \"port\" : 0 } } } name : can-connect-to provider : arguments : host : '' port : 0 func : can_connect_to module : chaoswm.utils type : python type : '' check_configuration \u00b6 Type Module chaoswm.utils Name check_configuration Return boolean Signature: def check_configuration ( c : Dict [ str , Any ] = None ) -> bool : pass Arguments: Name Type Default Required c mapping null No Usage: { \"name\" : \"check-configuration\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoswm.utils\" , \"func\" : \"check_configuration\" } } name : check-configuration provider : func : check_configuration module : chaoswm.utils type : python type : '' get_wm_params \u00b6 Type Module chaoswm.utils Name get_wm_params Return Union[Dict[str, Any], NoneType] Signature: def get_wm_params ( c : Dict [ str , Any ]) -> Union [ Dict [ str , Any ], NoneType ]: pass Arguments: Name Type Default Required c mapping Yes Usage: { \"name\" : \"get-wm-params\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoswm.utils\" , \"func\" : \"get_wm_params\" , \"arguments\" : { \"c\" : {} } } } name : get-wm-params provider : arguments : c : {} func : get_wm_params module : chaoswm.utils type : python type : ''","title":"WireMock"},{"location":"drivers/wiremock/#extension-chaoswm","text":"Version 0.1.2 Repository https://github.com/chaostoolkit-incubator/chaostoolkit-wiremock ===================== Chaos Toolkit driver for WireMock .","title":"Extension chaoswm"},{"location":"drivers/wiremock/#package-installation","text":"To install the package from pypi.org: pip install -U chaostoolkit-wiremock","title":"Package installation"},{"location":"drivers/wiremock/#installation-from-source","text":"In order to use it, you need python 3.5+ in your environment. Once downloaded the project, cd into it and run: pip install -r requirements.txt -r requirements-dev.txt make clean && make test && make install","title":"Installation from source"},{"location":"drivers/wiremock/#configuration","text":"The following keys can be configured in the experiment global configuration section, under the \"wiremock\" key: host : the wiremock server host port : the wiremock server port contextPath : the contextPath for your wiremock server (optional) timeout : accepted timeout (defaults to 1 sec) down : the delayDistribution section used by the down action Configuration example: { \"configuration\": { \"wiremock\": { \"host\": \"localhost\", \"port\": 8080, \"contextPath\": \"/wiremock\", \"timeout\": 10, \"down\": { \"type\": \"lognormal\", \"median\": 3000, \"sigma\": 0.2 } } } }","title":"Configuration"},{"location":"drivers/wiremock/#exported-actions","text":"Adding a list of mappings: { \"method\": [ { \"type\": \"action\", \"name\": \"adding a mapping\", \"provider\": { \"type\": \"python\", \"module\": \"chaoswm.actions\", \"func\": \"add_mappings\", \"arguments\": { \"mappings\": [{ \"request\": { \"method\": \"GET\", \"url\": \"/hello\" }, \"response\": { \"status\": 200, \"body\": \"Hello world!\", \"headers\": { \"Content-Type\": \"text/plain\" } } }] } } } ] } Deleting a list of mappings: { \"method\": [ { \"type\": \"action\", \"name\": \"deleting a mapping\", \"provider\": { \"type\": \"python\", \"module\": \"chaoswm.actions\", \"func\": \"delete_mappings\", \"arguments\": { \"filter\": [{ \"method\": \"GET\", \"url\": \"/hello\" }] } } } ] } Adding a global fixed delay: { \"method\": [ { \"type\": \"action\", \"name\": \"Adding a global fixed delay\", \"provider\": { \"type\": \"python\", \"module\": \"chaoswm.actions\", \"func\": \"global_fixed_delay\", \"arguments\": { \"fixedDelay\": 10 } } } ] } Adding a global random delay: { \"method\": [ { \"type\": \"action\", \"name\": \"Adding a global random delay\", \"provider\": { \"type\": \"python\", \"module\": \"chaoswm.actions\", \"func\": \"global_random_delay\", \"arguments\": { \"delayDistribution\": { \"type\": \"lognormal\", \"median\": 20, \"sigma\": 0.1 } } } } ] } Adding a fixed delay to a list of mappings: { \"method\": [ { \"type\": \"action\", \"name\": \"Adding a fixed delay to a mapping\", \"provider\": { \"type\": \"python\", \"module\": \"chaoswm.actions\", \"func\": \"fixed_delay\", \"arguments\": { \"filter\": [{ \"method\": \"GET\", \"url\": \"/hello1\" }], \"fixedDelayMilliseconds\": 1000 } } } ] } Adding a random delay to a list of mappings: { \"method\": [ { \"type\": \"action\", \"name\": \"Adding a random delay to a mapping\", \"provider\": { \"type\": \"python\", \"module\": \"chaoswm.actions\", \"func\": \"random_delay\", \"arguments\": { \"filter\": [{ \"method\": \"GET\", \"url\": \"/hello2\" }], \"delayDistribution\": { \"type\": \"lognormal\", \"median\": 2000, \"sigma\": 0.5 } } } } ] } Adding a ChunkedDribbleDelay to a list of mappings: { \"method\": [ { \"type\": \"action\", \"name\": \"Adding a ChunkedDribbleDelay to a mapping\", \"provider\": { \"type\": \"python\", \"module\": \"chaoswm.actions\", \"func\": \"chunked_dribble_delay\", \"arguments\": { \"filter\": [{ \"method\": \"GET\", \"url\": \"/hello\" }], \"chunkedDribbleDelay\": { \"numberOfChunks\": 5, \"totalDuration\": 1000 } } } } ] } Taking a list of mappings down (heavy distribution delay). This action will use the parameters specified in the \"down\" key of the configuration section: { \"method\": [ { \"type\": \"action\", \"name\": \"Taking a mapping down\", \"provider\": { \"type\": \"python\", \"module\": \"chaoswm.actions\", \"func\": \"down\", \"arguments\": { \"filter\": [{ \"method\": \"GET\", \"url\": \"/hello\" }] } } } ] } Taking a list of mappings up back again: { \"method\": [ { \"type\": \"action\", \"name\": \"Taking a mapping down\", \"provider\": { \"type\": \"python\", \"module\": \"chaoswm.actions\", \"func\": \"up\", \"arguments\": { \"filter\": [{ \"method\": \"GET\", \"url\": \"/hello\" }] } } } ] } Resetting the wiremock server (deleting all mappings): { \"method\": [ { \"type\": \"action\", \"name\": \"Taking a mapping down\", \"provider\": { \"type\": \"python\", \"module\": \"chaoswm.actions\", \"func\": \"reset\" } } ] }","title":"Exported Actions"},{"location":"drivers/wiremock/#experiments","text":"The driver comes with an experiments directory where you can find snippets to test all APIs against a WireMock server listening on localhost:8080.","title":"Experiments"},{"location":"drivers/wiremock/#discovery","text":"You may use the Chaos Toolkit to discover the capabilities of this extension: $ chaos discover chaostoolkit-wiremock --no-install","title":"Discovery"},{"location":"drivers/wiremock/#credits","text":"This package was created with Cookiecutter and the audreyr/cookiecutter-pypackage project template.","title":"Credits"},{"location":"drivers/wiremock/#exported-activities","text":"","title":"Exported Activities"},{"location":"drivers/wiremock/#actions","text":"","title":"actions"},{"location":"drivers/wiremock/#add_mappings","text":"Type action Module chaoswm.actions Name add_mappings Return list adds more mappings to wiremock returns the list of ids of the mappings added Signature: def add_mappings ( mappings : List [ Any ], configuration : Dict [ str , Dict [ str , str ]] = None ) -> List [ Any ]: pass Arguments: Name Type Default Required mappings list Yes Usage: { \"name\" : \"add-mappings\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoswm.actions\" , \"func\" : \"add_mappings\" , \"arguments\" : { \"mappings\" : [] } } } name : add-mappings provider : arguments : mappings : [] func : add_mappings module : chaoswm.actions type : python type : action","title":"add_mappings"},{"location":"drivers/wiremock/#chunked_dribble_delay","text":"Type action Module chaoswm.actions Name chunked_dribble_delay Return list adds a chunked dribble delay to a list of mappings Signature: def chunked_dribble_delay ( filter : List [ Any ], chunkedDribbleDelay : Mapping [ str , Any ], configuration : Dict [ str , Dict [ str , str ]] = None ) -> List [ Any ]: pass Arguments: Name Type Default Required filter list Yes chunkedDribbleDelay object Yes Usage: { \"name\" : \"chunked-dribble-delay\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoswm.actions\" , \"func\" : \"chunked_dribble_delay\" , \"arguments\" : { \"filter\" : [], \"chunkedDribbleDelay\" : null } } } name : chunked-dribble-delay provider : arguments : chunkedDribbleDelay : null filter : [] func : chunked_dribble_delay module : chaoswm.actions type : python type : action","title":"chunked_dribble_delay"},{"location":"drivers/wiremock/#delete_mappings","text":"Type action Module chaoswm.actions Name delete_mappings Return list deletes a list of mappings returns the list of ids of the mappings deleted Signature: def delete_mappings ( filter : List [ Any ], configuration : Dict [ str , Dict [ str , str ]] = None ) -> List [ Any ]: pass Arguments: Name Type Default Required filter list Yes Usage: { \"name\" : \"delete-mappings\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoswm.actions\" , \"func\" : \"delete_mappings\" , \"arguments\" : { \"filter\" : [] } } } name : delete-mappings provider : arguments : filter : [] func : delete_mappings module : chaoswm.actions type : python type : action","title":"delete_mappings"},{"location":"drivers/wiremock/#down","text":"Type action Module chaoswm.actions Name down Return list set a list of services down more correctly it adds a chunked dribble delay to the mapping as defined in the configuration section (or action attributes) Returns the list of delayed mappings Signature: def down ( filter : List [ Any ], configuration : Dict [ str , Dict [ str , str ]] = None ) -> List [ Any ]: pass Arguments: Name Type Default Required filter list Yes Usage: { \"name\" : \"down\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoswm.actions\" , \"func\" : \"down\" , \"arguments\" : { \"filter\" : [] } } } name : down provider : arguments : filter : [] func : down module : chaoswm.actions type : python type : action","title":"down"},{"location":"drivers/wiremock/#fixed_delay","text":"Type action Module chaoswm.actions Name fixed_delay Return list adds a fixed delay to a list of mappings Signature: def fixed_delay ( filter : List [ Any ], fixedDelayMilliseconds : int , configuration : Dict [ str , Dict [ str , str ]] = None ) -> List [ Any ]: pass Arguments: Name Type Default Required filter list Yes fixedDelayMilliseconds integer Yes Usage: { \"name\" : \"fixed-delay\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoswm.actions\" , \"func\" : \"fixed_delay\" , \"arguments\" : { \"filter\" : [], \"fixedDelayMilliseconds\" : 0 } } } name : fixed-delay provider : arguments : filter : [] fixedDelayMilliseconds : 0 func : fixed_delay module : chaoswm.actions type : python type : action","title":"fixed_delay"},{"location":"drivers/wiremock/#global_fixed_delay","text":"Type action Module chaoswm.actions Name global_fixed_delay Return integer add a fixed delay to all mappings Signature: def global_fixed_delay ( fixedDelay : int = 0 , configuration : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required fixedDelay integer 0 No Usage: { \"name\" : \"global-fixed-delay\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoswm.actions\" , \"func\" : \"global_fixed_delay\" } } name : global-fixed-delay provider : func : global_fixed_delay module : chaoswm.actions type : python type : action","title":"global_fixed_delay"},{"location":"drivers/wiremock/#global_random_delay","text":"Type action Module chaoswm.actions Name global_random_delay Return integer adds a random delay to all mappings Signature: def global_random_delay ( delayDistribution : Mapping [ str , Any ], configuration : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required delayDistribution object Yes Usage: { \"name\" : \"global-random-delay\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoswm.actions\" , \"func\" : \"global_random_delay\" , \"arguments\" : { \"delayDistribution\" : null } } } name : global-random-delay provider : arguments : delayDistribution : null func : global_random_delay module : chaoswm.actions type : python type : action","title":"global_random_delay"},{"location":"drivers/wiremock/#populate_from_dir","text":"Type action Module chaoswm.actions Name populate_from_dir Return list adds all mappings found in the passed folder returns the list of ids of the mappings added Signature: def populate_from_dir ( dir : str = '.' , configuration : Dict [ str , Dict [ str , str ]] = None ) -> List [ Any ]: pass Arguments: Name Type Default Required dir string \u201d.\u201d No Usage: { \"name\" : \"populate-from-dir\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoswm.actions\" , \"func\" : \"populate_from_dir\" } } name : populate-from-dir provider : func : populate_from_dir module : chaoswm.actions type : python type : action","title":"populate_from_dir"},{"location":"drivers/wiremock/#random_delay","text":"Type action Module chaoswm.actions Name random_delay Return list adds a random delay to a list of mapppings Signature: def random_delay ( filter : List [ Any ], delayDistribution : Mapping [ str , Any ], configuration : Dict [ str , Dict [ str , str ]] = None ) -> List [ Any ]: pass Arguments: Name Type Default Required filter list Yes delayDistribution object Yes Usage: { \"name\" : \"random-delay\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoswm.actions\" , \"func\" : \"random_delay\" , \"arguments\" : { \"filter\" : [], \"delayDistribution\" : null } } } name : random-delay provider : arguments : delayDistribution : null filter : [] func : random_delay module : chaoswm.actions type : python type : action","title":"random_delay"},{"location":"drivers/wiremock/#reset","text":"Type action Module chaoswm.actions Name reset Return integer resets the wiremock server: deletes all mappings! Signature: def reset ( configuration : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required Usage: { \"name\" : \"reset\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoswm.actions\" , \"func\" : \"reset\" } } name : reset provider : func : reset module : chaoswm.actions type : python type : action","title":"reset"},{"location":"drivers/wiremock/#up","text":"Type action Module chaoswm.actions Name up Return list deletes all delays connected with a list of mappings Signature: def up ( filter : List [ Any ], configuration : Dict [ str , Dict [ str , str ]] = None ) -> List [ Any ]: pass Arguments: Name Type Default Required filter list Yes Usage: { \"name\" : \"up\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoswm.actions\" , \"func\" : \"up\" , \"arguments\" : { \"filter\" : [] } } } name : up provider : arguments : filter : [] func : up module : chaoswm.actions type : python type : action","title":"up"},{"location":"drivers/wiremock/#probes","text":"","title":"probes"},{"location":"drivers/wiremock/#mappings","text":"Type probe Module chaoswm.probes Name mappings Return list Signature: def mappings ( c : Dict [ str , Dict [ str , str ]] = None ) -> List [ Any ]: pass Arguments: Name Type Default Required c mapping null No Usage: { \"name\" : \"mappings\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoswm.probes\" , \"func\" : \"mappings\" } } name : mappings provider : func : mappings module : chaoswm.probes type : python type : probe","title":"mappings"},{"location":"drivers/wiremock/#server_running","text":"Type probe Module chaoswm.probes Name server_running Return integer Signature: def server_running ( c : Dict [ str , Dict [ str , str ]] = None ) -> int : pass Arguments: Name Type Default Required c mapping null No Usage: { \"name\" : \"server-running\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoswm.probes\" , \"func\" : \"server_running\" } } name : server-running provider : func : server_running module : chaoswm.probes type : python type : probe","title":"server_running"},{"location":"drivers/wiremock/#utils","text":"","title":"utils"},{"location":"drivers/wiremock/#can_connect_to","text":"Type Module chaoswm.utils Name can_connect_to Return boolean Test a connection to a host/port Signature: def can_connect_to ( host : str , port : int ) -> bool : pass Arguments: Name Type Default Required host string Yes port integer Yes Usage: { \"name\" : \"can-connect-to\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoswm.utils\" , \"func\" : \"can_connect_to\" , \"arguments\" : { \"host\" : \"\" , \"port\" : 0 } } } name : can-connect-to provider : arguments : host : '' port : 0 func : can_connect_to module : chaoswm.utils type : python type : ''","title":"can_connect_to"},{"location":"drivers/wiremock/#check_configuration","text":"Type Module chaoswm.utils Name check_configuration Return boolean Signature: def check_configuration ( c : Dict [ str , Any ] = None ) -> bool : pass Arguments: Name Type Default Required c mapping null No Usage: { \"name\" : \"check-configuration\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoswm.utils\" , \"func\" : \"check_configuration\" } } name : check-configuration provider : func : check_configuration module : chaoswm.utils type : python type : ''","title":"check_configuration"},{"location":"drivers/wiremock/#get_wm_params","text":"Type Module chaoswm.utils Name get_wm_params Return Union[Dict[str, Any], NoneType] Signature: def get_wm_params ( c : Dict [ str , Any ]) -> Union [ Dict [ str , Any ], NoneType ]: pass Arguments: Name Type Default Required c mapping Yes Usage: { \"name\" : \"get-wm-params\" , \"type\" : \"\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaoswm.utils\" , \"func\" : \"get_wm_params\" , \"arguments\" : { \"c\" : {} } } } name : get-wm-params provider : arguments : c : {} func : get_wm_params module : chaoswm.utils type : python type : ''","title":"get_wm_params"},{"location":"reference/concepts/","text":"Chaos Engineering Concepts in the Chaos Toolkit \u00b6 If you haven\u2019t already, we strongly recommend reading the fantastic Chaos Engineering book from O\u2019Reilly Media. This book will give you some fantastic background on the whole Chaos Engineering discipline, and it\u2019s free! Chaos Engineering is a discipline that allows you to surface weaknesses, and eventually build confidence, in complex and often distributed systems. The Chaos Toolkit aims to give you the simplest experience for writing and running your own Chaos Engineering experiments. The main concepts are all expressed in an experiment definition, of which the following is an example from the Chaos Toolkit Samples project: { \"version\" : \"1.0.0\" , \"title\" : \"System is resilient to provider's failures\" , \"description\" : \"Can our consumer survive gracefully a provider's failure?\" , \"tags\" : [ \"service\" , \"kubernetes\" , \"spring\" ], \"steady-state-hypothesis\" : { \"title\" : \"Services are all available and healthy\" , \"probes\" : [ { \"type\" : \"probe\" , \"name\" : \"all-services-are-healthy\" , \"tolerance\" : true , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.probes\" , \"func\" : \"all_microservices_healthy\" } } ] }, \"method\" : [ { \"type\" : \"action\" , \"name\" : \"stop-provider-service\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.actions\" , \"func\" : \"kill_microservice\" , \"arguments\" : { \"name\" : \"my-provider-service\" } }, \"pauses\" : { \"after\" : 10 } }, { \"ref\" : \"all-services-are-healthy\" }, { \"type\" : \"probe\" , \"name\" : \"consumer-service-must-still-respond\" , \"provider\" : { \"type\" : \"http\" , \"url\" : \"http://192.168.42.58:31018/invokeConsumedService\" } } ], \"rollbacks\" : [] } The key concepts of the Chaos Toolkit are Experiments , Steady State Hypothesis and the experiment\u2019s Method . The Method contains a combination of Probes and Actions . Experiments \u00b6 A Chaos Toolkit experiment is provided in a single file and is currently expressed in JSON. Steady State Hypothesis \u00b6 A Steady State Hypothesis describes \u201cwhat normal looks like\u201d for your system in order for the experiment to surface information about weaknesses when compared against the declared \u201cnormal\u201d tolerances of what is measured. The Chaos Toolkit uses the Steady State Hypothesis for two purposes. It is used as a check before an experiment is run that the target system is in a recognised normal state. It is also used as the template for comparison of the state of your system after the experiment has been run, forming the results provided by the experiment\u2019s report. Method \u00b6 An experiment\u2019s activities are contained within its Method block. Probes \u00b6 A probe is a way of observing a particular set of conditions in the system that is undergoing experimentation. Actions \u00b6 An action is a particular activity that needs to be enacted on the system under experimentation. Rollbacks \u00b6 An experiment may define a sequence of actions that revert what was undone during the experiment. Controls \u00b6 An experiment may declare a set of controls which have an impact over the execution of the experiment itself. Controls are operational elements rather than experimental.","title":"Concepts"},{"location":"reference/concepts/#chaos-engineering-concepts-in-the-chaos-toolkit","text":"If you haven\u2019t already, we strongly recommend reading the fantastic Chaos Engineering book from O\u2019Reilly Media. This book will give you some fantastic background on the whole Chaos Engineering discipline, and it\u2019s free! Chaos Engineering is a discipline that allows you to surface weaknesses, and eventually build confidence, in complex and often distributed systems. The Chaos Toolkit aims to give you the simplest experience for writing and running your own Chaos Engineering experiments. The main concepts are all expressed in an experiment definition, of which the following is an example from the Chaos Toolkit Samples project: { \"version\" : \"1.0.0\" , \"title\" : \"System is resilient to provider's failures\" , \"description\" : \"Can our consumer survive gracefully a provider's failure?\" , \"tags\" : [ \"service\" , \"kubernetes\" , \"spring\" ], \"steady-state-hypothesis\" : { \"title\" : \"Services are all available and healthy\" , \"probes\" : [ { \"type\" : \"probe\" , \"name\" : \"all-services-are-healthy\" , \"tolerance\" : true , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.probes\" , \"func\" : \"all_microservices_healthy\" } } ] }, \"method\" : [ { \"type\" : \"action\" , \"name\" : \"stop-provider-service\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.actions\" , \"func\" : \"kill_microservice\" , \"arguments\" : { \"name\" : \"my-provider-service\" } }, \"pauses\" : { \"after\" : 10 } }, { \"ref\" : \"all-services-are-healthy\" }, { \"type\" : \"probe\" , \"name\" : \"consumer-service-must-still-respond\" , \"provider\" : { \"type\" : \"http\" , \"url\" : \"http://192.168.42.58:31018/invokeConsumedService\" } } ], \"rollbacks\" : [] } The key concepts of the Chaos Toolkit are Experiments , Steady State Hypothesis and the experiment\u2019s Method . The Method contains a combination of Probes and Actions .","title":"Chaos Engineering Concepts in the Chaos Toolkit"},{"location":"reference/concepts/#experiments","text":"A Chaos Toolkit experiment is provided in a single file and is currently expressed in JSON.","title":"Experiments"},{"location":"reference/concepts/#steady-state-hypothesis","text":"A Steady State Hypothesis describes \u201cwhat normal looks like\u201d for your system in order for the experiment to surface information about weaknesses when compared against the declared \u201cnormal\u201d tolerances of what is measured. The Chaos Toolkit uses the Steady State Hypothesis for two purposes. It is used as a check before an experiment is run that the target system is in a recognised normal state. It is also used as the template for comparison of the state of your system after the experiment has been run, forming the results provided by the experiment\u2019s report.","title":"Steady State Hypothesis"},{"location":"reference/concepts/#method","text":"An experiment\u2019s activities are contained within its Method block.","title":"Method"},{"location":"reference/concepts/#probes","text":"A probe is a way of observing a particular set of conditions in the system that is undergoing experimentation.","title":"Probes"},{"location":"reference/concepts/#actions","text":"An action is a particular activity that needs to be enacted on the system under experimentation.","title":"Actions"},{"location":"reference/concepts/#rollbacks","text":"An experiment may define a sequence of actions that revert what was undone during the experiment.","title":"Rollbacks"},{"location":"reference/concepts/#controls","text":"An experiment may declare a set of controls which have an impact over the execution of the experiment itself. Controls are operational elements rather than experimental.","title":"Controls"},{"location":"reference/contributing/","text":"The Chaos Toolkit is a free and open source tool and a community-driven set of projects . The community\u2019s input is what makes this project special and a success. Your input could take the form of raising issues , voting for issues , starring projects , joining us on our community Slack team , submitting pull requests , or even suggesting whole new extension projects . Whatever you can contribute, we\u2019re listening and want you to help us drive the project forward . The Chaos Toolkit Incubator \u00b6 New potential projects should be first incubated in the Chaos Toolkit Incubator until they are ready to be moved into the main Chaos Toolkit suite of projects . Conditions for graduating a project from the Incubator to the main suite of projects include: Correct Licensing and Certification of Origin. A popular starred and used extension to the Chaos Toolkit. Active and prompt project issue resolution. How to submit your own project to the incubator? \u00b6 The incubator is a place for community projects to be collected. If you think your extension makes sense as a community project, please don\u2019t hesitate to suggest it. The best place to start is on the community Slack team to announce it. Generally speaking, you should consider the followings: Can your project be made publicly available? Think it should respect the Developer Certificate of Origin Does it serve your own purpose or can it be used by anyone? What license do you want to set on it? We tend to prefer permissive licenses that are recognized by the Open Source project , such as Apache or BSD Will you be able to provide basic support to the project after you have submitted it? We are not talking about enterprise support but merely basic issues overview and bug fixes from time to time Notice also that we deal with contributors on a repository basis. Collaborators are external contributors with little permissions to the org and write permissions to the repositories they contribute to. We suggest that accounts should have 2FA enabled. This reduces the security surface risks in case a contributor account is breached. Licensing and Certification of Origin \u00b6 Every project in the Chaos Toolkit and the Chaos Toolkit Incubator is licensed under the Apache License, Version 2.0 and abides by the Developer Certificate of Origin on all accepted commits to the master branch.","title":"Contributing to the Chaos Toolkit"},{"location":"reference/contributing/#the-chaos-toolkit-incubator","text":"New potential projects should be first incubated in the Chaos Toolkit Incubator until they are ready to be moved into the main Chaos Toolkit suite of projects . Conditions for graduating a project from the Incubator to the main suite of projects include: Correct Licensing and Certification of Origin. A popular starred and used extension to the Chaos Toolkit. Active and prompt project issue resolution.","title":"The Chaos Toolkit Incubator"},{"location":"reference/contributing/#how-to-submit-your-own-project-to-the-incubator","text":"The incubator is a place for community projects to be collected. If you think your extension makes sense as a community project, please don\u2019t hesitate to suggest it. The best place to start is on the community Slack team to announce it. Generally speaking, you should consider the followings: Can your project be made publicly available? Think it should respect the Developer Certificate of Origin Does it serve your own purpose or can it be used by anyone? What license do you want to set on it? We tend to prefer permissive licenses that are recognized by the Open Source project , such as Apache or BSD Will you be able to provide basic support to the project after you have submitted it? We are not talking about enterprise support but merely basic issues overview and bug fixes from time to time Notice also that we deal with contributors on a repository basis. Collaborators are external contributors with little permissions to the org and write permissions to the repositories they contribute to. We suggest that accounts should have 2FA enabled. This reduces the security surface risks in case a contributor account is breached.","title":"How to submit your own project to the incubator?"},{"location":"reference/contributing/#licensing-and-certification-of-origin","text":"Every project in the Chaos Toolkit and the Chaos Toolkit Incubator is licensed under the Apache License, Version 2.0 and abides by the Developer Certificate of Origin on all accepted commits to the master branch.","title":"Licensing and Certification of Origin"},{"location":"reference/tutorial/","text":"Getting Started with the Chaos Toolkit \u00b6 When you practice chaos engineering, you are discovering how your system reacts following certain conditions you inject. By doing this in a controlled fashion, you may learn how to change the system accordingly. This tutorial will quickly give you a tour of the basic elements of an experiment. Tip You will find many more in-depth labs on GitHub . Get Ready \u00b6 Before you can run the experiment against your system, you will need to have it setup. Get the Code \u00b6 You can fetch the code as follows: git clone https://github.com/chaostoolkit/chaostoolkit-documentation-code This particular tutorial is under tutorials/a-simple-walkthrough . cd chaostoolkit-documentation-code/tutorials/a-simple-walkthrough Third-party binaries \u00b6 The experiment will use the following binaries, make sure you have them in your PATH: openssl pkill Install the Application dependencies \u00b6 Our application is made of a simple set of two microservices that converse with each other over HTTPS. Tip It\u2019s recommended that you use a Python virtual environment to keep your project dependencies isolated from any other projects. As you should already run Python 3 for the toolkit itself, we assume you are set accordingly, please install only the application dependencies: pip install -U -r requirements.txt Install the Chaos Toolkit \u00b6 You must install the Chaos Toolkit and its dependencies for the purpose of this tutorial. While we suggest you go through the install section, it boils down to: pip install -U chaostoolkit Your First Experiment \u00b6 Explore a Potential Weakness \u00b6 So, looking at our application, what could we consider as of interest to discover through an experiment? Well, we are using HTTPS between the two services in our application, what if the certificate expired? Tip In such a simple setup, we appreciate that things will likely break and, in general there is no point to run an experiment when you already know the outcome. However, let\u2019s humor ourselves for the sake of learning the basics behind the Chaos Toolkit. We can intuit things will fall apart if the sunset service cannot talk the astre service but, should the chain be part of much more complex graph of services, it could be difficult to fully understand all the branches that would be affected nor how badly. So, it may still be useful to experiment by injecting an expired certificate. Define the Steady State Hypothesis \u00b6 You can only learn if you know where you start from and what a good baseline for your application is. Here we assume two things: the services are running we can call the sunset service to retrieve the sunset time for a given city During our experiment, we will vary the conditions of the system and expect the state to remain valid. Changing the Conditions \u00b6 In this tutorial, we are going to set an expired certificate and restart the services. We will then call our application and see how it responds. Declare an Experiment to Observe the Weakness \u00b6 At this stage, we can create an experiment that tells how the system behaves when a certificate expires. { \"version\" : \"1.0.0\" , \"title\" : \"What is the impact of an expired certificate on our application chain?\" , \"description\" : \"If a certificate expires, we should gracefully deal with the issue.\" , \"tags\" : [ \"tls\" ], \"steady-state-hypothesis\" : { \"title\" : \"Application responds\" , \"probes\" : [ { \"type\" : \"probe\" , \"name\" : \"the-astre-service-must-be-running\" , \"tolerance\" : true , \"provider\" : { \"type\" : \"python\" , \"module\" : \"os.path\" , \"func\" : \"exists\" , \"arguments\" : { \"path\" : \"astre.pid\" } } }, { \"type\" : \"probe\" , \"name\" : \"the-sunset-service-must-be-running\" , \"tolerance\" : true , \"provider\" : { \"type\" : \"python\" , \"module\" : \"os.path\" , \"func\" : \"exists\" , \"arguments\" : { \"path\" : \"sunset.pid\" } } }, { \"type\" : \"probe\" , \"name\" : \"we-can-request-sunset\" , \"tolerance\" : 200 , \"provider\" : { \"type\" : \"http\" , \"timeout\" : 3 , \"verify_tls\" : false , \"url\" : \"https://localhost:8443/city/Paris\" } } ] }, \"method\" : [ { \"type\" : \"action\" , \"name\" : \"swap-to-expired-cert\" , \"provider\" : { \"type\" : \"process\" , \"path\" : \"cp\" , \"arguments\" : \"expired-cert.pem cert.pem\" } }, { \"type\" : \"probe\" , \"name\" : \"read-tls-cert-expiry-date\" , \"provider\" : { \"type\" : \"process\" , \"path\" : \"openssl\" , \"arguments\" : \"x509 -enddate -noout -in cert.pem\" } }, { \"type\" : \"action\" , \"name\" : \"restart-astre-service-to-pick-up-certificate\" , \"provider\" : { \"type\" : \"process\" , \"path\" : \"pkill\" , \"arguments\" : \"--echo -HUP -F astre.pid\" } }, { \"type\" : \"action\" , \"name\" : \"restart-sunset-service-to-pick-up-certificate\" , \"provider\" : { \"type\" : \"process\" , \"path\" : \"pkill\" , \"arguments\" : \"--echo -HUP -F sunset.pid\" }, \"pauses\" : { \"after\" : 1 } } ], \"rollbacks\" : [ { \"type\" : \"action\" , \"name\" : \"swap-to-vald-cert\" , \"provider\" : { \"type\" : \"process\" , \"path\" : \"cp\" , \"arguments\" : \"valid-cert.pem cert.pem\" } }, { \"ref\" : \"restart-astre-service-to-pick-up-certificate\" }, { \"ref\" : \"restart-sunset-service-to-pick-up-certificate\" } ] } The Various Sections of an Experiment \u00b6 Let\u2019s now go through the experiment blocks. The steady state hypothesis declares the various probes that will be applied as part of the hypothesis check. The hypothesis is played twice. The first time before we do anything else to ensure the system is indeed in a normal state, here we check the services are running by looking up their PID files and we call the sunset service which should respond OK. The second time the hypothesis is applied is after the conditions were changed in the system, to validate it is still in a normal state. The method is the block which changes the conditions of our system/application. Here, we swap the valid certificate for an expired one and restart the services by sending them a SIGHUP signal. Finally, the rollback section (which is optional) tries to remediate to the changes we made, in this case by swapping back to the valid certificate. Different Kinds of Activities \u00b6 It is interesting to notice that the hypothesis uses probes while rollbacks are made of actions only. The method may use both. The reason is that the hypothesis is only about querying the system while rollbacks act on it. Finally, it is often useful to query the system while we change the conditions, for future analysis. Probes and Actions are activities that do not differ in the way they work, it\u2019s only their goal that differs. You can create activities that make HTTP calls, execute processes or perform more complex operations through extensions (often implemented in Python). This tutorial showcases a bit of all of those. Tolerances in the Hypothesis \u00b6 Hypothesis probes expect a tolerance property which tells the Chaos Toolkit how to validate a certain aspect of the state. In our example, tolerances are rather simple. We check file exists and that a HTTP request returns a status code of 200 . Richer tolerances can be created by using regex or jsonpath. Run the Experiment \u00b6 Start the Experiment without the Application \u00b6 To run the experiment, simply execute the following command: chaos run experiment.json [2018-05-14 18:38:04 INFO] Validating the experiment's syntax [2018-05-14 18:38:04 INFO] Experiment looks valid [2018-05-14 18:38:04 INFO] Running experiment: What is the impact of an expired certificate on our application chain? [2018-05-14 18:38:04 INFO] Steady state hypothesis: Application responds [2018-05-14 18:38:04 INFO] Probe: the-astre-service-must-be-running [2018-05-14 18:38:04 CRITICAL] Steady state probe 'the-astre-service-must-be-running' is not in the given tolerance so failing this experiment [2018-05-14 18:38:04 INFO] Let's rollback... [2018-05-14 18:38:04 INFO] Rollback: swap-to-vald-cert [2018-05-14 18:38:04 INFO] Action: swap-to-vald-cert [2018-05-14 18:38:04 INFO] Rollback: None [2018-05-14 18:38:04 INFO] Action: restart-astre-service-to-pick-up-certificate [2018-05-14 18:38:04 INFO] Rollback: None [2018-05-14 18:38:04 INFO] Action: restart-sunset-service-to-pick-up-certificate [2018-05-14 18:38:04 INFO] Pausing after activity for 1s... [2018-05-14 18:38:05 INFO] Experiment ended with status: failed Because we ran this command before we even started our application, our steady-state hypothesis failed and bailed the experiment immediately. Note that the rollbacks will run anyway. They are only bypassed when you send a SIGINT or SIGTERM signal to the chaos process because the toolkit assumes you may want to review your system. Start the Application \u00b6 You may now run the application. First, copy the valid certificate as follows: cp valid-cert.pem cert.pem Next, start the services, in one terminal: python3 astre.py [14/May/2018:16:11:09] ENGINE Listening for SIGTERM. [14/May/2018:16:11:09] ENGINE Listening for SIGHUP. [14/May/2018:16:11:09] ENGINE Listening for SIGUSR1. [14/May/2018:16:11:09] ENGINE Bus STARTING [14/May/2018:16:11:09] ENGINE Serving on https://127.0.0.1:8444 [14/May/2018:16:11:09] ENGINE Bus STARTE Then, in another terminal: python3 sunset.py [14/May/2018:16:13:58] ENGINE Listening for SIGTERM. [14/May/2018:16:13:58] ENGINE Listening for SIGHUP. [14/May/2018:16:13:58] ENGINE Listening for SIGUSR1. [14/May/2018:16:13:58] ENGINE Bus STARTING [14/May/2018:16:13:58] ENGINE Serving on https://127.0.0.1:8443 [14/May/2018:16:13:58] ENGINE Bus STARTED Now you may perform a simple call: curl -k https://localhost:8443/city/Paris The sunset will occur at 2018-05-14T21:23:09+02:00 in Paris What happens is that the sunset service performs a call to the astre service for the data and simply render them to you, as plain text. Both services are chained together over HTTPS. Run the Experiment \u00b6 Now your application is running, execute the experiment once again: chaos run experiment.json [2018-05-14 18:41:09 INFO] Validating the experiment's syntax [2018-05-14 18:41:09 INFO] Experiment looks valid [2018-05-14 18:41:09 INFO] Running experiment: What is the impact of an expired certificate on our application chain? [2018-05-14 18:41:09 INFO] Steady state hypothesis: Application responds [2018-05-14 18:41:09 INFO] Probe: the-astre-service-must-be-running [2018-05-14 18:41:09 INFO] Probe: the-sunset-service-must-be-running [2018-05-14 18:41:09 INFO] Probe: we-can-request-sunset [2018-05-14 18:41:09 INFO] Steady state hypothesis is met! [2018-05-14 18:41:09 INFO] Action: swap-to-expired-cert [2018-05-14 18:41:09 INFO] Probe: read-tls-cert-expiry-date [2018-05-14 18:41:09 INFO] Action: restart-astre-service-to-pick-up-certificate [2018-05-14 18:41:09 INFO] Action: restart-sunset-service-to-pick-up-certificate [2018-05-14 18:41:09 INFO] Pausing after activity for 1s... [2018-05-14 18:41:10 INFO] Steady state hypothesis: Application responds [2018-05-14 18:41:10 INFO] Probe: the-astre-service-must-be-running [2018-05-14 18:41:10 INFO] Probe: the-sunset-service-must-be-running [2018-05-14 18:41:10 INFO] Probe: we-can-request-sunset [2018-05-14 18:41:10 CRITICAL] Steady state probe 'we-can-request-sunset' is not in the given tolerance so failing this experiment [2018-05-14 18:41:10 INFO] Let's rollback... [2018-05-14 18:41:10 INFO] Rollback: swap-to-vald-cert [2018-05-14 18:41:10 INFO] Action: swap-to-vald-cert [2018-05-14 18:41:10 INFO] Rollback: None [2018-05-14 18:41:10 INFO] Action: restart-astre-service-to-pick-up-certificate [2018-05-14 18:41:10 INFO] Rollback: None [2018-05-14 18:41:10 INFO] Action: restart-sunset-service-to-pick-up-certificate [2018-05-14 18:41:10 INFO] Pausing after activity for 1s... [2018-05-14 18:41:11 INFO] Experiment ended with status: failed Each activity is run in the order it appears in the experiment. Notice now how the hypothesis is not met after we swapped the certificates. But, we learn something interesting, even if expected, using an expired certificate does not prevent our services to even start. Report on your Findings \u00b6 Review the Journal of the Run \u00b6 You may now review the journal generated by the run: cat journal.json It contains the activities runs and the output of each of them. Generate a Report \u00b6 You can generate a PDF (or HTML, markdown\u2026) report from the journal if you install the chaostoolkit-reporting plugin first: chaos report --export-format=pdf journal.json report.pdf Learnings and Responses \u00b6 In this experiment, we proved what we guessed initially, that an expired certificate will create trouble and break the application for our users. What could be the responses? Use a circuit-breaker to provide a more meaningful, and controlled, answer to the caller Prevent the service to start when the certificate it uses is expired Put some monitoring in place on our certificates and trigger an alert when they get close to their end date Move to Let\u2019s Encrypt and renew our certs automatically For each of these potential responses, you could create an experiment should they unearth potential new questions. Next? \u00b6 An experiment is never the end game. The flow should be continuous and you should create and run experiments regularly.","title":"Get Started with the Chaos Toolkit"},{"location":"reference/tutorial/#getting-started-with-the-chaos-toolkit","text":"When you practice chaos engineering, you are discovering how your system reacts following certain conditions you inject. By doing this in a controlled fashion, you may learn how to change the system accordingly. This tutorial will quickly give you a tour of the basic elements of an experiment. Tip You will find many more in-depth labs on GitHub .","title":"Getting Started with the Chaos Toolkit"},{"location":"reference/tutorial/#get-ready","text":"Before you can run the experiment against your system, you will need to have it setup.","title":"Get Ready"},{"location":"reference/tutorial/#get-the-code","text":"You can fetch the code as follows: git clone https://github.com/chaostoolkit/chaostoolkit-documentation-code This particular tutorial is under tutorials/a-simple-walkthrough . cd chaostoolkit-documentation-code/tutorials/a-simple-walkthrough","title":"Get the Code"},{"location":"reference/tutorial/#third-party-binaries","text":"The experiment will use the following binaries, make sure you have them in your PATH: openssl pkill","title":"Third-party binaries"},{"location":"reference/tutorial/#install-the-application-dependencies","text":"Our application is made of a simple set of two microservices that converse with each other over HTTPS. Tip It\u2019s recommended that you use a Python virtual environment to keep your project dependencies isolated from any other projects. As you should already run Python 3 for the toolkit itself, we assume you are set accordingly, please install only the application dependencies: pip install -U -r requirements.txt","title":"Install the Application dependencies"},{"location":"reference/tutorial/#install-the-chaos-toolkit","text":"You must install the Chaos Toolkit and its dependencies for the purpose of this tutorial. While we suggest you go through the install section, it boils down to: pip install -U chaostoolkit","title":"Install the Chaos Toolkit"},{"location":"reference/tutorial/#your-first-experiment","text":"","title":"Your First Experiment"},{"location":"reference/tutorial/#explore-a-potential-weakness","text":"So, looking at our application, what could we consider as of interest to discover through an experiment? Well, we are using HTTPS between the two services in our application, what if the certificate expired? Tip In such a simple setup, we appreciate that things will likely break and, in general there is no point to run an experiment when you already know the outcome. However, let\u2019s humor ourselves for the sake of learning the basics behind the Chaos Toolkit. We can intuit things will fall apart if the sunset service cannot talk the astre service but, should the chain be part of much more complex graph of services, it could be difficult to fully understand all the branches that would be affected nor how badly. So, it may still be useful to experiment by injecting an expired certificate.","title":"Explore a Potential Weakness"},{"location":"reference/tutorial/#define-the-steady-state-hypothesis","text":"You can only learn if you know where you start from and what a good baseline for your application is. Here we assume two things: the services are running we can call the sunset service to retrieve the sunset time for a given city During our experiment, we will vary the conditions of the system and expect the state to remain valid.","title":"Define the Steady State Hypothesis"},{"location":"reference/tutorial/#changing-the-conditions","text":"In this tutorial, we are going to set an expired certificate and restart the services. We will then call our application and see how it responds.","title":"Changing the Conditions"},{"location":"reference/tutorial/#declare-an-experiment-to-observe-the-weakness","text":"At this stage, we can create an experiment that tells how the system behaves when a certificate expires. { \"version\" : \"1.0.0\" , \"title\" : \"What is the impact of an expired certificate on our application chain?\" , \"description\" : \"If a certificate expires, we should gracefully deal with the issue.\" , \"tags\" : [ \"tls\" ], \"steady-state-hypothesis\" : { \"title\" : \"Application responds\" , \"probes\" : [ { \"type\" : \"probe\" , \"name\" : \"the-astre-service-must-be-running\" , \"tolerance\" : true , \"provider\" : { \"type\" : \"python\" , \"module\" : \"os.path\" , \"func\" : \"exists\" , \"arguments\" : { \"path\" : \"astre.pid\" } } }, { \"type\" : \"probe\" , \"name\" : \"the-sunset-service-must-be-running\" , \"tolerance\" : true , \"provider\" : { \"type\" : \"python\" , \"module\" : \"os.path\" , \"func\" : \"exists\" , \"arguments\" : { \"path\" : \"sunset.pid\" } } }, { \"type\" : \"probe\" , \"name\" : \"we-can-request-sunset\" , \"tolerance\" : 200 , \"provider\" : { \"type\" : \"http\" , \"timeout\" : 3 , \"verify_tls\" : false , \"url\" : \"https://localhost:8443/city/Paris\" } } ] }, \"method\" : [ { \"type\" : \"action\" , \"name\" : \"swap-to-expired-cert\" , \"provider\" : { \"type\" : \"process\" , \"path\" : \"cp\" , \"arguments\" : \"expired-cert.pem cert.pem\" } }, { \"type\" : \"probe\" , \"name\" : \"read-tls-cert-expiry-date\" , \"provider\" : { \"type\" : \"process\" , \"path\" : \"openssl\" , \"arguments\" : \"x509 -enddate -noout -in cert.pem\" } }, { \"type\" : \"action\" , \"name\" : \"restart-astre-service-to-pick-up-certificate\" , \"provider\" : { \"type\" : \"process\" , \"path\" : \"pkill\" , \"arguments\" : \"--echo -HUP -F astre.pid\" } }, { \"type\" : \"action\" , \"name\" : \"restart-sunset-service-to-pick-up-certificate\" , \"provider\" : { \"type\" : \"process\" , \"path\" : \"pkill\" , \"arguments\" : \"--echo -HUP -F sunset.pid\" }, \"pauses\" : { \"after\" : 1 } } ], \"rollbacks\" : [ { \"type\" : \"action\" , \"name\" : \"swap-to-vald-cert\" , \"provider\" : { \"type\" : \"process\" , \"path\" : \"cp\" , \"arguments\" : \"valid-cert.pem cert.pem\" } }, { \"ref\" : \"restart-astre-service-to-pick-up-certificate\" }, { \"ref\" : \"restart-sunset-service-to-pick-up-certificate\" } ] }","title":"Declare an Experiment to Observe the Weakness"},{"location":"reference/tutorial/#the-various-sections-of-an-experiment","text":"Let\u2019s now go through the experiment blocks. The steady state hypothesis declares the various probes that will be applied as part of the hypothesis check. The hypothesis is played twice. The first time before we do anything else to ensure the system is indeed in a normal state, here we check the services are running by looking up their PID files and we call the sunset service which should respond OK. The second time the hypothesis is applied is after the conditions were changed in the system, to validate it is still in a normal state. The method is the block which changes the conditions of our system/application. Here, we swap the valid certificate for an expired one and restart the services by sending them a SIGHUP signal. Finally, the rollback section (which is optional) tries to remediate to the changes we made, in this case by swapping back to the valid certificate.","title":"The Various Sections of an Experiment"},{"location":"reference/tutorial/#different-kinds-of-activities","text":"It is interesting to notice that the hypothesis uses probes while rollbacks are made of actions only. The method may use both. The reason is that the hypothesis is only about querying the system while rollbacks act on it. Finally, it is often useful to query the system while we change the conditions, for future analysis. Probes and Actions are activities that do not differ in the way they work, it\u2019s only their goal that differs. You can create activities that make HTTP calls, execute processes or perform more complex operations through extensions (often implemented in Python). This tutorial showcases a bit of all of those.","title":"Different Kinds of Activities"},{"location":"reference/tutorial/#tolerances-in-the-hypothesis","text":"Hypothesis probes expect a tolerance property which tells the Chaos Toolkit how to validate a certain aspect of the state. In our example, tolerances are rather simple. We check file exists and that a HTTP request returns a status code of 200 . Richer tolerances can be created by using regex or jsonpath.","title":"Tolerances in the Hypothesis"},{"location":"reference/tutorial/#run-the-experiment","text":"","title":"Run the Experiment"},{"location":"reference/tutorial/#start-the-experiment-without-the-application","text":"To run the experiment, simply execute the following command: chaos run experiment.json [2018-05-14 18:38:04 INFO] Validating the experiment's syntax [2018-05-14 18:38:04 INFO] Experiment looks valid [2018-05-14 18:38:04 INFO] Running experiment: What is the impact of an expired certificate on our application chain? [2018-05-14 18:38:04 INFO] Steady state hypothesis: Application responds [2018-05-14 18:38:04 INFO] Probe: the-astre-service-must-be-running [2018-05-14 18:38:04 CRITICAL] Steady state probe 'the-astre-service-must-be-running' is not in the given tolerance so failing this experiment [2018-05-14 18:38:04 INFO] Let's rollback... [2018-05-14 18:38:04 INFO] Rollback: swap-to-vald-cert [2018-05-14 18:38:04 INFO] Action: swap-to-vald-cert [2018-05-14 18:38:04 INFO] Rollback: None [2018-05-14 18:38:04 INFO] Action: restart-astre-service-to-pick-up-certificate [2018-05-14 18:38:04 INFO] Rollback: None [2018-05-14 18:38:04 INFO] Action: restart-sunset-service-to-pick-up-certificate [2018-05-14 18:38:04 INFO] Pausing after activity for 1s... [2018-05-14 18:38:05 INFO] Experiment ended with status: failed Because we ran this command before we even started our application, our steady-state hypothesis failed and bailed the experiment immediately. Note that the rollbacks will run anyway. They are only bypassed when you send a SIGINT or SIGTERM signal to the chaos process because the toolkit assumes you may want to review your system.","title":"Start the Experiment without the Application"},{"location":"reference/tutorial/#start-the-application","text":"You may now run the application. First, copy the valid certificate as follows: cp valid-cert.pem cert.pem Next, start the services, in one terminal: python3 astre.py [14/May/2018:16:11:09] ENGINE Listening for SIGTERM. [14/May/2018:16:11:09] ENGINE Listening for SIGHUP. [14/May/2018:16:11:09] ENGINE Listening for SIGUSR1. [14/May/2018:16:11:09] ENGINE Bus STARTING [14/May/2018:16:11:09] ENGINE Serving on https://127.0.0.1:8444 [14/May/2018:16:11:09] ENGINE Bus STARTE Then, in another terminal: python3 sunset.py [14/May/2018:16:13:58] ENGINE Listening for SIGTERM. [14/May/2018:16:13:58] ENGINE Listening for SIGHUP. [14/May/2018:16:13:58] ENGINE Listening for SIGUSR1. [14/May/2018:16:13:58] ENGINE Bus STARTING [14/May/2018:16:13:58] ENGINE Serving on https://127.0.0.1:8443 [14/May/2018:16:13:58] ENGINE Bus STARTED Now you may perform a simple call: curl -k https://localhost:8443/city/Paris The sunset will occur at 2018-05-14T21:23:09+02:00 in Paris What happens is that the sunset service performs a call to the astre service for the data and simply render them to you, as plain text. Both services are chained together over HTTPS.","title":"Start the Application"},{"location":"reference/tutorial/#run-the-experiment_1","text":"Now your application is running, execute the experiment once again: chaos run experiment.json [2018-05-14 18:41:09 INFO] Validating the experiment's syntax [2018-05-14 18:41:09 INFO] Experiment looks valid [2018-05-14 18:41:09 INFO] Running experiment: What is the impact of an expired certificate on our application chain? [2018-05-14 18:41:09 INFO] Steady state hypothesis: Application responds [2018-05-14 18:41:09 INFO] Probe: the-astre-service-must-be-running [2018-05-14 18:41:09 INFO] Probe: the-sunset-service-must-be-running [2018-05-14 18:41:09 INFO] Probe: we-can-request-sunset [2018-05-14 18:41:09 INFO] Steady state hypothesis is met! [2018-05-14 18:41:09 INFO] Action: swap-to-expired-cert [2018-05-14 18:41:09 INFO] Probe: read-tls-cert-expiry-date [2018-05-14 18:41:09 INFO] Action: restart-astre-service-to-pick-up-certificate [2018-05-14 18:41:09 INFO] Action: restart-sunset-service-to-pick-up-certificate [2018-05-14 18:41:09 INFO] Pausing after activity for 1s... [2018-05-14 18:41:10 INFO] Steady state hypothesis: Application responds [2018-05-14 18:41:10 INFO] Probe: the-astre-service-must-be-running [2018-05-14 18:41:10 INFO] Probe: the-sunset-service-must-be-running [2018-05-14 18:41:10 INFO] Probe: we-can-request-sunset [2018-05-14 18:41:10 CRITICAL] Steady state probe 'we-can-request-sunset' is not in the given tolerance so failing this experiment [2018-05-14 18:41:10 INFO] Let's rollback... [2018-05-14 18:41:10 INFO] Rollback: swap-to-vald-cert [2018-05-14 18:41:10 INFO] Action: swap-to-vald-cert [2018-05-14 18:41:10 INFO] Rollback: None [2018-05-14 18:41:10 INFO] Action: restart-astre-service-to-pick-up-certificate [2018-05-14 18:41:10 INFO] Rollback: None [2018-05-14 18:41:10 INFO] Action: restart-sunset-service-to-pick-up-certificate [2018-05-14 18:41:10 INFO] Pausing after activity for 1s... [2018-05-14 18:41:11 INFO] Experiment ended with status: failed Each activity is run in the order it appears in the experiment. Notice now how the hypothesis is not met after we swapped the certificates. But, we learn something interesting, even if expected, using an expired certificate does not prevent our services to even start.","title":"Run the Experiment"},{"location":"reference/tutorial/#report-on-your-findings","text":"","title":"Report on your Findings"},{"location":"reference/tutorial/#review-the-journal-of-the-run","text":"You may now review the journal generated by the run: cat journal.json It contains the activities runs and the output of each of them.","title":"Review the Journal of the Run"},{"location":"reference/tutorial/#generate-a-report","text":"You can generate a PDF (or HTML, markdown\u2026) report from the journal if you install the chaostoolkit-reporting plugin first: chaos report --export-format=pdf journal.json report.pdf","title":"Generate a Report"},{"location":"reference/tutorial/#learnings-and-responses","text":"In this experiment, we proved what we guessed initially, that an expired certificate will create trouble and break the application for our users. What could be the responses? Use a circuit-breaker to provide a more meaningful, and controlled, answer to the caller Prevent the service to start when the certificate it uses is expired Put some monitoring in place on our certificates and trigger an alert when they get close to their end date Move to Let\u2019s Encrypt and renew our certs automatically For each of these potential responses, you could create an experiment should they unearth potential new questions.","title":"Learnings and Responses"},{"location":"reference/tutorial/#next","text":"An experiment is never the end game. The flow should be continuous and you should create and run experiments regularly.","title":"Next?"},{"location":"reference/api/experiment/","text":"An Open API for Chaos Engineering Experiments \u00b6 Info The current specification has not reached its 1.0.0 stable version yet. Make sure to join the discussion to provide any feedback you might have. Introduction \u00b6 The purpose of this specification is to formalize the elements of a Chaos Engineering experiment and offer a way to federate the community around a common syntax and semantic. As a fairly recent field, Chaos Engineering is a dynamic and its foundations are still emerging. However, it appears certain concepts are settling down enough to start agreeing on a shared understanding. This specification is not prescriptive and does not aim at forcing the community into one direction, rather it strives at providing a common vocabulary that new practitioners can easily make sense of. It is necessary to appreciate that this document does not specify what tools, such as the Chaos Monkey or similar, should look like. Instead, this document specifies how Chaos Engineering Experiment could be described, shared and conducted collaboratively. Conventions Used in This Document \u00b6 The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 . The terms \u201cJSON\u201d, \u201cJSON text\u201d, \u201cJSON value\u201d, \u201cmember\u201d, \u201celement\u201d, \u201cobject\u201d, \u201carray\u201d, \u201cnumber\u201d, \u201cstring\u201d, \u201cboolean\u201d, \u201ctrue\u201d, \u201cfalse\u201d, and \u201cnull\u201d in this document are to be interpreted as defined in RFC 7159 . Other formats \u00b6 While this specification uses JSON to define its elements, implementations may allow loading from other formats, such as YAML . As long as the output of such format respects the specification herein. Chaos Engineering Elements \u00b6 Overview \u00b6 An Experiment is one possible description of the principles of the Chaos Engineering . The intention of such a description is to provide shared understanding around a hypothesis on how to discover system\u2019s behavior under certain conditions. An Experiment declares a steady state hypothesis , alongside probes to validate this steady state is met, and a method as a sequence actions and probes , to interact and query the system respectively. By using a variety of probes , experiments should gather information to sense behaviors in the system, potentially leading to systemic patterns that can be stabilized. Experiment \u00b6 A Chaos Engineering experiment, or simply an experiment, describes both the elements and the order in which they should be applied. An experiment is a JSON object. An experiment MUST declare: a version property a title property a description property a method property The version property MUST be \"0.1.0\" . The experiment\u2019s title and description are meant for humans and therefore should be as descriptive as possible to clarify the experiment\u2019s rationale. Title and description are JSON strings with no maximum length. An experiment SHOULD also declare: a steady-state-hypothesis property a rollbacks property An experiment MAY finally declare: a tags property a secrets property an extension property a contributions property a controls property Tags provide a way of categorizing experiments. It is a sequence of JSON strings. Extensions define opaque payloads for vendors to carry valuable information. Contribution describes valuable properties of the target system, such as \u201creliability\u201d or \u201cdurability\u201d, that an experiment contribute to. This information can be aggregated together with other experiments\u2019 contributions to better appreciate where the focus is put and where it is not. Controls describe out-of-band capabilities applied during the experiment\u2019s execution. Steady State Hypothesis \u00b6 The Steady State Hypothesis element describes what normal looks like in your system before the Method element is applied. If the steady state is not met, the Method element is not applied and the experiment MUST bail out. The Steady State Hypothesis element is a JSON object. Steady State Hypothesis element MUST declare: a title property a probes property The title is meant for humans and therefore should clarify the rationale for this hypothesis. Each Probe MUST define a tolerance property that acting as a gate mechanism for the experiment to carry on or bail. Any Probe that does not fall into the tolerance zone MUST fail the experiment. Steady State Hypothesis element MAY declare: a controls property Controls describe out-of-band capabilities applied during the experiment\u2019s execution. Steady State Probe Tolerance \u00b6 Probes of the Steady State Hypothesis MUST declare an additional property named tolerance . The tolerance property\u2019s value MUST be one of: a scalar: JSON string, number (an integer), boolean a sequence of scalars: JSON string, number, boolean an object In the case of a scalar or the sequence, the tolerance validation MUST be strict. The value returned by the Probe MUST be checked against the scalar value. The experiment MUST bail when both fail to match. When the tolerance is a sequence. If it has only two values, those two values represent a lower and upper bound within which the Probe returned value must fall (inclusive). When the sequence has more than two elements, the Probe returned value must be contained in that sequence. When the tolerance is an object, it MUST have a type property which MUST be one of the followings: \"probe\" , \"regex\" , \"jsonpath\" or \"range\" . When the type property is \"probe\" , the object MUST be a Probe that is applied. The probe should take two arguments, value and secrets where the value is the Probe returned value and secrets a Secret object or null . Its returned status MUST be successful for the tolerance to be considered valid. When the type property is \"regex\" , the object MUST have a pattern property which MUST be a valid regular expression. The tolerance succeeds if the Probe returned value is matched against the pattern. Object MAY have a target property which MUST be a valid value returned for a given provider. When the type property is \"jsonpath\" , the object MUST have a path property which MUST be a valid JSON Path . In addition, the object MAY have a expect property which is used to compare each value matched by the JSON Path to that value. The expect property value MUST be a scalar. When the expect property is not present, the tolerance succeeds if the JSON Path matched at least one item. When the type property is \"range\" , the object MUST have a range property whuch MUST be a sequence of length two. The first entry of the sequence MUST be the lower bound and the second entry MUST be the upper bound. Both entries MUST be JSON numbers. In addition, when the Probe returned value is an object with a status property, the tested value is the value of that property. Some examples of tolerance properties. A boolean tolerance: \"tolerance\" : true A integer tolerance: \"tolerance\" : 8 A string tolerance: \"tolerance\" : \"OK\" A sequence tolerance with lower and upper bounds: \"tolerance\" : [ 4 , 9 ] A sequence tolerance, the value must be contained in that sequence: \"tolerance\" : [ 4 , 9 , 78 ] A Probe tolerance: \"tolerance\" : { \"type\" : \"probe\" , \"name\" : \"should-exist\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"os.path\" , \"func\" : \"exists\" , \"arguments\" : { \"path\" : \"some/file\" } } } A regex tolerance: \"tolerance\" : { \"type\" : \"regex\" , \"pattern\" : \"[0-9]{3}\" } A regex tolerance with a non default target: \"tolerance\" : { \"type\" : \"regex\" , \"target\" : \"stdout\" , \"pattern\" : \"[0-9]{2}\" } A jsonpath tolerance: \"tolerance\" : { \"type\" : \"jsonpath\" , \"path\" : \"foo[*].baz\" } A jsonpath tolerance with an expected value to match: \"tolerance\" : { \"type\" : \"jsonpath\" , \"path\" : \"foo[*].baz\" , \"expect\" : 4 } Two range tolerances: \"tolerance\" : { \"type\" : \"range\" , \"range\" : [ 4 , 8 ] } \"tolerance\" : { \"type\" : \"range\" , \"range\" : [ 4.6 , 8.9 ] } Contributions \u00b6 Contributions describe the valuable system properties an experiment targets as well as how much they contributes to it. Those properties usually refer to aspects stakeholders care about. Aggregated they offer a powerful metric about the effort and focus on building confidence across the system. Contributions are declared under the top-level contributions property as an object. Properties of that object MUST be JSON strings representing the name of a contribution. The values MUST be the weight of a given contribution and MUST be one of \"high\" , \"medium\" , \"low\" or \"none\" . The \"none\" value is not the same as a missing contribution from the contributions object. That value marks explicitly that a given contribution is not addressed by an experiment. A missing contribution means impact via this experiment is unknown for this contribution. Here is a contribution example: \"contributions\" : { \"reliability\" : \"high\" , \"security\" : \"none\" , \"scalability\" : \"medium\" } This sample tells us that the experiment contributes mainly to exploring reliability of the system and moderately to its scability. However, it is explicit here this experiment does not address security. On the other hand: \"contributions\" : { \"reliability\" : \"high\" , \"scalability\" : \"medium\" } This tells us the same about reliability and scalability but we can\u2019t presume anything about security. Method \u00b6 The Method describes the sequence of Probe and Action elements to apply. The Method is declared under method property at the top-level of the experiment. The method MAY have at least one element which can be either a Probe or an Action . The elements MUST be applied in the order they are declared. An empty method is allowed for running experiments with Steady States Hypothesis only. Probe \u00b6 A Probe collects information from the system during the experiment. A Probe is a JSON object. A Probe is declared fully or reference another Probe through the ref property. When declared fully, a Probe MUST declare: a type property a name property a provider property The type property MUST be the JSON string \"probe\" . The name property is a free-form JSON string that MAY be considered as an identifier within the experiment. It MAY also declare: a secret property a configuration property a background property a controls property The secret property MUST be a JSON string referencing an identifier declared in the top-level secrets property . It is assumed that when not declared, the Probe requires no secrets. The configuration property MUST be a JSON string referencing an identifier declared in the top-level configuration property . It is assumed that when not declared, the Probe requires no configuration. The background property MUST be a JSON boolean value either true or false . It is assumed that, when that property is not declared, it is set to false . When that property is set to true it indicates the Probe MUST not block and the next Action or Probe should immediately be applied. When a Probe references another Probe in the Experiment, the Probe MUST declare a single property called ref . The ref property MUST be a JSON string which MUST be the name of a declared Probe. Controls describe out-of-band capabilities applied during the experiment\u2019s execution. Action \u00b6 An Action performs an operation against the system. An Action collects information from the system during the experiment. An Action is a JSON object. An Action is declared fully or reference another Action through the ref property. When declared fully, a Action MUST declare: a type property a name property a provider property a controls property The type property MUST be the JSON string \"action\" . The name property is a free-form JSON string that MAY be considered as an identifier within the experiment. It MAY also declare: a secret property a configuration property a background property a pauses property The secret property MUST be a JSON string referencing an identifier declared in the top-level secrets property . It is assumed that when not declared, the Action requires no secrets. The configuration property MUST be a JSON string referencing an identifier declared in the top-level configuration property . It is assumed that when not declared, the Action requires no configuration. The background property MUST be a JSON boolean value either true or false . It is assumed that, when that property is not declared, it is set to false . When that property is set to true it indicates the Action MUST not block and the next Action or Probe should immediately be applied. The pauses property MUST be a JSON object which MAY have one or the two following properties: before after In both cases, the value MUST be JSON number indicating the number of seconds to wait before continuing. The before pause MUST be performed before the Action while the after MUST be performed afterwards. When a Action references another Action in the Experiment, the Action MUST declare a single property called ref . The ref property MUST be a JSON string which MUST be the name of a declared Action. Controls describe out-of-band capabilities applied during the experiment\u2019s execution. Action or Probe Provider \u00b6 A provider MUST be a JSON object which MUST declare a type property that decides the other expected properties. The type property MUST be one of \"python\" , \"http\" or \"process\" . Info This specification only mentions those three providers but it could grow to support more , such as \"go\" , \"rust\" or \"grpc\" \u2026 Python Provider \u00b6 A Python Provider declares a Python function to be applied. A Python Provider MUST declare the following: a module property a func property It SHOULD also declare an arguments property when the function expects them. The module property is the fully qualified module exposing the function. It MUST be a JSON string. The func property is the name of the function to apply. It MUST be a JSON string. When provided, the arguments property MUST be a JSON object which properties are the names of the function\u2019s arguments . When a function\u2019s signature has default values for some of its arguments, those MAY be omitted from the arguments object. In that case, those default values will be used. Argument values MUST be valid JSON entities. HTTP Provider \u00b6 A HTTP Provider declares a URL to be called. A HTTP Provider MUST declare the following: a url property The url property MUST be a JSON string representing a URL as per RFC 3986 . In addition, the provider object MAY declare any of the followings: a method property a headers property a expected_status property a arguments property a timeout property The method property MUST be a JSON string, such as \"POST\" , as per RFC 7231 . It defaults to \"GET\" . The headers property MUST be a JSON object which properties are header names and values are header values, as per RFC 7231 . When provided, the arguments property MUST be a JSON object which properties are parameters of the HTTP request. When method is \"GET\" , the arguments are mapped as a query-string of the URL. Otherwise, the arguments are passed as the request body\u2019s data and the encoding depends on the \"Content-Type\" provided in the headers object. The timeout property MUST be either a JSON number specifying how long the request should take to complete. Or a JSON array that MUST made of two JSON numbers, the first one indicating the connection timeout, the second the request timeout to respond. The HTTP provider MUST return an object with the following properties: status which MUST be a valid HTTP returned code as defined in RFC 7231 headers which MUST be an object body which MUST be a string Process Provider \u00b6 A Process Provider declares a process to be called. A Process Provider MUST declare the following: a path property The path property MUST be a JSON string of a path to an executable. In addition, the provider object MAY declare any of the followings: a arguments property a timeout property The arguments property MUST be a JSON array which defines the process arguments. Those arguments are passed in order to the process arguments. The timeout property MUST be a JSON number specifying how long the process should take to complete. The Process provider MUST return an object with the following properties: status which MUST be a scalar of the process return code stdout which MUST be bytes sequence encoded with the UTF-8 encoding representing the stdout payload of the process stderr which MUST be bytes sequence encoded with the UTF-8 encoding representing the stderr payload of the process Rollbacks \u00b6 Rollbacks declare the sequence of actions that attempt to put the system back to its initial state. The experiment MAY declare a single rollbacks property which is a JSON array consisting of Actions . A failed rollback MUST not bail the sequence of rollbacks. Secrets \u00b6 Secrets declare values that need to be passed on to Actions or Probes in a secure manner. The secrets property MUST be a JSON object. Its properties are identifiers referenced by Actions and Probes . The value of each identifier is a JSON object which properties are the secrets keys and the properties values are the secrets values. Referenced secrets MUST be injected into probes and actions when they are applied. Probes and actions MUST NOT modify the secrets. Secrets MUST be passed a mapping of keys and values to probes and actions. An example of a secrets element at the top-level: { \"secrets\" : { \"kubernetes\" : { \"token\" : \"XYZ\" } } } This can then referenced from probes or actions: { \"type\" : \"probe\" , \"secrets\" : \"kubernetes\" } Inline Secrets \u00b6 Secrets MAY be inlined in the Experiment directly. { \"secrets\" : { \"kubernetes\" : { \"token\" : \"ABCDEF-1234-XYZ\" } } } Environment Secrets \u00b6 Secrets MAY be retrieved from the environment. In that case, they must be declared as a JSON object with a type property set to \"env\" . The environment variable MUST be declared in the key property as a JSON string. { \"secrets\" : { \"kubernetes\" : { \"token\" : { \"type\" : \"env\" , \"key\" : \"KUBERNETES_TOKEN\" } } } } Vault Secrets \u00b6 Secrets MAY be retrieved from a HashiCorp vault instance . In that case, they must be declared as a JSON object with a type property set to \"vault\" . The path to the key MUST be declared in the path property as a JSON string. { \"secrets\" : { \"myapp\" : { \"token\" : { \"type\" : \"vault\" , \"path\" : \"secrets/something\" } } } } When only the path property is set, the whole secrets payload at the given path MUST be set to the Chaos Toolkit secret key. A key property MAY be set to select a specific value from the Vault secret payload. The Vault url MUST be provided in the Configuration section via the \"vault_addr\" property. Vault authentication MUST at least support: token based authentication The token MUST be provided in the Configuration section via the \"vault_token\" property AppRole authentication The role-id and secret-id MUST be provided in the Configuration section via the \"vault_role_id\" and \"vault_role_secret\" properties The Vault KV secrets version MAY be provided via the \"vault_kv_version\" Configuration key. If not provided, it MUST default to \"2\" . Examples: Vault secret at path secret/something : { \"foo\" : \"bar\" , \"baz\" : \"hello\" } Then in your Chaos Toolkit experiment: { \"secrets\" : { \"myapp\" : { \"token\" : { \"type\" : \"vault\" , \"path\" : \"secrets/something\" } } } } means the secrets will become: \"token\": { \"foo\": \"bar\", \"baz\": \"hello\" } However: { \"secrets\" : { \"myapp\" : { \"token\" : { \"type\" : \"vault\" , \"path\" : \"secrets/something\" , \"key\" : \"foo\" } } } } means the secrets will become: \"token\": \"bar\" Configuration \u00b6 Configuration is meant to provide runtime values to actions and probes . The configuration element MUST be a JSON object. The value of each property MUST be a JSON string or object which properties are considered the configuration lookup. Configuration must be passed to all Probes and actions requiring it. Probes and actions MUST NOT modify the configuration. Configurations MUST be passed a mapping of keys and values to probes and actions. An example of a configuration element at the top-level: { \"configuration\" : { \"some_service\" : \"http://127.0.0.1:8080\" , \"vault_addr\" : { \"type\" : \"env\" , \"key\" : \"VAULT_ADDR\" } } } Inline Configurations \u00b6 Configurations MAY be inlined in the Experiment directly. { \"configuration\" : { \"some-service\" : \"http://127.0.0.1:8080\" } } Environment Configurations \u00b6 Configurations MAY be retrieved from the environment. In that case, they must be declared as a JSON object with a type property set to \"env\" . The environment variable MUST be declared in the key property as a JSON string. The default key is OPTIONAL and MAY be used when the environment variable can be undefined and fallback to a default value for the experiment. { \"configuration\" : { \"vault_addr\" : { \"type\" : \"env\" , \"key\" : \"VAULT_ADDR\" , \"default\" : \"https://127.0.0.1:8200\" } } } Variable Substitution \u00b6 Probes and Actions argument values MAY be dynamically resolved at runtime. Dynamic values MUST follow the syntax ${name} where name is an identifier declared in either the Configuration or Secrets sections. When name is declared in both sections, the Configuration section MUST take precedence. Dynamic values MUST be substituted before being passed to Probes or Actions. Other values, such as the HTTP Probe url, MAY be substituted as well. Controls \u00b6 Controls describe out-of-band capabilities applied when the experiment is executed. Controls are used to declare operations that should be carried by external tools. Controls MAY be declared at each of the following levels: experiment steady-state-hypothesis activity Controls MUST be applied before and after each of those levels. Schematically, this looks like this: apply experiment control before experiment starts start experiment apply steady state control before steady-state probes are started start steady-state processing apply activity control before each probe is applied run each probe apply activity control after each probe is applied apply steady state control after steady-state probes have completed apply steady state control before method activities are started start method processing apply activity control before each activity is applied run each activity apply activity control after each activity is applied apply steady state control after method activities have completed apply steady state control before rollback activities are started start rollback processing apply activity control before each activity is applied run each activity apply activity control after each activity is applied apply steady state control after rollback activities have completed apply experiment control after experiment completes Controls MAY be omitted anywhere and MUST NOT be applied at a level they are not declared. Controls MUST NOT fail the experiment\u2019s execution due to unforeseen conditions. Controls are declared with the controls property which is set to a JSON array. Controls MAY modify Configuration and Secrets . In that case changes MUST be made visible to the experiment. An item of that array MUST be a control, which is a JSON object which MUST have the following properties: a name property which MUST be a JSON string a provider property MUST be a JSON object The provider object indicates which implementation of the control to use. It MUST declare the following properties: a type JSON string which MUST be \"python\" a module JSON string when the type property is \"python\" . It MUST be a a Python module dotted path implementing the control interface A control object MAY also declare the following property: a scope property MUST be a JSON string automatic , a JSON boolean which MUST be true by default (when omitted) The scope value MUST be one of \"before\" or \"after\" . When the scope property is omitted, the control MUST be applied before and after. When the scope property is set, the control MUST be applied only on that scope. When the automatic property is set to false , it MUST be understood that the control cannot be applied anywhere but where it is declared. Examples of Controls: Just a generic declaration of a control at the top-level of the experiment: \"controls\" : [ { \"name\" : \"tracing\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostracing.control\" } } ] Another control by applied only as post-control: \"controls\" : [ { \"name\" : \"tracing\" , \"scope\" : \"post\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostracing.control\" } } ] Finally, a top-level level control not applied anywhere else down the tree: \"controls\" : [ { \"name\" : \"tracing\" , \"automatic\" : false , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostracing.control\" } } ] Extensions \u00b6 An Experiment MAY declare an extensions property which MUST be an array of objects. Each object MUST declare a non-empty name property. Extensions are used in two scenarios: future core features that need to be ironed out by the community first vendor specific payload In both cases, their actual usage is runtime dependent, this specification does not declare any meaning to an extension. Below is an example of an Extension: { \"extensions\" : [{ \"name\" : \"vendorX\" , \"data\" : \"...\" }] } Examples \u00b6 The following examples MUST NOT be considered normative. Minimal Experiment \u00b6 Here is an example of the most minimal experiment: { \"version\" : \"1.0.0\" , \"title\" : \"Moving a file from under our feet is forgivable\" , \"description\" : \"Our application should re-create a file that was removed\" , \"contributions\" : { \"reliability\" : \"high\" , \"availability\" : \"high\" }, \"steady-state-hypothesis\" : { \"title\" : \"The file must be around first\" , \"probes\" : [ { \"type\" : \"probe\" , \"name\" : \"file-must-exist\" , \"tolerance\" : true , \"provider\" : { \"type\" : \"python\" , \"module\" : \"os.path\" , \"func\" : \"exists\" , \"arguments\" : { \"path\" : \"some/file\" } } } ] }, \"method\" : [ { \"type\" : \"action\" , \"name\" : \"file-be-gone\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"os\" , \"func\" : \"remove\" , \"arguments\" : { \"path\" : \"some/file\" } }, \"pauses\" : { \"after\" : 5 } }, { \"ref\" : \"file-must-exist\" } ] } For reference, here is the YAML equivalent (which is not official but respects the specification herein): --- version : 1.0.0 title : Moving a file from under our feet is forgivable description : Our application should re-create a file that was removed contributions : reliability : high availability : high steady-state-hypothesis : title : The file must be around first probes : - type : probe name : file-must-exist tolerance : true provider : type : python module : os.path func : exists arguments : path : some/file method : - type : action name : file-be-gone provider : type : python module : os func : remove arguments : path : some/file pauses : after : 5 - ref : file-must-exist More Complex Experiment \u00b6 Below is an example of a fully featured experiment that uses various extensions to perform actions, probing and steady-state hypothesis validation. { \"version\" : \"1.0.0\" , \"title\" : \"Are our users impacted by the loss of a function?\" , \"description\" : \"While users query the Astre function, they should not be impacted if one instance goes down.\" , \"contributions\" : { \"reliability\" : \"high\" , \"availability\" : \"high\" , \"performance\" : \"medium\" , \"security\" : \"none\" }, \"tags\" : [ \"kubernetes\" , \"openfaas\" , \"cloudnative\" ], \"configuration\" : { \"prometheus_base_url\" : \"http://demo.foo.bar\" }, \"secrets\" : { \"global\" : { \"auth\" : \"Basic XYZ\" } }, \"controls\" : [ { \"name\" : \"tracing\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostracing.control\" } } ], \"steady-state-hypothesis\" : { \"title\" : \"Function is available\" , \"probes\" : [ { \"type\" : \"probe\" , \"name\" : \"function-must-exist\" , \"tolerance\" : 200 , \"provider\" : { \"type\" : \"http\" , \"secrets\" : [ \"global\" ], \"url\" : \"http://demo.foo.bar/system/function/astre\" , \"headers\" : { \"Authorization\" : \"${auth}\" } } }, { \"type\" : \"probe\" , \"name\" : \"function-must-respond\" , \"tolerance\" : 200 , \"provider\" : { \"type\" : \"http\" , \"timeout\" : [ 3 , 5 ], \"secrets\" : [ \"global\" ], \"url\" : \"http://demo.foo.bar/function/astre\" , \"method\" : \"POST\" , \"headers\" : { \"Content-Type\" : \"application/json\" , \"Authorization\" : \"${auth}\" }, \"arguments\" : { \"city\" : \"Paris\" } } } ] }, \"method\" : [ { \"type\" : \"action\" , \"name\" : \"simulate-user-traffic\" , \"background\" : true , \"provider\" : { \"type\" : \"process\" , \"path\" : \"vegeta\" , \"arguments\" : \"-cpus 2 attack -targets=data/scenario.txt -workers=2 -connections=1 -rate=3 -timeout=3s -duration=30s -output=result.bin\" } }, { \"type\" : \"action\" , \"name\" : \"terminate-one-function\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.pod.actions\" , \"func\" : \"terminate_pods\" , \"arguments\" : { \"ns\" : \"openfaas-fn\" , \"label_selector\" : \"faas_function=astre\" , \"rand\" : true } }, \"pauses\" : { \"before\" : 5 } }, { \"type\" : \"probe\" , \"name\" : \"fetch-openfaas-gateway-logs\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.pod.probes\" , \"func\" : \"read_pod_logs\" , \"arguments\" : { \"label_selector\" : \"app=gateway\" , \"last\" : \"35s\" , \"ns\" : \"openfaas\" } } }, { \"type\" : \"probe\" , \"name\" : \"query-total-function-invocation\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosprometheus.probes\" , \"func\" : \"query_interval\" , \"secrets\" : [ \"global\" ], \"arguments\" : { \"query\" : \"gateway_function_invocation_total{function_name='astre'}\" , \"start\" : \"1 minute ago\" , \"end\" : \"now\" , \"step\" : 1 } } } ], \"rollbacks\" : [] } The equivalent YAML serialization: --- version : 1.0.0 title : Are our users impacted by the loss of a function? description : While users query the Astre function, they should not be impacted if one instance goes down. contributions : reliability : high availability : high performance : medium security : none tags : - kubernetes - openfaas - cloudnative configuration : prometheus_base_url : http://demo.foo.bar secrets : global : auth : Basic XYZ controls : - name : tracing provider : type : python module : chaostracing.control steady-state-hypothesis : title : Function is available probes : - type : probe name : function-must-exist tolerance : 200 provider : type : http secrets : - global url : http://demo.foo.bar/system/function/astre headers : Authorization : \"${auth}\" - type : probe name : function-must-respond tolerance : 200 provider : type : http timeout : - 3 - 5 secrets : - global url : http://demo.foo.bar/function/astre method : POST headers : Content-Type : application/json Authorization : \"${auth}\" arguments : city : Paris method : - type : action name : simulate-user-traffic background : true provider : type : process path : vegeta arguments : \"-cpus 2 attack -targets=data/scenario.txt -workers=2 -connections=1 -rate=3 -timeout=3s -duration=30s -output=result.bin\" - type : action name : terminate-one-function provider : type : python module : chaosk8s.pod.actions func : terminate_pods arguments : ns : openfaas-fn label_selector : faas_function=astre rand : true pauses : before : 5 - type : probe name : fetch-openfaas-gateway-logs provider : type : python module : chaosk8s.pod.probes func : read_pod_logs arguments : label_selector : app=gateway last : 35s ns : openfaas - type : probe name : query-total-function-invocation provider : type : python module : chaosprometheus.probes func : query_interval secrets : - global arguments : query : gateway_function_invocation_total{function_name='astre'} start : 1 minute ago end : now step : 1 rollbacks : []","title":"Experiment"},{"location":"reference/api/experiment/#an-open-api-for-chaos-engineering-experiments","text":"Info The current specification has not reached its 1.0.0 stable version yet. Make sure to join the discussion to provide any feedback you might have.","title":"An Open API for Chaos Engineering Experiments"},{"location":"reference/api/experiment/#introduction","text":"The purpose of this specification is to formalize the elements of a Chaos Engineering experiment and offer a way to federate the community around a common syntax and semantic. As a fairly recent field, Chaos Engineering is a dynamic and its foundations are still emerging. However, it appears certain concepts are settling down enough to start agreeing on a shared understanding. This specification is not prescriptive and does not aim at forcing the community into one direction, rather it strives at providing a common vocabulary that new practitioners can easily make sense of. It is necessary to appreciate that this document does not specify what tools, such as the Chaos Monkey or similar, should look like. Instead, this document specifies how Chaos Engineering Experiment could be described, shared and conducted collaboratively.","title":"Introduction"},{"location":"reference/api/experiment/#conventions-used-in-this-document","text":"The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 . The terms \u201cJSON\u201d, \u201cJSON text\u201d, \u201cJSON value\u201d, \u201cmember\u201d, \u201celement\u201d, \u201cobject\u201d, \u201carray\u201d, \u201cnumber\u201d, \u201cstring\u201d, \u201cboolean\u201d, \u201ctrue\u201d, \u201cfalse\u201d, and \u201cnull\u201d in this document are to be interpreted as defined in RFC 7159 .","title":"Conventions Used in This Document"},{"location":"reference/api/experiment/#other-formats","text":"While this specification uses JSON to define its elements, implementations may allow loading from other formats, such as YAML . As long as the output of such format respects the specification herein.","title":"Other formats"},{"location":"reference/api/experiment/#chaos-engineering-elements","text":"","title":"Chaos Engineering Elements"},{"location":"reference/api/experiment/#overview","text":"An Experiment is one possible description of the principles of the Chaos Engineering . The intention of such a description is to provide shared understanding around a hypothesis on how to discover system\u2019s behavior under certain conditions. An Experiment declares a steady state hypothesis , alongside probes to validate this steady state is met, and a method as a sequence actions and probes , to interact and query the system respectively. By using a variety of probes , experiments should gather information to sense behaviors in the system, potentially leading to systemic patterns that can be stabilized.","title":"Overview"},{"location":"reference/api/experiment/#experiment","text":"A Chaos Engineering experiment, or simply an experiment, describes both the elements and the order in which they should be applied. An experiment is a JSON object. An experiment MUST declare: a version property a title property a description property a method property The version property MUST be \"0.1.0\" . The experiment\u2019s title and description are meant for humans and therefore should be as descriptive as possible to clarify the experiment\u2019s rationale. Title and description are JSON strings with no maximum length. An experiment SHOULD also declare: a steady-state-hypothesis property a rollbacks property An experiment MAY finally declare: a tags property a secrets property an extension property a contributions property a controls property Tags provide a way of categorizing experiments. It is a sequence of JSON strings. Extensions define opaque payloads for vendors to carry valuable information. Contribution describes valuable properties of the target system, such as \u201creliability\u201d or \u201cdurability\u201d, that an experiment contribute to. This information can be aggregated together with other experiments\u2019 contributions to better appreciate where the focus is put and where it is not. Controls describe out-of-band capabilities applied during the experiment\u2019s execution.","title":"Experiment"},{"location":"reference/api/experiment/#steady-state-hypothesis","text":"The Steady State Hypothesis element describes what normal looks like in your system before the Method element is applied. If the steady state is not met, the Method element is not applied and the experiment MUST bail out. The Steady State Hypothesis element is a JSON object. Steady State Hypothesis element MUST declare: a title property a probes property The title is meant for humans and therefore should clarify the rationale for this hypothesis. Each Probe MUST define a tolerance property that acting as a gate mechanism for the experiment to carry on or bail. Any Probe that does not fall into the tolerance zone MUST fail the experiment. Steady State Hypothesis element MAY declare: a controls property Controls describe out-of-band capabilities applied during the experiment\u2019s execution.","title":"Steady State Hypothesis"},{"location":"reference/api/experiment/#steady-state-probe-tolerance","text":"Probes of the Steady State Hypothesis MUST declare an additional property named tolerance . The tolerance property\u2019s value MUST be one of: a scalar: JSON string, number (an integer), boolean a sequence of scalars: JSON string, number, boolean an object In the case of a scalar or the sequence, the tolerance validation MUST be strict. The value returned by the Probe MUST be checked against the scalar value. The experiment MUST bail when both fail to match. When the tolerance is a sequence. If it has only two values, those two values represent a lower and upper bound within which the Probe returned value must fall (inclusive). When the sequence has more than two elements, the Probe returned value must be contained in that sequence. When the tolerance is an object, it MUST have a type property which MUST be one of the followings: \"probe\" , \"regex\" , \"jsonpath\" or \"range\" . When the type property is \"probe\" , the object MUST be a Probe that is applied. The probe should take two arguments, value and secrets where the value is the Probe returned value and secrets a Secret object or null . Its returned status MUST be successful for the tolerance to be considered valid. When the type property is \"regex\" , the object MUST have a pattern property which MUST be a valid regular expression. The tolerance succeeds if the Probe returned value is matched against the pattern. Object MAY have a target property which MUST be a valid value returned for a given provider. When the type property is \"jsonpath\" , the object MUST have a path property which MUST be a valid JSON Path . In addition, the object MAY have a expect property which is used to compare each value matched by the JSON Path to that value. The expect property value MUST be a scalar. When the expect property is not present, the tolerance succeeds if the JSON Path matched at least one item. When the type property is \"range\" , the object MUST have a range property whuch MUST be a sequence of length two. The first entry of the sequence MUST be the lower bound and the second entry MUST be the upper bound. Both entries MUST be JSON numbers. In addition, when the Probe returned value is an object with a status property, the tested value is the value of that property. Some examples of tolerance properties. A boolean tolerance: \"tolerance\" : true A integer tolerance: \"tolerance\" : 8 A string tolerance: \"tolerance\" : \"OK\" A sequence tolerance with lower and upper bounds: \"tolerance\" : [ 4 , 9 ] A sequence tolerance, the value must be contained in that sequence: \"tolerance\" : [ 4 , 9 , 78 ] A Probe tolerance: \"tolerance\" : { \"type\" : \"probe\" , \"name\" : \"should-exist\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"os.path\" , \"func\" : \"exists\" , \"arguments\" : { \"path\" : \"some/file\" } } } A regex tolerance: \"tolerance\" : { \"type\" : \"regex\" , \"pattern\" : \"[0-9]{3}\" } A regex tolerance with a non default target: \"tolerance\" : { \"type\" : \"regex\" , \"target\" : \"stdout\" , \"pattern\" : \"[0-9]{2}\" } A jsonpath tolerance: \"tolerance\" : { \"type\" : \"jsonpath\" , \"path\" : \"foo[*].baz\" } A jsonpath tolerance with an expected value to match: \"tolerance\" : { \"type\" : \"jsonpath\" , \"path\" : \"foo[*].baz\" , \"expect\" : 4 } Two range tolerances: \"tolerance\" : { \"type\" : \"range\" , \"range\" : [ 4 , 8 ] } \"tolerance\" : { \"type\" : \"range\" , \"range\" : [ 4.6 , 8.9 ] }","title":"Steady State Probe Tolerance"},{"location":"reference/api/experiment/#contributions","text":"Contributions describe the valuable system properties an experiment targets as well as how much they contributes to it. Those properties usually refer to aspects stakeholders care about. Aggregated they offer a powerful metric about the effort and focus on building confidence across the system. Contributions are declared under the top-level contributions property as an object. Properties of that object MUST be JSON strings representing the name of a contribution. The values MUST be the weight of a given contribution and MUST be one of \"high\" , \"medium\" , \"low\" or \"none\" . The \"none\" value is not the same as a missing contribution from the contributions object. That value marks explicitly that a given contribution is not addressed by an experiment. A missing contribution means impact via this experiment is unknown for this contribution. Here is a contribution example: \"contributions\" : { \"reliability\" : \"high\" , \"security\" : \"none\" , \"scalability\" : \"medium\" } This sample tells us that the experiment contributes mainly to exploring reliability of the system and moderately to its scability. However, it is explicit here this experiment does not address security. On the other hand: \"contributions\" : { \"reliability\" : \"high\" , \"scalability\" : \"medium\" } This tells us the same about reliability and scalability but we can\u2019t presume anything about security.","title":"Contributions"},{"location":"reference/api/experiment/#method","text":"The Method describes the sequence of Probe and Action elements to apply. The Method is declared under method property at the top-level of the experiment. The method MAY have at least one element which can be either a Probe or an Action . The elements MUST be applied in the order they are declared. An empty method is allowed for running experiments with Steady States Hypothesis only.","title":"Method"},{"location":"reference/api/experiment/#probe","text":"A Probe collects information from the system during the experiment. A Probe is a JSON object. A Probe is declared fully or reference another Probe through the ref property. When declared fully, a Probe MUST declare: a type property a name property a provider property The type property MUST be the JSON string \"probe\" . The name property is a free-form JSON string that MAY be considered as an identifier within the experiment. It MAY also declare: a secret property a configuration property a background property a controls property The secret property MUST be a JSON string referencing an identifier declared in the top-level secrets property . It is assumed that when not declared, the Probe requires no secrets. The configuration property MUST be a JSON string referencing an identifier declared in the top-level configuration property . It is assumed that when not declared, the Probe requires no configuration. The background property MUST be a JSON boolean value either true or false . It is assumed that, when that property is not declared, it is set to false . When that property is set to true it indicates the Probe MUST not block and the next Action or Probe should immediately be applied. When a Probe references another Probe in the Experiment, the Probe MUST declare a single property called ref . The ref property MUST be a JSON string which MUST be the name of a declared Probe. Controls describe out-of-band capabilities applied during the experiment\u2019s execution.","title":"Probe"},{"location":"reference/api/experiment/#action","text":"An Action performs an operation against the system. An Action collects information from the system during the experiment. An Action is a JSON object. An Action is declared fully or reference another Action through the ref property. When declared fully, a Action MUST declare: a type property a name property a provider property a controls property The type property MUST be the JSON string \"action\" . The name property is a free-form JSON string that MAY be considered as an identifier within the experiment. It MAY also declare: a secret property a configuration property a background property a pauses property The secret property MUST be a JSON string referencing an identifier declared in the top-level secrets property . It is assumed that when not declared, the Action requires no secrets. The configuration property MUST be a JSON string referencing an identifier declared in the top-level configuration property . It is assumed that when not declared, the Action requires no configuration. The background property MUST be a JSON boolean value either true or false . It is assumed that, when that property is not declared, it is set to false . When that property is set to true it indicates the Action MUST not block and the next Action or Probe should immediately be applied. The pauses property MUST be a JSON object which MAY have one or the two following properties: before after In both cases, the value MUST be JSON number indicating the number of seconds to wait before continuing. The before pause MUST be performed before the Action while the after MUST be performed afterwards. When a Action references another Action in the Experiment, the Action MUST declare a single property called ref . The ref property MUST be a JSON string which MUST be the name of a declared Action. Controls describe out-of-band capabilities applied during the experiment\u2019s execution.","title":"Action"},{"location":"reference/api/experiment/#action-or-probe-provider","text":"A provider MUST be a JSON object which MUST declare a type property that decides the other expected properties. The type property MUST be one of \"python\" , \"http\" or \"process\" . Info This specification only mentions those three providers but it could grow to support more , such as \"go\" , \"rust\" or \"grpc\" \u2026","title":"Action or Probe Provider"},{"location":"reference/api/experiment/#python-provider","text":"A Python Provider declares a Python function to be applied. A Python Provider MUST declare the following: a module property a func property It SHOULD also declare an arguments property when the function expects them. The module property is the fully qualified module exposing the function. It MUST be a JSON string. The func property is the name of the function to apply. It MUST be a JSON string. When provided, the arguments property MUST be a JSON object which properties are the names of the function\u2019s arguments . When a function\u2019s signature has default values for some of its arguments, those MAY be omitted from the arguments object. In that case, those default values will be used. Argument values MUST be valid JSON entities.","title":"Python Provider"},{"location":"reference/api/experiment/#http-provider","text":"A HTTP Provider declares a URL to be called. A HTTP Provider MUST declare the following: a url property The url property MUST be a JSON string representing a URL as per RFC 3986 . In addition, the provider object MAY declare any of the followings: a method property a headers property a expected_status property a arguments property a timeout property The method property MUST be a JSON string, such as \"POST\" , as per RFC 7231 . It defaults to \"GET\" . The headers property MUST be a JSON object which properties are header names and values are header values, as per RFC 7231 . When provided, the arguments property MUST be a JSON object which properties are parameters of the HTTP request. When method is \"GET\" , the arguments are mapped as a query-string of the URL. Otherwise, the arguments are passed as the request body\u2019s data and the encoding depends on the \"Content-Type\" provided in the headers object. The timeout property MUST be either a JSON number specifying how long the request should take to complete. Or a JSON array that MUST made of two JSON numbers, the first one indicating the connection timeout, the second the request timeout to respond. The HTTP provider MUST return an object with the following properties: status which MUST be a valid HTTP returned code as defined in RFC 7231 headers which MUST be an object body which MUST be a string","title":"HTTP Provider"},{"location":"reference/api/experiment/#process-provider","text":"A Process Provider declares a process to be called. A Process Provider MUST declare the following: a path property The path property MUST be a JSON string of a path to an executable. In addition, the provider object MAY declare any of the followings: a arguments property a timeout property The arguments property MUST be a JSON array which defines the process arguments. Those arguments are passed in order to the process arguments. The timeout property MUST be a JSON number specifying how long the process should take to complete. The Process provider MUST return an object with the following properties: status which MUST be a scalar of the process return code stdout which MUST be bytes sequence encoded with the UTF-8 encoding representing the stdout payload of the process stderr which MUST be bytes sequence encoded with the UTF-8 encoding representing the stderr payload of the process","title":"Process Provider"},{"location":"reference/api/experiment/#rollbacks","text":"Rollbacks declare the sequence of actions that attempt to put the system back to its initial state. The experiment MAY declare a single rollbacks property which is a JSON array consisting of Actions . A failed rollback MUST not bail the sequence of rollbacks.","title":"Rollbacks"},{"location":"reference/api/experiment/#secrets","text":"Secrets declare values that need to be passed on to Actions or Probes in a secure manner. The secrets property MUST be a JSON object. Its properties are identifiers referenced by Actions and Probes . The value of each identifier is a JSON object which properties are the secrets keys and the properties values are the secrets values. Referenced secrets MUST be injected into probes and actions when they are applied. Probes and actions MUST NOT modify the secrets. Secrets MUST be passed a mapping of keys and values to probes and actions. An example of a secrets element at the top-level: { \"secrets\" : { \"kubernetes\" : { \"token\" : \"XYZ\" } } } This can then referenced from probes or actions: { \"type\" : \"probe\" , \"secrets\" : \"kubernetes\" }","title":"Secrets"},{"location":"reference/api/experiment/#inline-secrets","text":"Secrets MAY be inlined in the Experiment directly. { \"secrets\" : { \"kubernetes\" : { \"token\" : \"ABCDEF-1234-XYZ\" } } }","title":"Inline Secrets"},{"location":"reference/api/experiment/#environment-secrets","text":"Secrets MAY be retrieved from the environment. In that case, they must be declared as a JSON object with a type property set to \"env\" . The environment variable MUST be declared in the key property as a JSON string. { \"secrets\" : { \"kubernetes\" : { \"token\" : { \"type\" : \"env\" , \"key\" : \"KUBERNETES_TOKEN\" } } } }","title":"Environment Secrets"},{"location":"reference/api/experiment/#vault-secrets","text":"Secrets MAY be retrieved from a HashiCorp vault instance . In that case, they must be declared as a JSON object with a type property set to \"vault\" . The path to the key MUST be declared in the path property as a JSON string. { \"secrets\" : { \"myapp\" : { \"token\" : { \"type\" : \"vault\" , \"path\" : \"secrets/something\" } } } } When only the path property is set, the whole secrets payload at the given path MUST be set to the Chaos Toolkit secret key. A key property MAY be set to select a specific value from the Vault secret payload. The Vault url MUST be provided in the Configuration section via the \"vault_addr\" property. Vault authentication MUST at least support: token based authentication The token MUST be provided in the Configuration section via the \"vault_token\" property AppRole authentication The role-id and secret-id MUST be provided in the Configuration section via the \"vault_role_id\" and \"vault_role_secret\" properties The Vault KV secrets version MAY be provided via the \"vault_kv_version\" Configuration key. If not provided, it MUST default to \"2\" . Examples: Vault secret at path secret/something : { \"foo\" : \"bar\" , \"baz\" : \"hello\" } Then in your Chaos Toolkit experiment: { \"secrets\" : { \"myapp\" : { \"token\" : { \"type\" : \"vault\" , \"path\" : \"secrets/something\" } } } } means the secrets will become: \"token\": { \"foo\": \"bar\", \"baz\": \"hello\" } However: { \"secrets\" : { \"myapp\" : { \"token\" : { \"type\" : \"vault\" , \"path\" : \"secrets/something\" , \"key\" : \"foo\" } } } } means the secrets will become: \"token\": \"bar\"","title":"Vault Secrets"},{"location":"reference/api/experiment/#configuration","text":"Configuration is meant to provide runtime values to actions and probes . The configuration element MUST be a JSON object. The value of each property MUST be a JSON string or object which properties are considered the configuration lookup. Configuration must be passed to all Probes and actions requiring it. Probes and actions MUST NOT modify the configuration. Configurations MUST be passed a mapping of keys and values to probes and actions. An example of a configuration element at the top-level: { \"configuration\" : { \"some_service\" : \"http://127.0.0.1:8080\" , \"vault_addr\" : { \"type\" : \"env\" , \"key\" : \"VAULT_ADDR\" } } }","title":"Configuration"},{"location":"reference/api/experiment/#inline-configurations","text":"Configurations MAY be inlined in the Experiment directly. { \"configuration\" : { \"some-service\" : \"http://127.0.0.1:8080\" } }","title":"Inline Configurations"},{"location":"reference/api/experiment/#environment-configurations","text":"Configurations MAY be retrieved from the environment. In that case, they must be declared as a JSON object with a type property set to \"env\" . The environment variable MUST be declared in the key property as a JSON string. The default key is OPTIONAL and MAY be used when the environment variable can be undefined and fallback to a default value for the experiment. { \"configuration\" : { \"vault_addr\" : { \"type\" : \"env\" , \"key\" : \"VAULT_ADDR\" , \"default\" : \"https://127.0.0.1:8200\" } } }","title":"Environment Configurations"},{"location":"reference/api/experiment/#variable-substitution","text":"Probes and Actions argument values MAY be dynamically resolved at runtime. Dynamic values MUST follow the syntax ${name} where name is an identifier declared in either the Configuration or Secrets sections. When name is declared in both sections, the Configuration section MUST take precedence. Dynamic values MUST be substituted before being passed to Probes or Actions. Other values, such as the HTTP Probe url, MAY be substituted as well.","title":"Variable Substitution"},{"location":"reference/api/experiment/#controls","text":"Controls describe out-of-band capabilities applied when the experiment is executed. Controls are used to declare operations that should be carried by external tools. Controls MAY be declared at each of the following levels: experiment steady-state-hypothesis activity Controls MUST be applied before and after each of those levels. Schematically, this looks like this: apply experiment control before experiment starts start experiment apply steady state control before steady-state probes are started start steady-state processing apply activity control before each probe is applied run each probe apply activity control after each probe is applied apply steady state control after steady-state probes have completed apply steady state control before method activities are started start method processing apply activity control before each activity is applied run each activity apply activity control after each activity is applied apply steady state control after method activities have completed apply steady state control before rollback activities are started start rollback processing apply activity control before each activity is applied run each activity apply activity control after each activity is applied apply steady state control after rollback activities have completed apply experiment control after experiment completes Controls MAY be omitted anywhere and MUST NOT be applied at a level they are not declared. Controls MUST NOT fail the experiment\u2019s execution due to unforeseen conditions. Controls are declared with the controls property which is set to a JSON array. Controls MAY modify Configuration and Secrets . In that case changes MUST be made visible to the experiment. An item of that array MUST be a control, which is a JSON object which MUST have the following properties: a name property which MUST be a JSON string a provider property MUST be a JSON object The provider object indicates which implementation of the control to use. It MUST declare the following properties: a type JSON string which MUST be \"python\" a module JSON string when the type property is \"python\" . It MUST be a a Python module dotted path implementing the control interface A control object MAY also declare the following property: a scope property MUST be a JSON string automatic , a JSON boolean which MUST be true by default (when omitted) The scope value MUST be one of \"before\" or \"after\" . When the scope property is omitted, the control MUST be applied before and after. When the scope property is set, the control MUST be applied only on that scope. When the automatic property is set to false , it MUST be understood that the control cannot be applied anywhere but where it is declared. Examples of Controls: Just a generic declaration of a control at the top-level of the experiment: \"controls\" : [ { \"name\" : \"tracing\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostracing.control\" } } ] Another control by applied only as post-control: \"controls\" : [ { \"name\" : \"tracing\" , \"scope\" : \"post\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostracing.control\" } } ] Finally, a top-level level control not applied anywhere else down the tree: \"controls\" : [ { \"name\" : \"tracing\" , \"automatic\" : false , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostracing.control\" } } ]","title":"Controls"},{"location":"reference/api/experiment/#extensions","text":"An Experiment MAY declare an extensions property which MUST be an array of objects. Each object MUST declare a non-empty name property. Extensions are used in two scenarios: future core features that need to be ironed out by the community first vendor specific payload In both cases, their actual usage is runtime dependent, this specification does not declare any meaning to an extension. Below is an example of an Extension: { \"extensions\" : [{ \"name\" : \"vendorX\" , \"data\" : \"...\" }] }","title":"Extensions"},{"location":"reference/api/experiment/#examples","text":"The following examples MUST NOT be considered normative.","title":"Examples"},{"location":"reference/api/experiment/#minimal-experiment","text":"Here is an example of the most minimal experiment: { \"version\" : \"1.0.0\" , \"title\" : \"Moving a file from under our feet is forgivable\" , \"description\" : \"Our application should re-create a file that was removed\" , \"contributions\" : { \"reliability\" : \"high\" , \"availability\" : \"high\" }, \"steady-state-hypothesis\" : { \"title\" : \"The file must be around first\" , \"probes\" : [ { \"type\" : \"probe\" , \"name\" : \"file-must-exist\" , \"tolerance\" : true , \"provider\" : { \"type\" : \"python\" , \"module\" : \"os.path\" , \"func\" : \"exists\" , \"arguments\" : { \"path\" : \"some/file\" } } } ] }, \"method\" : [ { \"type\" : \"action\" , \"name\" : \"file-be-gone\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"os\" , \"func\" : \"remove\" , \"arguments\" : { \"path\" : \"some/file\" } }, \"pauses\" : { \"after\" : 5 } }, { \"ref\" : \"file-must-exist\" } ] } For reference, here is the YAML equivalent (which is not official but respects the specification herein): --- version : 1.0.0 title : Moving a file from under our feet is forgivable description : Our application should re-create a file that was removed contributions : reliability : high availability : high steady-state-hypothesis : title : The file must be around first probes : - type : probe name : file-must-exist tolerance : true provider : type : python module : os.path func : exists arguments : path : some/file method : - type : action name : file-be-gone provider : type : python module : os func : remove arguments : path : some/file pauses : after : 5 - ref : file-must-exist","title":"Minimal Experiment"},{"location":"reference/api/experiment/#more-complex-experiment","text":"Below is an example of a fully featured experiment that uses various extensions to perform actions, probing and steady-state hypothesis validation. { \"version\" : \"1.0.0\" , \"title\" : \"Are our users impacted by the loss of a function?\" , \"description\" : \"While users query the Astre function, they should not be impacted if one instance goes down.\" , \"contributions\" : { \"reliability\" : \"high\" , \"availability\" : \"high\" , \"performance\" : \"medium\" , \"security\" : \"none\" }, \"tags\" : [ \"kubernetes\" , \"openfaas\" , \"cloudnative\" ], \"configuration\" : { \"prometheus_base_url\" : \"http://demo.foo.bar\" }, \"secrets\" : { \"global\" : { \"auth\" : \"Basic XYZ\" } }, \"controls\" : [ { \"name\" : \"tracing\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaostracing.control\" } } ], \"steady-state-hypothesis\" : { \"title\" : \"Function is available\" , \"probes\" : [ { \"type\" : \"probe\" , \"name\" : \"function-must-exist\" , \"tolerance\" : 200 , \"provider\" : { \"type\" : \"http\" , \"secrets\" : [ \"global\" ], \"url\" : \"http://demo.foo.bar/system/function/astre\" , \"headers\" : { \"Authorization\" : \"${auth}\" } } }, { \"type\" : \"probe\" , \"name\" : \"function-must-respond\" , \"tolerance\" : 200 , \"provider\" : { \"type\" : \"http\" , \"timeout\" : [ 3 , 5 ], \"secrets\" : [ \"global\" ], \"url\" : \"http://demo.foo.bar/function/astre\" , \"method\" : \"POST\" , \"headers\" : { \"Content-Type\" : \"application/json\" , \"Authorization\" : \"${auth}\" }, \"arguments\" : { \"city\" : \"Paris\" } } } ] }, \"method\" : [ { \"type\" : \"action\" , \"name\" : \"simulate-user-traffic\" , \"background\" : true , \"provider\" : { \"type\" : \"process\" , \"path\" : \"vegeta\" , \"arguments\" : \"-cpus 2 attack -targets=data/scenario.txt -workers=2 -connections=1 -rate=3 -timeout=3s -duration=30s -output=result.bin\" } }, { \"type\" : \"action\" , \"name\" : \"terminate-one-function\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.pod.actions\" , \"func\" : \"terminate_pods\" , \"arguments\" : { \"ns\" : \"openfaas-fn\" , \"label_selector\" : \"faas_function=astre\" , \"rand\" : true } }, \"pauses\" : { \"before\" : 5 } }, { \"type\" : \"probe\" , \"name\" : \"fetch-openfaas-gateway-logs\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosk8s.pod.probes\" , \"func\" : \"read_pod_logs\" , \"arguments\" : { \"label_selector\" : \"app=gateway\" , \"last\" : \"35s\" , \"ns\" : \"openfaas\" } } }, { \"type\" : \"probe\" , \"name\" : \"query-total-function-invocation\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosprometheus.probes\" , \"func\" : \"query_interval\" , \"secrets\" : [ \"global\" ], \"arguments\" : { \"query\" : \"gateway_function_invocation_total{function_name='astre'}\" , \"start\" : \"1 minute ago\" , \"end\" : \"now\" , \"step\" : 1 } } } ], \"rollbacks\" : [] } The equivalent YAML serialization: --- version : 1.0.0 title : Are our users impacted by the loss of a function? description : While users query the Astre function, they should not be impacted if one instance goes down. contributions : reliability : high availability : high performance : medium security : none tags : - kubernetes - openfaas - cloudnative configuration : prometheus_base_url : http://demo.foo.bar secrets : global : auth : Basic XYZ controls : - name : tracing provider : type : python module : chaostracing.control steady-state-hypothesis : title : Function is available probes : - type : probe name : function-must-exist tolerance : 200 provider : type : http secrets : - global url : http://demo.foo.bar/system/function/astre headers : Authorization : \"${auth}\" - type : probe name : function-must-respond tolerance : 200 provider : type : http timeout : - 3 - 5 secrets : - global url : http://demo.foo.bar/function/astre method : POST headers : Content-Type : application/json Authorization : \"${auth}\" arguments : city : Paris method : - type : action name : simulate-user-traffic background : true provider : type : process path : vegeta arguments : \"-cpus 2 attack -targets=data/scenario.txt -workers=2 -connections=1 -rate=3 -timeout=3s -duration=30s -output=result.bin\" - type : action name : terminate-one-function provider : type : python module : chaosk8s.pod.actions func : terminate_pods arguments : ns : openfaas-fn label_selector : faas_function=astre rand : true pauses : before : 5 - type : probe name : fetch-openfaas-gateway-logs provider : type : python module : chaosk8s.pod.probes func : read_pod_logs arguments : label_selector : app=gateway last : 35s ns : openfaas - type : probe name : query-total-function-invocation provider : type : python module : chaosprometheus.probes func : query_interval secrets : - global arguments : query : gateway_function_invocation_total{function_name='astre'} start : 1 minute ago end : now step : 1 rollbacks : []","title":"More Complex Experiment"},{"location":"reference/api/journal/","text":"Experiment Journal \u00b6 Introduction \u00b6 This document describes the syntax and grammar of a Chaos Engineering experiment\u2019s output, called a journal. One should be able to walkthrough the experiment\u2019s run through its journal alone. This specification makes sense in regards to the Experiment specification itself. It is indeed a mirror to that document. Conventions Used in This Document \u00b6 The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 . The terms \u201cJSON\u201d, \u201cJSON text\u201d, \u201cJSON value\u201d, \u201cmember\u201d, \u201celement\u201d, \u201cobject\u201d, \u201carray\u201d, \u201cnumber\u201d, \u201cstring\u201d, \u201cboolean\u201d, \u201ctrue\u201d, \u201cfalse\u201d, and \u201cnull\u201d in this document are to be interpreted as defined in RFC 7159 . Other formats \u00b6 While this specification uses JSON to define its elements, implementations may allow loading from other formats, such as YAML . As long as the output of such format respects the specification herein. Journal Elements \u00b6 Overview \u00b6 A Journal is one potential output of a Chaos Engineering experiment . The objective of such journal is to collect all events that took place during the experiment\u2019s run. The journal contains static information, such as the experiment that was run, as well as runtime entries. Format \u00b6 A journal is a JSON object. Required Properties \u00b6 A journal MUST declare: a experiment property a status property a start property a end property a duration property a deviated property The experiment property MUST be a copy of the run experiment as-is and is therefore a JSON object. It MUST follow the Experiment definition. The \u0300 status property MUST be a JSON string, one of: \"completed\" : when the experiment runs fully. It does not indicate the activities in the experiment succeeded, only that they were executed as expected \"failed\" : when one of the activity reports a failed condition \"aborted\" : when the experiment breaks for unforeseen reason \"interrupted\" : when the experiment is interrupted (for instance after a signal is received) Note It is important to understand the \"completed\" status expresses that everything ran all the way. An action may not have resulted in what the operator wanted but it did not fail. Always review the entire journal to fully appreciate the actual outcome of the experiment. There are two reasons it could be marked as \"failed\" . Either a tolerance failed or if an extension made a check for a condition. So, for instance, let\u2019s say the extension made a HTTP call to your service, that call returned a 400 rather than 200. If the extension was not designed to care for this difference, then the status will be marked as \"completed\" . However, if the extension validated the HTTP response, it may have decided to fail the action which would lead to a \u0300 \u201cfailed\u201d` status. The \"aborted\" and \"interrupted\" are different, the former means of a crash somehow (say, because of a bug). The latter indicates a signal was received. Both MUST bail the entire process. The deviated property MUST be a boolean flag that MUST be set to true when the steady-state was executed after the experimental method but reported that, at least, one of its probes failed to match the expected tolerance. The start property MUST be a JSON string formatted as per RFC 3339 in UTC timezone. The end property MUST be a JSON string formatted as per RFC 3339 in UTC timezone. The duration MUST be a JSON number of difference between the end datetime and the start datetime. Recommended Properties \u00b6 In addition to those required properties, the journal SHOULD also declare the followings: a steady_states property a run property a rollbacks property The steady_states property MUST be a JSON object defining the result of the steady state hypothesis outcome. The run property MUST be a JSON array defining the result of each activity in the method element of the experiment. The rollbacks property MUST be a JSON array defining the result of each action in the rollbacks element of the experiment. Optional Properties \u00b6 In addition to those required properties, the journal MAY also declare the followings: a platform property a node property The platform property MUST be a JSON string defining the machine on which the experiment was executed. The content is free form but may be similar to the output of the uname -a command. The node property MUST be a JSON string representing the name of the machine where the experiment was run. The content is free form. Steady State \u00b6 The steady_states property holds the outcomes of the steady state hypothesis. The steady_states property MAY declare the following properties: a before property a after property The before property MUST be a JSON object describing the outcome of the hypothesis run before the method is executed. The after property MUST be a JSON object describing the outcome of the hypothesis run after the method is executed. Notice that either of those properties MAY be missing if they were not run. Steady State Outcomes \u00b6 Both the before and after properties follow the same definition. a steady_state_met property a probes property The steady_state_met property MUST be a JSON boolean. It MUST be true if the steady state hypothesis was met, false otherwise. A steady state is met when all its probes matched their tolerance. A steady state is not met at the first non-matching tolerance probe. The probes property MUST be a JSON array of probes results. Each probe result MUST declare the following properties: a activity property a status property a start property a end property a duration property a tolerance_met property a output property The activity property MUST be a JSON object, a raw copy of the executed probe . The status property MUST be a JSON string, one of \"succeeded\" or \"failed\" . The start property MUST be a JSON string formatted as per RFC 3339 in UTC timezone. The end property MUST be a JSON string formatted as per RFC 3339 in UTC timezone. The duration MUST be a JSON number of difference between the end datetime and the start datetime. The tolerance_met MUST be a JSON boolean indicating if the probe matched its tolerance or not. The output MUST be a JSON string or null . In addition, the probe result MAY contain an additional property: a exception property This property is set when the probe failed in an unforeseeable way and MUST be a JSON array or JSON string of the error trace. Run \u00b6 The run property holds the outcomes of the method element. The run property MUST be a JSON array of activity results. Each activity result MUST declare the following properties: a activity property a status property a start property a end property a duration property a output property The activity property MUST be a JSON object, a raw copy of the executed probe or action . The status property MUST be a JSON string, one of \"succeeded\" or \"failed\" . The start property MUST be a JSON string formatted as per RFC 3339 in UTC timezone. The end property MUST be a JSON string formatted as per RFC 3339 in UTC timezone. The duration MUST be a JSON number of difference between the end datetime and the start datetime. The output MUST be a JSON string or null . In addition, the activity result MAY contain an additional property: a exception property This property is set when the activity failed in an unforeseeable way and MUST be a JSON array or JSON string of the error trace. Rollbacks \u00b6 The rollbacks property holds the outcomes of the rollbacks element. The rollbacks property MUST be a JSON array of action results. Each action result MUST declare the following properties: a activity property a status property a start property a end property a duration property a output property The activity property MUST be a JSON object, a raw copy of the executed action . The status property MUST be a JSON string, one of \"succeeded\" or \"failed\" . The start property MUST be a JSON string formatted as per RFC 3339 in UTC timezone. The end property MUST be a JSON string formatted as per RFC 3339 in UTC timezone. The duration MUST be a JSON number of difference between the end datetime and the start datetime. The output MUST be a JSON string or null . In addition, the activity result MAY contain an additional property: a exception property This property is set when the action failed in an unforeseeable way and MUST be a JSON array or JSON string of the error trace. Rollbacks MUST NOT to be applied when the experiment status is \"interrupted\" .","title":"Journal"},{"location":"reference/api/journal/#experiment-journal","text":"","title":"Experiment Journal"},{"location":"reference/api/journal/#introduction","text":"This document describes the syntax and grammar of a Chaos Engineering experiment\u2019s output, called a journal. One should be able to walkthrough the experiment\u2019s run through its journal alone. This specification makes sense in regards to the Experiment specification itself. It is indeed a mirror to that document.","title":"Introduction"},{"location":"reference/api/journal/#conventions-used-in-this-document","text":"The key words \u201cMUST\u201d, \u201cMUST NOT\u201d, \u201cREQUIRED\u201d, \u201cSHALL\u201d, \u201cSHALL NOT\u201d, \u201cSHOULD\u201d, \u201cSHOULD NOT\u201d, \u201cRECOMMENDED\u201d, \u201cMAY\u201d, and \u201cOPTIONAL\u201d in this document are to be interpreted as described in RFC 2119 . The terms \u201cJSON\u201d, \u201cJSON text\u201d, \u201cJSON value\u201d, \u201cmember\u201d, \u201celement\u201d, \u201cobject\u201d, \u201carray\u201d, \u201cnumber\u201d, \u201cstring\u201d, \u201cboolean\u201d, \u201ctrue\u201d, \u201cfalse\u201d, and \u201cnull\u201d in this document are to be interpreted as defined in RFC 7159 .","title":"Conventions Used in This Document"},{"location":"reference/api/journal/#other-formats","text":"While this specification uses JSON to define its elements, implementations may allow loading from other formats, such as YAML . As long as the output of such format respects the specification herein.","title":"Other formats"},{"location":"reference/api/journal/#journal-elements","text":"","title":"Journal Elements"},{"location":"reference/api/journal/#overview","text":"A Journal is one potential output of a Chaos Engineering experiment . The objective of such journal is to collect all events that took place during the experiment\u2019s run. The journal contains static information, such as the experiment that was run, as well as runtime entries.","title":"Overview"},{"location":"reference/api/journal/#format","text":"A journal is a JSON object.","title":"Format"},{"location":"reference/api/journal/#required-properties","text":"A journal MUST declare: a experiment property a status property a start property a end property a duration property a deviated property The experiment property MUST be a copy of the run experiment as-is and is therefore a JSON object. It MUST follow the Experiment definition. The \u0300 status property MUST be a JSON string, one of: \"completed\" : when the experiment runs fully. It does not indicate the activities in the experiment succeeded, only that they were executed as expected \"failed\" : when one of the activity reports a failed condition \"aborted\" : when the experiment breaks for unforeseen reason \"interrupted\" : when the experiment is interrupted (for instance after a signal is received) Note It is important to understand the \"completed\" status expresses that everything ran all the way. An action may not have resulted in what the operator wanted but it did not fail. Always review the entire journal to fully appreciate the actual outcome of the experiment. There are two reasons it could be marked as \"failed\" . Either a tolerance failed or if an extension made a check for a condition. So, for instance, let\u2019s say the extension made a HTTP call to your service, that call returned a 400 rather than 200. If the extension was not designed to care for this difference, then the status will be marked as \"completed\" . However, if the extension validated the HTTP response, it may have decided to fail the action which would lead to a \u0300 \u201cfailed\u201d` status. The \"aborted\" and \"interrupted\" are different, the former means of a crash somehow (say, because of a bug). The latter indicates a signal was received. Both MUST bail the entire process. The deviated property MUST be a boolean flag that MUST be set to true when the steady-state was executed after the experimental method but reported that, at least, one of its probes failed to match the expected tolerance. The start property MUST be a JSON string formatted as per RFC 3339 in UTC timezone. The end property MUST be a JSON string formatted as per RFC 3339 in UTC timezone. The duration MUST be a JSON number of difference between the end datetime and the start datetime.","title":"Required Properties"},{"location":"reference/api/journal/#recommended-properties","text":"In addition to those required properties, the journal SHOULD also declare the followings: a steady_states property a run property a rollbacks property The steady_states property MUST be a JSON object defining the result of the steady state hypothesis outcome. The run property MUST be a JSON array defining the result of each activity in the method element of the experiment. The rollbacks property MUST be a JSON array defining the result of each action in the rollbacks element of the experiment.","title":"Recommended Properties"},{"location":"reference/api/journal/#optional-properties","text":"In addition to those required properties, the journal MAY also declare the followings: a platform property a node property The platform property MUST be a JSON string defining the machine on which the experiment was executed. The content is free form but may be similar to the output of the uname -a command. The node property MUST be a JSON string representing the name of the machine where the experiment was run. The content is free form.","title":"Optional Properties"},{"location":"reference/api/journal/#steady-state","text":"The steady_states property holds the outcomes of the steady state hypothesis. The steady_states property MAY declare the following properties: a before property a after property The before property MUST be a JSON object describing the outcome of the hypothesis run before the method is executed. The after property MUST be a JSON object describing the outcome of the hypothesis run after the method is executed. Notice that either of those properties MAY be missing if they were not run.","title":"Steady State"},{"location":"reference/api/journal/#steady-state-outcomes","text":"Both the before and after properties follow the same definition. a steady_state_met property a probes property The steady_state_met property MUST be a JSON boolean. It MUST be true if the steady state hypothesis was met, false otherwise. A steady state is met when all its probes matched their tolerance. A steady state is not met at the first non-matching tolerance probe. The probes property MUST be a JSON array of probes results. Each probe result MUST declare the following properties: a activity property a status property a start property a end property a duration property a tolerance_met property a output property The activity property MUST be a JSON object, a raw copy of the executed probe . The status property MUST be a JSON string, one of \"succeeded\" or \"failed\" . The start property MUST be a JSON string formatted as per RFC 3339 in UTC timezone. The end property MUST be a JSON string formatted as per RFC 3339 in UTC timezone. The duration MUST be a JSON number of difference between the end datetime and the start datetime. The tolerance_met MUST be a JSON boolean indicating if the probe matched its tolerance or not. The output MUST be a JSON string or null . In addition, the probe result MAY contain an additional property: a exception property This property is set when the probe failed in an unforeseeable way and MUST be a JSON array or JSON string of the error trace.","title":"Steady State Outcomes"},{"location":"reference/api/journal/#run","text":"The run property holds the outcomes of the method element. The run property MUST be a JSON array of activity results. Each activity result MUST declare the following properties: a activity property a status property a start property a end property a duration property a output property The activity property MUST be a JSON object, a raw copy of the executed probe or action . The status property MUST be a JSON string, one of \"succeeded\" or \"failed\" . The start property MUST be a JSON string formatted as per RFC 3339 in UTC timezone. The end property MUST be a JSON string formatted as per RFC 3339 in UTC timezone. The duration MUST be a JSON number of difference between the end datetime and the start datetime. The output MUST be a JSON string or null . In addition, the activity result MAY contain an additional property: a exception property This property is set when the activity failed in an unforeseeable way and MUST be a JSON array or JSON string of the error trace.","title":"Run"},{"location":"reference/api/journal/#rollbacks","text":"The rollbacks property holds the outcomes of the rollbacks element. The rollbacks property MUST be a JSON array of action results. Each action result MUST declare the following properties: a activity property a status property a start property a end property a duration property a output property The activity property MUST be a JSON object, a raw copy of the executed action . The status property MUST be a JSON string, one of \"succeeded\" or \"failed\" . The start property MUST be a JSON string formatted as per RFC 3339 in UTC timezone. The end property MUST be a JSON string formatted as per RFC 3339 in UTC timezone. The duration MUST be a JSON number of difference between the end datetime and the start datetime. The output MUST be a JSON string or null . In addition, the activity result MAY contain an additional property: a exception property This property is set when the action failed in an unforeseeable way and MUST be a JSON array or JSON string of the error trace. Rollbacks MUST NOT to be applied when the experiment status is \"interrupted\" .","title":"Rollbacks"},{"location":"reference/developing/core/","text":"Core Projects \u00b6 The Chaos Toolkit is made of several projects that work together to provide its service. chaostoolkit \u00b6 The chaostoolkit project is the command-line interface (CLI), in other words the command executed by users to run their experiments. That project tries to remain as shallow as possible, only providing the user interface commands by gluing other projects together. This project is implemented in Python 3. chaostoolkit-lib \u00b6 The chaostoolkit-lib project is the core library which implements the core concepts of the Chaos Toolkit. This project is implemented in Python 3. chaostoolkit-documentation \u00b6 The chaostoolkit-documehtation is the documentation source and renderer of the Chaos Toolkit. Namely, that project generates the website you are currently reading. This project is implemented in Python 3 by generating HTML from Markdown documents. chaostoolkit-kubernetes \u00b6 The chaostoolkit-kubernetes project is the Kubernetes extension. This project is implemented in Python 3. chaostoolkit-addons \u00b6 The chaostoolkit-addons project is a set of addons for Chaos Toolkit: useful controls, probes, actions and tolerances. This project is implemented in Python 3. chaostoolkit-reporting \u00b6 The chaostoolkit-reporting project is a plugin for Chaos Toolkit to create PDF/HTMl reports from executions. This project is implemented in Python 3. chaostoolkit-bundler \u00b6 The chaostoolkit-bundler project is a binary package of Chaos Toolkit and its most common extensions. In case you want a drop in Chaos Toolkit for your system. This project is implemented in Python 3.","title":"Core Projects"},{"location":"reference/developing/core/#core-projects","text":"The Chaos Toolkit is made of several projects that work together to provide its service.","title":"Core Projects"},{"location":"reference/developing/core/#chaostoolkit","text":"The chaostoolkit project is the command-line interface (CLI), in other words the command executed by users to run their experiments. That project tries to remain as shallow as possible, only providing the user interface commands by gluing other projects together. This project is implemented in Python 3.","title":"chaostoolkit"},{"location":"reference/developing/core/#chaostoolkit-lib","text":"The chaostoolkit-lib project is the core library which implements the core concepts of the Chaos Toolkit. This project is implemented in Python 3.","title":"chaostoolkit-lib"},{"location":"reference/developing/core/#chaostoolkit-documentation","text":"The chaostoolkit-documehtation is the documentation source and renderer of the Chaos Toolkit. Namely, that project generates the website you are currently reading. This project is implemented in Python 3 by generating HTML from Markdown documents.","title":"chaostoolkit-documentation"},{"location":"reference/developing/core/#chaostoolkit-kubernetes","text":"The chaostoolkit-kubernetes project is the Kubernetes extension. This project is implemented in Python 3.","title":"chaostoolkit-kubernetes"},{"location":"reference/developing/core/#chaostoolkit-addons","text":"The chaostoolkit-addons project is a set of addons for Chaos Toolkit: useful controls, probes, actions and tolerances. This project is implemented in Python 3.","title":"chaostoolkit-addons"},{"location":"reference/developing/core/#chaostoolkit-reporting","text":"The chaostoolkit-reporting project is a plugin for Chaos Toolkit to create PDF/HTMl reports from executions. This project is implemented in Python 3.","title":"chaostoolkit-reporting"},{"location":"reference/developing/core/#chaostoolkit-bundler","text":"The chaostoolkit-bundler project is a binary package of Chaos Toolkit and its most common extensions. In case you want a drop in Chaos Toolkit for your system. This project is implemented in Python 3.","title":"chaostoolkit-bundler"},{"location":"reference/developing/extensions/","text":"Extension Projects \u00b6 In addition to the core projects, the Chaos Toolkit manages some extension projects which provide probes and/or actions for experiments. Extensions can be found on the incubator GitHub organisation .","title":"Extensions Projects"},{"location":"reference/developing/extensions/#extension-projects","text":"In addition to the core projects, the Chaos Toolkit manages some extension projects which provide probes and/or actions for experiments. Extensions can be found on the incubator GitHub organisation .","title":"Extension Projects"},{"location":"reference/developing/guidelines/","text":"Developer Guidelines \u00b6 Contributors to the Chaos Toolkit are always welcome. This guide describes the general elements you probably need to know to get started. Once past those elements, you should dive into the code of each project and come discuss on our Slack . Overview \u00b6 Programming Environment \u00b6 The programming environment really is up to you. However, since the Chaos Toolkit is implemented in Python so make sure to have the right tooling for it. The most basics are: Python 3.6+ installed. A virtual environment so you can deploy the dependencies in a specific environment If you\u2019re not familiar with Python, you will find a few helpful books online, such The Hitchhiker\u2019s Guide to Python . The Ultimate Trick \u00b6 Whenever you code on one of the projects, you should run the following command so that the project you are hacking on is part of your virtual environment without being installed: cd <project-name> python setup.py develop Sometimes, your virtual env may be borked and not point to your development directory. In that case, make sure to remove any previously installed version of the project: pip uninstall <project-name> Then make sure your virtual environment point at your local directory with: pip freeze GitHub \u00b6 The Chaos Toolkit projects are hosted on GitHub . If you wish to contribute , you will need to have an account there. The general workflow is to fork the project you wish to contribute to, make your changes in a dedicated branch, rebase against the original master and finally submit a pull-request to the project with a clear description of the what and why. Chaos Toolkit Projects At A Glance \u00b6 The Chaos Toolkit is made of several projects. The core ones are: chaostoolkit : the CLI chaostoolkit-lib : the core library that propels the CLI Basically, those projects represent the Chaos Toolkit itself. However, the toolkit is naked without extensions. The currently core extensions are: chaostoolkit-kubernetes chaostoolkit-addons In addition, there are a bunch of incubating projects . Creating an Extension \u00b6 Please review the various approaches to extend the toolkit. Creating a Notification Plugin \u00b6 The Chaos Toolkit triggers events while it runs. Those events may be forwarded to any endpoint that you care for through HTTP or, when you need more control, a full Python project. There is no template for such a project yet but it is very close to an extension project except it doesn\u2019t have probes and actions. You can therefore start by cloning the extension template project and start from there. Instead, it should define a function in a module. That function takes two parameters: the notification channel settings (coming from the Chaos Toolkit settings file ) as a dictionary the event payload as a Python dictionary which is documented here The event has a payload key which is the content associated to the event. It can be one of: None when there was no payload () a string an experiment dictionary an journal dictionary Three kind of events can be triggered: started , completed and failed for each phase of the flow. Those events are defined here . A typical notification callback function will look like this: from typing import Any , Dict from chaoslib.notification import RunFlowEvent from chaoslib.types import EventPayload import logzero def notify ( settings : Dict [ str , Any ], event : EventPayload ): if event [ \"name\" ] == RunFlowEvent . RunStarted . value : logzero . info ( \"Event phase \" + event [ \"phase\" ]) logzero . info ( \"Event timestamp \" + event [ \"ts\" ]) logzero . info ( \"Event payload \" + event [ \"payload\" ]) logzero . info ( \"Event error \" + event . get ( \"error\" , \"N/A\" )) logzero is a third-party package that the Chaos Toolkit uses to log when it runs.","title":"Guidelines"},{"location":"reference/developing/guidelines/#developer-guidelines","text":"Contributors to the Chaos Toolkit are always welcome. This guide describes the general elements you probably need to know to get started. Once past those elements, you should dive into the code of each project and come discuss on our Slack .","title":"Developer Guidelines"},{"location":"reference/developing/guidelines/#overview","text":"","title":"Overview"},{"location":"reference/developing/guidelines/#programming-environment","text":"The programming environment really is up to you. However, since the Chaos Toolkit is implemented in Python so make sure to have the right tooling for it. The most basics are: Python 3.6+ installed. A virtual environment so you can deploy the dependencies in a specific environment If you\u2019re not familiar with Python, you will find a few helpful books online, such The Hitchhiker\u2019s Guide to Python .","title":"Programming Environment"},{"location":"reference/developing/guidelines/#the-ultimate-trick","text":"Whenever you code on one of the projects, you should run the following command so that the project you are hacking on is part of your virtual environment without being installed: cd <project-name> python setup.py develop Sometimes, your virtual env may be borked and not point to your development directory. In that case, make sure to remove any previously installed version of the project: pip uninstall <project-name> Then make sure your virtual environment point at your local directory with: pip freeze","title":"The Ultimate Trick"},{"location":"reference/developing/guidelines/#github","text":"The Chaos Toolkit projects are hosted on GitHub . If you wish to contribute , you will need to have an account there. The general workflow is to fork the project you wish to contribute to, make your changes in a dedicated branch, rebase against the original master and finally submit a pull-request to the project with a clear description of the what and why.","title":"GitHub"},{"location":"reference/developing/guidelines/#chaos-toolkit-projects-at-a-glance","text":"The Chaos Toolkit is made of several projects. The core ones are: chaostoolkit : the CLI chaostoolkit-lib : the core library that propels the CLI Basically, those projects represent the Chaos Toolkit itself. However, the toolkit is naked without extensions. The currently core extensions are: chaostoolkit-kubernetes chaostoolkit-addons In addition, there are a bunch of incubating projects .","title":"Chaos Toolkit Projects At A Glance"},{"location":"reference/developing/guidelines/#creating-an-extension","text":"Please review the various approaches to extend the toolkit.","title":"Creating an Extension"},{"location":"reference/developing/guidelines/#creating-a-notification-plugin","text":"The Chaos Toolkit triggers events while it runs. Those events may be forwarded to any endpoint that you care for through HTTP or, when you need more control, a full Python project. There is no template for such a project yet but it is very close to an extension project except it doesn\u2019t have probes and actions. You can therefore start by cloning the extension template project and start from there. Instead, it should define a function in a module. That function takes two parameters: the notification channel settings (coming from the Chaos Toolkit settings file ) as a dictionary the event payload as a Python dictionary which is documented here The event has a payload key which is the content associated to the event. It can be one of: None when there was no payload () a string an experiment dictionary an journal dictionary Three kind of events can be triggered: started , completed and failed for each phase of the flow. Those events are defined here . A typical notification callback function will look like this: from typing import Any , Dict from chaoslib.notification import RunFlowEvent from chaoslib.types import EventPayload import logzero def notify ( settings : Dict [ str , Any ], event : EventPayload ): if event [ \"name\" ] == RunFlowEvent . RunStarted . value : logzero . info ( \"Event phase \" + event [ \"phase\" ]) logzero . info ( \"Event timestamp \" + event [ \"ts\" ]) logzero . info ( \"Event payload \" + event [ \"payload\" ]) logzero . info ( \"Event error \" + event . get ( \"error\" , \"N/A\" )) logzero is a third-party package that the Chaos Toolkit uses to log when it runs.","title":"Creating a Notification Plugin"},{"location":"reference/developing/technologies/","text":"Technology Choices \u00b6 Python 3 \u00b6 The Chaos Toolkit is implemented in Python 3 . A high-level language with a long successfully story for writing great software. It\u2019s a common choice for tooling purpose. The language supports readability well and has a large ecosystem of libraries. It is also well-spread and easy to install. The choice to not support Python 2 is a look at Python\u2019s present and future. The choice for a dynamic language was also motivated because the Chaos Toolkit manipulates a lot of strings and that task is made straightforward with Python. Although Python natively does not generate (though it can be done ) standalone binaries like golang would. We do not believe this will harm the project and hope that package managers will eventually provide native installers. Functional \u00b6 Well, this project is not truly a functional piece of code but the code relies as little as possible on stateful constructions as provided by classes. Mutable data structures are used but mostly created and returned from functions rather than modified. Generally speaking, the project draws inspirations from certain ideas of functional paradigms but does not enforce them strictly. One notable area where the code strays away from these principles is the use of exceptions rather than returning error codes. This may change if the community expresses such an intention.","title":"Technology Choices"},{"location":"reference/developing/technologies/#technology-choices","text":"","title":"Technology Choices"},{"location":"reference/developing/technologies/#python-3","text":"The Chaos Toolkit is implemented in Python 3 . A high-level language with a long successfully story for writing great software. It\u2019s a common choice for tooling purpose. The language supports readability well and has a large ecosystem of libraries. It is also well-spread and easy to install. The choice to not support Python 2 is a look at Python\u2019s present and future. The choice for a dynamic language was also motivated because the Chaos Toolkit manipulates a lot of strings and that task is made straightforward with Python. Although Python natively does not generate (though it can be done ) standalone binaries like golang would. We do not believe this will harm the project and hope that package managers will eventually provide native installers.","title":"Python 3"},{"location":"reference/developing/technologies/#functional","text":"Well, this project is not truly a functional piece of code but the code relies as little as possible on stateful constructions as provided by classes. Mutable data structures are used but mostly created and returned from functions rather than modified. Generally speaking, the project draws inspirations from certain ideas of functional paradigms but does not enforce them strictly. One notable area where the code strays away from these principles is the use of exceptions rather than returning error codes. This may change if the community expresses such an intention.","title":"Functional"},{"location":"reference/developing/values/","text":"Key Project Values \u00b6 The following key values of the Chaos Toolkit reflect the mindset the community has when engineering the Chaos Toolkit project. Refer to our Code of Conduct as well. Simplicity \u00b6 The Chaos Toolkit aims at being a simple piece of technology both from a user and developer perspective. To achieve simplicity, the Chaos Toolkit comes as a command line interface driven by a description file. As a user, this means no code and no need to learn a programming language. As a developer, this reduces the functional surface area to consider. Extensibility \u00b6 The Chaos Toolkit does not wish to be a monolith and strives to be extended to fully reach its goal through community driven efforts. By using a description file, the implementation is not prescribed by the Chaos Toolkit project. Although we fully expect the community to eventually settle on certain implementations of probes and actions. Readability \u00b6 We believe code readability is a factor for positive maintenance and evolutivity. Readable code never goes out of fashion. As the code of the Chaos Toolkit is mostly written in Python, best practices such as defined in PEP8 . Diversity \u00b6 Although not strictly speaking referring to the technological aspect of the project, having diversity in the community will contribute to a better project overall.","title":"Key Project Values"},{"location":"reference/developing/values/#key-project-values","text":"The following key values of the Chaos Toolkit reflect the mindset the community has when engineering the Chaos Toolkit project. Refer to our Code of Conduct as well.","title":"Key Project Values"},{"location":"reference/developing/values/#simplicity","text":"The Chaos Toolkit aims at being a simple piece of technology both from a user and developer perspective. To achieve simplicity, the Chaos Toolkit comes as a command line interface driven by a description file. As a user, this means no code and no need to learn a programming language. As a developer, this reduces the functional surface area to consider.","title":"Simplicity"},{"location":"reference/developing/values/#extensibility","text":"The Chaos Toolkit does not wish to be a monolith and strives to be extended to fully reach its goal through community driven efforts. By using a description file, the implementation is not prescribed by the Chaos Toolkit project. Although we fully expect the community to eventually settle on certain implementations of probes and actions.","title":"Extensibility"},{"location":"reference/developing/values/#readability","text":"We believe code readability is a factor for positive maintenance and evolutivity. Readable code never goes out of fashion. As the code of the Chaos Toolkit is mostly written in Python, best practices such as defined in PEP8 .","title":"Readability"},{"location":"reference/developing/values/#diversity","text":"Although not strictly speaking referring to the technological aspect of the project, having diversity in the community will contribute to a better project overall.","title":"Diversity"},{"location":"reference/extending/approaches/","text":"Extending the Chaos Toolkit \u00b6 The Chaos Toolkit is designed to be extended with new probes and actions so that you can work with any failure injection and system observability systems that you choose. The toolkit has a growing number of open source extensions for just this purpose, but the intention is that you may also want to extend the Chaos Toolkit for your own unique, possible closed, systems as well. The ChaosToolkit currently supports three extension approaches: Python function : see this page for more information on creating Python extensions Process HTTP You can extend your actions and probes by implementing them using one of these approaches. Tip The Chaos Toolkit maintains a set of open-source extensions ready to be integrated into your Chaos experiments.","title":"Extension Approaches"},{"location":"reference/extending/approaches/#extending-the-chaos-toolkit","text":"The Chaos Toolkit is designed to be extended with new probes and actions so that you can work with any failure injection and system observability systems that you choose. The toolkit has a growing number of open source extensions for just this purpose, but the intention is that you may also want to extend the Chaos Toolkit for your own unique, possible closed, systems as well. The ChaosToolkit currently supports three extension approaches: Python function : see this page for more information on creating Python extensions Process HTTP You can extend your actions and probes by implementing them using one of these approaches. Tip The Chaos Toolkit maintains a set of open-source extensions ready to be integrated into your Chaos experiments.","title":"Extending the Chaos Toolkit"},{"location":"reference/extending/create-control-extension/","text":"Create a Control Extension \u00b6 A control extension implements the interface defined by the Chaos Toolkit to support the Controls element of the specification . Controls are good for changing the experiment or its environment during execution. They have the power to impact the experiment, configuration, secrets on the fly, which is unlike probes and actions. Controls Interface \u00b6 When implementing a control module, you must simply define a set of functions that are called by the Chaos Toolkit when executing the experiment. Tip All of these functions are optional, only implement the one you need. from typing import Any , Dict , List from chaoslib.types import Activity , Configuration , \\ Experiment , Hypothesis , Journal , Run , Secrets , Settings def configure_control ( configuration : Configuration = None , secrets : Secrets = None , settings : Settings = None , experiment : Experiment = None ): \"\"\" Configure the control's global state This is called once only per Chaos Toolkit's run and should be used to initialize any state your control may require. The `settings` are only passed when the control is declared in the settings file of the Chaos Toolkit. \"\"\" pass def cleanup_control (): \"\"\" Cleanup the control's global state Called once only during the experiment's execution. \"\"\" pass def before_loading_experiment_control ( context : str , ** kwargs ): \"\"\" before loading the experiment from its source. The context is the file path or URL given to the loader. Use this loader if you want to interact with that source before it is loaded. \"\"\" pass def after_loading_experiment_control ( context : str , state : Experiment , ** kwargs ): \"\"\" after loading the experiment from its source. Use this loader if you want to interact with the experiment once it's been loaded and parsed but before the validation or execution take place. \"\"\" pass def before_experiment_control ( context : Experiment , configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" before-control of the experiment's execution Called by the Chaos Toolkit before the experiment's begin but after the configuration and secrets have been loaded. \"\"\" pass def after_experiment_control ( context : Experiment , state : Journal , configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" after-control of the experiment's execution Called by the Chaos Toolkit after the experiment's completed. It passes the journal of the execution. At that stage, the after control has no influence over the execution however. Please see https://docs.chaostoolkit.org/reference/api/journal/#journal-elements for more information about the journal. \"\"\" pass def before_hypothesis_control ( context : Hypothesis , configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" before-control of the hypothesis's execution Called by the Chaos Toolkit before the steady-state hypothesis is applied. \"\"\" pass def after_hypothesis_control ( context : Hypothesis , state : Dict [ str , Any ], configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" after-control of the hypothesis's execution Called by the Chaos Toolkit after the steady-state hypothesis is complete. The `state` contains the result of the hypothesis. Refer to https://docs.chaostoolkit.org/reference/api/journal/#steady-state-outcomes for the description of that state. \"\"\" pass def before_method_control ( context : Experiment , configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" before-control of the method's execution Called by the Chaos Toolkit before the activities of the method are applied. \"\"\" pass def after_method_control ( context : Experiment , state : List [ Run ], configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" after-control of the method's execution Called by the Chaos Toolkit after the activities of the method have been applied. The `state` is the list of activity results. See https://docs.chaostoolkit.org/reference/api/journal/#run for more information. \"\"\" pass def before_rollback_control ( context : Experiment , configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" before-control of the rollback's execution Called by the Chaos Toolkit before the actions of the rollback are applied. \"\"\" pass def after_rollback_control ( context : Experiment , state : List [ Run ], configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" after-control of the rollback's execution Called by the Chaos Toolkit after the actions of the rollback have been applied. The `state` is the list of actions results. See https://docs.chaostoolkit.org/reference/api/journal/#run for more information. \"\"\" pass def before_activity_control ( context : Activity , configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" before-control of the activity's execution Called by the Chaos Toolkit before the activity is applied. \"\"\" pass def after_activity_control ( context : Activity , state : Run , configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" after-control of the activity's execution Called by the Chaos Toolkit before the activity is applied. The result of the execution is passed as `state`. See https://docs.chaostoolkit.org/reference/api/journal/#run for more information. \"\"\" pass Use your control \u00b6 Define those functions into a module that is used as a provider. For instance, assume the above definition is stored into a module chaosstuff.control , in other words a control.py module of the chaosstuff package. The package must obviously be available to the PYTHONPATH in which the chaos runs. Declare it in the experiment \u00b6 Controls can be applied per-experiment only: \"controls\" : [ { \"name\" : \"my-stuff\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosstuff.control\" } } ] Declare it in your settings \u00b6 Controls can be also applied globally to all runs by declaring them in the Chaos Toolkit settings file: controls : my-stuff : provider : type : python module : chaosstuff.control Things to note \u00b6 Unforeseen errors \u00b6 The Chaos Toolkit will not let a control abort the execution of the experiment. So if an exception is raised, it will be caught by the Chaos Toolkit, logged and the execution will carry on. Interrupting the execution \u00b6 While unforeseen errors in your controls cannot stop the execution, you can interrupt the execution by raising chaoslib.exceptions.InterruptExecution from any of your control functions. Note however, this is a harsh way to terminate the execution since, none of the rollbacks will be applied. Here is an example: from chaoslib.exceptions import InterruptExecution def after_activity_control ( context : Activity , state : Run , configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): if check_stuff ( state [ \"output\" ]): raise InterruptExecution ( \"Well things went really bad!\" ) In that case, the experiment\u2019s execution will have its status set to \"interrupted\" as described here .","title":"Create Control"},{"location":"reference/extending/create-control-extension/#create-a-control-extension","text":"A control extension implements the interface defined by the Chaos Toolkit to support the Controls element of the specification . Controls are good for changing the experiment or its environment during execution. They have the power to impact the experiment, configuration, secrets on the fly, which is unlike probes and actions.","title":"Create a Control Extension"},{"location":"reference/extending/create-control-extension/#controls-interface","text":"When implementing a control module, you must simply define a set of functions that are called by the Chaos Toolkit when executing the experiment. Tip All of these functions are optional, only implement the one you need. from typing import Any , Dict , List from chaoslib.types import Activity , Configuration , \\ Experiment , Hypothesis , Journal , Run , Secrets , Settings def configure_control ( configuration : Configuration = None , secrets : Secrets = None , settings : Settings = None , experiment : Experiment = None ): \"\"\" Configure the control's global state This is called once only per Chaos Toolkit's run and should be used to initialize any state your control may require. The `settings` are only passed when the control is declared in the settings file of the Chaos Toolkit. \"\"\" pass def cleanup_control (): \"\"\" Cleanup the control's global state Called once only during the experiment's execution. \"\"\" pass def before_loading_experiment_control ( context : str , ** kwargs ): \"\"\" before loading the experiment from its source. The context is the file path or URL given to the loader. Use this loader if you want to interact with that source before it is loaded. \"\"\" pass def after_loading_experiment_control ( context : str , state : Experiment , ** kwargs ): \"\"\" after loading the experiment from its source. Use this loader if you want to interact with the experiment once it's been loaded and parsed but before the validation or execution take place. \"\"\" pass def before_experiment_control ( context : Experiment , configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" before-control of the experiment's execution Called by the Chaos Toolkit before the experiment's begin but after the configuration and secrets have been loaded. \"\"\" pass def after_experiment_control ( context : Experiment , state : Journal , configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" after-control of the experiment's execution Called by the Chaos Toolkit after the experiment's completed. It passes the journal of the execution. At that stage, the after control has no influence over the execution however. Please see https://docs.chaostoolkit.org/reference/api/journal/#journal-elements for more information about the journal. \"\"\" pass def before_hypothesis_control ( context : Hypothesis , configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" before-control of the hypothesis's execution Called by the Chaos Toolkit before the steady-state hypothesis is applied. \"\"\" pass def after_hypothesis_control ( context : Hypothesis , state : Dict [ str , Any ], configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" after-control of the hypothesis's execution Called by the Chaos Toolkit after the steady-state hypothesis is complete. The `state` contains the result of the hypothesis. Refer to https://docs.chaostoolkit.org/reference/api/journal/#steady-state-outcomes for the description of that state. \"\"\" pass def before_method_control ( context : Experiment , configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" before-control of the method's execution Called by the Chaos Toolkit before the activities of the method are applied. \"\"\" pass def after_method_control ( context : Experiment , state : List [ Run ], configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" after-control of the method's execution Called by the Chaos Toolkit after the activities of the method have been applied. The `state` is the list of activity results. See https://docs.chaostoolkit.org/reference/api/journal/#run for more information. \"\"\" pass def before_rollback_control ( context : Experiment , configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" before-control of the rollback's execution Called by the Chaos Toolkit before the actions of the rollback are applied. \"\"\" pass def after_rollback_control ( context : Experiment , state : List [ Run ], configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" after-control of the rollback's execution Called by the Chaos Toolkit after the actions of the rollback have been applied. The `state` is the list of actions results. See https://docs.chaostoolkit.org/reference/api/journal/#run for more information. \"\"\" pass def before_activity_control ( context : Activity , configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" before-control of the activity's execution Called by the Chaos Toolkit before the activity is applied. \"\"\" pass def after_activity_control ( context : Activity , state : Run , configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): \"\"\" after-control of the activity's execution Called by the Chaos Toolkit before the activity is applied. The result of the execution is passed as `state`. See https://docs.chaostoolkit.org/reference/api/journal/#run for more information. \"\"\" pass","title":"Controls Interface"},{"location":"reference/extending/create-control-extension/#use-your-control","text":"Define those functions into a module that is used as a provider. For instance, assume the above definition is stored into a module chaosstuff.control , in other words a control.py module of the chaosstuff package. The package must obviously be available to the PYTHONPATH in which the chaos runs.","title":"Use your control"},{"location":"reference/extending/create-control-extension/#declare-it-in-the-experiment","text":"Controls can be applied per-experiment only: \"controls\" : [ { \"name\" : \"my-stuff\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"chaosstuff.control\" } } ]","title":"Declare it in the experiment"},{"location":"reference/extending/create-control-extension/#declare-it-in-your-settings","text":"Controls can be also applied globally to all runs by declaring them in the Chaos Toolkit settings file: controls : my-stuff : provider : type : python module : chaosstuff.control","title":"Declare it in your settings"},{"location":"reference/extending/create-control-extension/#things-to-note","text":"","title":"Things to note"},{"location":"reference/extending/create-control-extension/#unforeseen-errors","text":"The Chaos Toolkit will not let a control abort the execution of the experiment. So if an exception is raised, it will be caught by the Chaos Toolkit, logged and the execution will carry on.","title":"Unforeseen errors"},{"location":"reference/extending/create-control-extension/#interrupting-the-execution","text":"While unforeseen errors in your controls cannot stop the execution, you can interrupt the execution by raising chaoslib.exceptions.InterruptExecution from any of your control functions. Note however, this is a harsh way to terminate the execution since, none of the rollbacks will be applied. Here is an example: from chaoslib.exceptions import InterruptExecution def after_activity_control ( context : Activity , state : Run , configuration : Configuration = None , secrets : Secrets = None , ** kwargs ): if check_stuff ( state [ \"output\" ]): raise InterruptExecution ( \"Well things went really bad!\" ) In that case, the experiment\u2019s execution will have its status set to \"interrupted\" as described here .","title":"Interrupting the execution"},{"location":"reference/extending/extending-with-python/","text":"Extending Chaos Toolkit with Python \u00b6 Create your new Chaos Toolkit extension project \u00b6 All Chaos Toolkit extensions follow the same structure and you can benefit from a project generator such as cookiecutter . This will drive you through a set of basic questions for metadata and will create a local project you can then start put your code into. Let\u2019s use the community-driven template project : pip install -U cookiecutter cookiecutter https://github.com/dastergon/cookiecutter-chaostoolkit.git Where to put your code \u00b6 There are two extension points for a Chaos Toolkit Python extension, and they are captured in two files: actions.py and probes.py . It is conventional to use the actions.py module as the place where you expose the actions that you would like to conduct as part of your Chaos Toolkit experimental method against the environment you want to inject failure into. It\u2019s also conventional to use the probes.py module as the place where you can integrate with your system\u2019s existing observability so that those values can be used either for an experiment\u2019s Steady State Hypothesis , or as simple additional data-gathering probes that can be declared throughout an experiment\u2019s method. Running Discover on a New Extension \u00b6 Chaos Toolkit extensions often implement functionality that assists in discovering what a system, and the extension against that system, supports. This is executed using the chaos discover command. When writing your own implementation of discovery you will often want to test the new functionality locally. To do this you should first execute from your extension workspace: $ python setup.py develop Then you can exercise your discovery functionality using the --no-install flag on the chaos discover command, for example: chaos discover --no-install ext-name Log From Your Extension \u00b6 You can write to the Chaos Toolkit log by using the logzero package. from logzero import logger logger . info ( \"Hello!\" ) Make sure to add logzero as an entry of the requirements.txt file of your extension.","title":"Extend with Python"},{"location":"reference/extending/extending-with-python/#extending-chaos-toolkit-with-python","text":"","title":"Extending Chaos Toolkit with Python"},{"location":"reference/extending/extending-with-python/#create-your-new-chaos-toolkit-extension-project","text":"All Chaos Toolkit extensions follow the same structure and you can benefit from a project generator such as cookiecutter . This will drive you through a set of basic questions for metadata and will create a local project you can then start put your code into. Let\u2019s use the community-driven template project : pip install -U cookiecutter cookiecutter https://github.com/dastergon/cookiecutter-chaostoolkit.git","title":"Create your new Chaos Toolkit extension project"},{"location":"reference/extending/extending-with-python/#where-to-put-your-code","text":"There are two extension points for a Chaos Toolkit Python extension, and they are captured in two files: actions.py and probes.py . It is conventional to use the actions.py module as the place where you expose the actions that you would like to conduct as part of your Chaos Toolkit experimental method against the environment you want to inject failure into. It\u2019s also conventional to use the probes.py module as the place where you can integrate with your system\u2019s existing observability so that those values can be used either for an experiment\u2019s Steady State Hypothesis , or as simple additional data-gathering probes that can be declared throughout an experiment\u2019s method.","title":"Where to put your code"},{"location":"reference/extending/extending-with-python/#running-discover-on-a-new-extension","text":"Chaos Toolkit extensions often implement functionality that assists in discovering what a system, and the extension against that system, supports. This is executed using the chaos discover command. When writing your own implementation of discovery you will often want to test the new functionality locally. To do this you should first execute from your extension workspace: $ python setup.py develop Then you can exercise your discovery functionality using the --no-install flag on the chaos discover command, for example: chaos discover --no-install ext-name","title":"Running Discover on a New Extension"},{"location":"reference/extending/extending-with-python/#log-from-your-extension","text":"You can write to the Chaos Toolkit log by using the logzero package. from logzero import logger logger . info ( \"Hello!\" ) Make sure to add logzero as an entry of the requirements.txt file of your extension.","title":"Log From Your Extension"},{"location":"reference/tutorials/authoring_operating/","text":"Authoring vs Operating \u00b6 The Chaos Toolkit specifies an experimental protocol and format for your chaos engineering capabilities. It is often interesting to distinguish, at least in your mind, two roles. Author \u00b6 The author of an experiment is responsible for defining the structure of the experiment and its objective. The author does not have to be the one who comes with the question the experiment tries to produce evidence for. Rather, the author knows how to structure the experiment and ensures the outcome of an experiment\u2019s execution can be interpreted in an objective way. An author manipulates the following elements: steady-state hypothesis, method, rollbacks. Operator \u00b6 The operator of an experiment executes it. This role is not as clear cut as the author\u2019s role and, quite often, both are the same person. However, it is useful to keep in mind that an experiment does not and infrastructure and to be operated. Since you may end up with a fleet of Chaos Toolkit experiments running concurrently, the operator should work to ensure the executions happen in a safe and controlled manner. An operator manipulates the following elements: controls, settings","title":"Author and Operator"},{"location":"reference/tutorials/authoring_operating/#authoring-vs-operating","text":"The Chaos Toolkit specifies an experimental protocol and format for your chaos engineering capabilities. It is often interesting to distinguish, at least in your mind, two roles.","title":"Authoring vs Operating"},{"location":"reference/tutorials/authoring_operating/#author","text":"The author of an experiment is responsible for defining the structure of the experiment and its objective. The author does not have to be the one who comes with the question the experiment tries to produce evidence for. Rather, the author knows how to structure the experiment and ensures the outcome of an experiment\u2019s execution can be interpreted in an objective way. An author manipulates the following elements: steady-state hypothesis, method, rollbacks.","title":"Author"},{"location":"reference/tutorials/authoring_operating/#operator","text":"The operator of an experiment executes it. This role is not as clear cut as the author\u2019s role and, quite often, both are the same person. However, it is useful to keep in mind that an experiment does not and infrastructure and to be operated. Since you may end up with a fleet of Chaos Toolkit experiments running concurrently, the operator should work to ensure the executions happen in a safe and controlled manner. An operator manipulates the following elements: controls, settings","title":"Operator"},{"location":"reference/tutorials/blockchain/","text":"Chaos Engineering experiments against a blockchain \u00b6 Credits This article has been authored by Yolanne Lee and you can find the original article code on Yolanne\u2019s repository Blockchains are interesting concepts to test using chaos engineering principles. This is because they operate based on user usage, taking advantage of a network of participants and internal algorithms to create a distributed, decentralized ledger. This tutorial will not focus on teaching core blockchain concepts. While the setup may be done by simply pulling from my github repository, you may alternatively invest some time reading through the great tutorial here ! If you choose to proceed with the tutorial, you will need to ensure that your HTTP requests match logically with those in this tutorial. Ready? Great! Let\u2019s get started. Setup \u00b6 First, clone the code using the command below in your command line. This fetches an up-to-date version of all files required to run the experiment. $ git clone https://github.com/yolannel/CTKBlockchain Assuming you are running Python 3.6 or higher, you can install all required dependencies via the following command in your command line. Please note that it is highly recommended that you work inside of a virtual environment. A simple explanation of virtual environments may be found here ; if you\u2019re running Pycharm or another editor which has in-built venv support then check your project settings! $ pip install -U -r requirements.txt Now you\u2019re all set up to dive into the experiments! Chaos Toolkit and Blockchain \u00b6 Looking forward \u00b6 Blockchains are inherently user dependent which is why it presents a unique case to test with Chaos Toolkit. This tutorial will guide you through the thought process of creating two experiments: Testing a simple transaction Testing the consensus mechanism We will follow the above order because the consensus mechanism naturally builds off of the transaction model. If you require additional help at any point regarding the CTK, you can view the documentation . You can consider an experiment as an automator for the process you\u2019d normally do to test your program: you preset a full task flow so that your testing is repeatable and easy to run. The results of your experiment are also automatically recorded, so you can continuously expose your system to stressors and understand its strengths and weaknesses from reading the records which are automatically recorded in your journal file. Transaction Experiment \u00b6 We\u2019ll use this as an introduction to the CTK experiment as well. An experiment is a single json file which tests a functionality of your program. It has several components that must be declared: version Currently, this should always be set to 0.1.0 title This forces you to be organised with your experiments. The title should be clear for anyone reading it to understand what is being performed in the experiment. description Similarly, a more detailed description which clarifies the experiment should be included. In my case, I use this property to describe the expected behaviour of the system so the tester knows right off the bat what is happening. method This is where the majority of your work goes. More details are included below. When we start to think about creating an experiment, we need to have a well-defined goal of testing. For example, the blockchain should support making a simple transaction which can be mined; before and after mining, the chain should exist and be callable. No rollbacks should be supported since a blockchain should be immutable. This is the beginning of my experiment: { \"version\" : \"1.0.0\" , \"title\" : \"Can we make a new transaction?\" , \"description\" : \"The system should respond to a transaction request.\" , \"tags\" : [ \"tx\" ], ... The format of the json file is quite simple. Similarly to a dictionary, there is a property, and a value assigned to the property. In the case of a property which can take multiple values, such as \"tags\" , square brackets are put around the values. Try adding an additional tag to the experiment by adding a comma after the first value and adding a second tag! Below, we see the \"steady-state-hypothesis\" . We previously mentioned what the blockchain should be capable of both before and after the experiment. The steady state hypothesis tests for this condition - in this case, the condition is simply that the chain should exist. We also introduce a probe! This is the workhorse of any experiment. Probes are able to carry out tests and listen for responses. They have the following properties: type REQUIRED. The type should always be set to \"probe\" name REQUIRED. This is, again, for human readability. The name shouhld describe what the probe does. tolerance This takes a value or set of values that we can consider a \u2018good\u2019 response. Since my probe is an http request, the tolerance is set to the http status code corresponding to a successful call. You can see line 165 of blockchain.py that a successful chain GET request returns a status code of 200. provider REQUIRED. This defines what type of probe is being asked for: \"python\" , \"http\" or \"process\" . For a http probe, you must include an \"url\" property which is what you\u2019d normally test with manually. You may also include a \"timeout\" property which only considers a response successful (or within tolerance) if it is received within a certain timeframe. Units are in seconds. Note that the probe is encapsulated within square brackets. You can define additional probes within the square brackets which are separated by commas. \"steady-state-hypothesis\" : { \"title\" : \"Chain exists\" , \"probes\" : [ { \"type\" : \"probe\" , \"name\" : \"chain-exists\" , \"tolerance\" : 200 , \"provider\" : { \"type\" : \"http\" , \"timeout\" : 5 , \"url\" : \"http://127.0.0.1:5000/chain\" } } ] }, Now we reach the main body of the json file, the method. The basic structure is simply a list of probes and actions. Actions are very similar to probes, but should introduce new information or a change to the system being tested rather than simply checking its state. As an example, checking that the chain exists is a probe but creating a new transaction is an action. We have to POST a request, which differs from the previous check-chain probe which used a simple \u2018GET\u2019, so we define the \"method\" to be POST. The \"header\" is a property which defines header names. These provide information/context about the type of information being sent - in our case, the content should be read as a json request so the header defines the content-type. Certain arguments must be included (see line 173 in blockchain.py) in the json for the request to be valid according to our blockchain.py file: \"sender\" \"recipient\" \"amount\" We can include arguments in our action by simply including \"arguments\" and listing them in name-value pairs. \"method\" : [ { \"type\" : \"action\" , \"name\" : \"make-new-transaction\" , \"provider\" : { \"type\" : \"http\" , \"timeout\" : 1 , \"url\" : \"http://127.0.0.1:5000/transactions/new\" , \"method\" : \"POST\" , \"headers\" : { \"Content-Type\" : \"application/json\" }, \"arguments\" : { \"sender\" : \"me\" , \"recipient\" : \"new-other-address\" , \"amount\" : 20 } } }, { \"type\" : \"probe\" , \"name\" : \"check-chain\" , \"provider\" : { \"type\" : \"http\" , \"url\" : \"http://127.0.0.1:5000/mine\" } }, { \"type\" : \"action\" , \"name\" : \"mine-block\" , \"provider\" : { \"type\" : \"http\" , \"timeout\" : 3 , \"url\" : \"http://127.0.0.1:5000/mine\" } }, { \"type\" : \"probe\" , \"name\" : \"check-chain\" , \"provider\" : { \"type\" : \"http\" , \"url\" : \"http://127.0.0.1:5000/mine\" } } ], Finally, we reach the rollbacks! When designing an experiment, you should be aware of the capabilities of your system and also what it should be able to do. For example, I could include code in my blockchain.py file that allows a user to delete a transaction which hasn\u2019t been mined yet; however, this would violate the operation of a blockchain because blockchains derive trust from immutability (as mentioned before). So, you can see below that no rollbacks are included because a user should not be able to delete changes nor does my blockchain.py file include an option to. \"rollbacks\" : [ ] } Running the experiment \u00b6 In your command line, you should create the blockchain before running the experiment by running the blockchain.py file: $ python blockchain.py Then, you can run the experiment by using the command: $ chaos run testTransaction.json That\u2019s your first experiment! Consensus Experiment \u00b6 While our blockchain is a very simple one, it should be able to demonstrate arguably the key reason why we can call it \u2018decentralized\u2019 and \u2018distributed\u2019: the consensus mechanism. As before, see the brilliant tutorial linked above if you really want to get into the details! On a topical level, the consensus mechanism is how you determine the global truth. If one person posts a transaction on a block that was mined at the exact same time, it could accidentally branch off of the original chain. Additionally, there must be a verifiable task involved in mining that is unbiased and sufficiently difficult, but still easy to check. Both of these requirements are addressed by the consensus mechanism, which is the task required to mine a block. We will demo a simple Proof of Work, which essentially is an extremely difficult computation to solve a math puzzle. We will then start a second chain as an example of the branching that may occasionally occur; this blockchain resolves itself by taking the longest chain. We will not walk through the entire experiment this time, but the procedure planned out is as follows. Like before, we should ensure that the chain exist on two separate nodes. Simulate activity. Check the chains exist still. Resolve the chains to identify the global truth. Steps 1 and 3 should be familiar to you and I invite you to try coding them yourself! Step 2 brings an opportunity to show another use case for CTK. So far we have used the http provider, but we may also use a python provider. { \"type\" : \"action\" , \"name\" : \"simulate activity\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"os\" , \"func\" : \"system\" , \"arguments\" : { \"command\" : \"python -c \\\"import activity; activity.run(100)\\\"\" } } } To make this experiment os-agnostic, we use python to run a python file through the os.system. module This should be a Python module - in our case, we use the os module since it comes with the core Python libraries. func This should be a function in the specified module that can be run. arguments If a function takes arguments, check the documentation so you know how the arguments are titled and you can list them in the standard JSON format. Here, the argument is a command and the input is '\"python -c \\\"import activity; activity.run(100)\\\"\" The activity.py file run by simulate activity randomly posts transactions from either of the two nodes and occasionally mines a block. For reference, the approximate probability of posting a transaction to any of the two chains is 75% and accordingly, the probability of mining from either of the two chains is 25%. Finally, we want to resolve the chains. This is an http request which we\u2019ve learned earlier, and I again invite you to try your hand at it! Running the experiment \u00b6 In your command line, you should create the blockchain and start both nodes (here we use 127.0.0.1:5000 and 127.0.0.1:5001) before running the experiment: $ python blockchain.py --port 5000 .. and on a new terminal, $ python blockchain.py --port 5001 Then, you can run the experiment by using the command: $ chaos run testConsensus.json You\u2019ve completed the tutorial! Some key takeaways \u00b6 The http provider makes it simple to test user requests that are very common in web applications The Python provider is a very powerful tool that can run \u2018on its own\u2019 or other Python files The CTK at the core of it tests your system on what could possibly happen This means it is context specific - walking through this tutorial, you have seen how the experiments should be tailored to how the system should work, like how there are no rollback options. On an even more abstracted level, the CTK is an automation tool - note how the consensus test essentially automates a lot of usage and then checks. This actually makes it incredibly powerful even if you aren\u2019t specifically running a chaos experiment because there is a set process that you create which is replicable. Think of experiments as blueprints for what you want to try! Thanks \u00b6 Chaos Toolkit is an open source project hosted on Github . If you have any issues then raise them on the Github, and if you\u2019d like to contribute, start here ! The blockchain tutorial linked in the beginning is completely external to this tutorial and all credits go to Daniel van Flymen.","title":"Experimenting against a blockchain"},{"location":"reference/tutorials/blockchain/#chaos-engineering-experiments-against-a-blockchain","text":"Credits This article has been authored by Yolanne Lee and you can find the original article code on Yolanne\u2019s repository Blockchains are interesting concepts to test using chaos engineering principles. This is because they operate based on user usage, taking advantage of a network of participants and internal algorithms to create a distributed, decentralized ledger. This tutorial will not focus on teaching core blockchain concepts. While the setup may be done by simply pulling from my github repository, you may alternatively invest some time reading through the great tutorial here ! If you choose to proceed with the tutorial, you will need to ensure that your HTTP requests match logically with those in this tutorial. Ready? Great! Let\u2019s get started.","title":"Chaos Engineering experiments against a blockchain"},{"location":"reference/tutorials/blockchain/#setup","text":"First, clone the code using the command below in your command line. This fetches an up-to-date version of all files required to run the experiment. $ git clone https://github.com/yolannel/CTKBlockchain Assuming you are running Python 3.6 or higher, you can install all required dependencies via the following command in your command line. Please note that it is highly recommended that you work inside of a virtual environment. A simple explanation of virtual environments may be found here ; if you\u2019re running Pycharm or another editor which has in-built venv support then check your project settings! $ pip install -U -r requirements.txt Now you\u2019re all set up to dive into the experiments!","title":"Setup"},{"location":"reference/tutorials/blockchain/#chaos-toolkit-and-blockchain","text":"","title":"Chaos Toolkit and Blockchain"},{"location":"reference/tutorials/blockchain/#looking-forward","text":"Blockchains are inherently user dependent which is why it presents a unique case to test with Chaos Toolkit. This tutorial will guide you through the thought process of creating two experiments: Testing a simple transaction Testing the consensus mechanism We will follow the above order because the consensus mechanism naturally builds off of the transaction model. If you require additional help at any point regarding the CTK, you can view the documentation . You can consider an experiment as an automator for the process you\u2019d normally do to test your program: you preset a full task flow so that your testing is repeatable and easy to run. The results of your experiment are also automatically recorded, so you can continuously expose your system to stressors and understand its strengths and weaknesses from reading the records which are automatically recorded in your journal file.","title":"Looking forward"},{"location":"reference/tutorials/blockchain/#transaction-experiment","text":"We\u2019ll use this as an introduction to the CTK experiment as well. An experiment is a single json file which tests a functionality of your program. It has several components that must be declared: version Currently, this should always be set to 0.1.0 title This forces you to be organised with your experiments. The title should be clear for anyone reading it to understand what is being performed in the experiment. description Similarly, a more detailed description which clarifies the experiment should be included. In my case, I use this property to describe the expected behaviour of the system so the tester knows right off the bat what is happening. method This is where the majority of your work goes. More details are included below. When we start to think about creating an experiment, we need to have a well-defined goal of testing. For example, the blockchain should support making a simple transaction which can be mined; before and after mining, the chain should exist and be callable. No rollbacks should be supported since a blockchain should be immutable. This is the beginning of my experiment: { \"version\" : \"1.0.0\" , \"title\" : \"Can we make a new transaction?\" , \"description\" : \"The system should respond to a transaction request.\" , \"tags\" : [ \"tx\" ], ... The format of the json file is quite simple. Similarly to a dictionary, there is a property, and a value assigned to the property. In the case of a property which can take multiple values, such as \"tags\" , square brackets are put around the values. Try adding an additional tag to the experiment by adding a comma after the first value and adding a second tag! Below, we see the \"steady-state-hypothesis\" . We previously mentioned what the blockchain should be capable of both before and after the experiment. The steady state hypothesis tests for this condition - in this case, the condition is simply that the chain should exist. We also introduce a probe! This is the workhorse of any experiment. Probes are able to carry out tests and listen for responses. They have the following properties: type REQUIRED. The type should always be set to \"probe\" name REQUIRED. This is, again, for human readability. The name shouhld describe what the probe does. tolerance This takes a value or set of values that we can consider a \u2018good\u2019 response. Since my probe is an http request, the tolerance is set to the http status code corresponding to a successful call. You can see line 165 of blockchain.py that a successful chain GET request returns a status code of 200. provider REQUIRED. This defines what type of probe is being asked for: \"python\" , \"http\" or \"process\" . For a http probe, you must include an \"url\" property which is what you\u2019d normally test with manually. You may also include a \"timeout\" property which only considers a response successful (or within tolerance) if it is received within a certain timeframe. Units are in seconds. Note that the probe is encapsulated within square brackets. You can define additional probes within the square brackets which are separated by commas. \"steady-state-hypothesis\" : { \"title\" : \"Chain exists\" , \"probes\" : [ { \"type\" : \"probe\" , \"name\" : \"chain-exists\" , \"tolerance\" : 200 , \"provider\" : { \"type\" : \"http\" , \"timeout\" : 5 , \"url\" : \"http://127.0.0.1:5000/chain\" } } ] }, Now we reach the main body of the json file, the method. The basic structure is simply a list of probes and actions. Actions are very similar to probes, but should introduce new information or a change to the system being tested rather than simply checking its state. As an example, checking that the chain exists is a probe but creating a new transaction is an action. We have to POST a request, which differs from the previous check-chain probe which used a simple \u2018GET\u2019, so we define the \"method\" to be POST. The \"header\" is a property which defines header names. These provide information/context about the type of information being sent - in our case, the content should be read as a json request so the header defines the content-type. Certain arguments must be included (see line 173 in blockchain.py) in the json for the request to be valid according to our blockchain.py file: \"sender\" \"recipient\" \"amount\" We can include arguments in our action by simply including \"arguments\" and listing them in name-value pairs. \"method\" : [ { \"type\" : \"action\" , \"name\" : \"make-new-transaction\" , \"provider\" : { \"type\" : \"http\" , \"timeout\" : 1 , \"url\" : \"http://127.0.0.1:5000/transactions/new\" , \"method\" : \"POST\" , \"headers\" : { \"Content-Type\" : \"application/json\" }, \"arguments\" : { \"sender\" : \"me\" , \"recipient\" : \"new-other-address\" , \"amount\" : 20 } } }, { \"type\" : \"probe\" , \"name\" : \"check-chain\" , \"provider\" : { \"type\" : \"http\" , \"url\" : \"http://127.0.0.1:5000/mine\" } }, { \"type\" : \"action\" , \"name\" : \"mine-block\" , \"provider\" : { \"type\" : \"http\" , \"timeout\" : 3 , \"url\" : \"http://127.0.0.1:5000/mine\" } }, { \"type\" : \"probe\" , \"name\" : \"check-chain\" , \"provider\" : { \"type\" : \"http\" , \"url\" : \"http://127.0.0.1:5000/mine\" } } ], Finally, we reach the rollbacks! When designing an experiment, you should be aware of the capabilities of your system and also what it should be able to do. For example, I could include code in my blockchain.py file that allows a user to delete a transaction which hasn\u2019t been mined yet; however, this would violate the operation of a blockchain because blockchains derive trust from immutability (as mentioned before). So, you can see below that no rollbacks are included because a user should not be able to delete changes nor does my blockchain.py file include an option to. \"rollbacks\" : [ ] }","title":"Transaction Experiment"},{"location":"reference/tutorials/blockchain/#running-the-experiment","text":"In your command line, you should create the blockchain before running the experiment by running the blockchain.py file: $ python blockchain.py Then, you can run the experiment by using the command: $ chaos run testTransaction.json That\u2019s your first experiment!","title":"Running the experiment"},{"location":"reference/tutorials/blockchain/#consensus-experiment","text":"While our blockchain is a very simple one, it should be able to demonstrate arguably the key reason why we can call it \u2018decentralized\u2019 and \u2018distributed\u2019: the consensus mechanism. As before, see the brilliant tutorial linked above if you really want to get into the details! On a topical level, the consensus mechanism is how you determine the global truth. If one person posts a transaction on a block that was mined at the exact same time, it could accidentally branch off of the original chain. Additionally, there must be a verifiable task involved in mining that is unbiased and sufficiently difficult, but still easy to check. Both of these requirements are addressed by the consensus mechanism, which is the task required to mine a block. We will demo a simple Proof of Work, which essentially is an extremely difficult computation to solve a math puzzle. We will then start a second chain as an example of the branching that may occasionally occur; this blockchain resolves itself by taking the longest chain. We will not walk through the entire experiment this time, but the procedure planned out is as follows. Like before, we should ensure that the chain exist on two separate nodes. Simulate activity. Check the chains exist still. Resolve the chains to identify the global truth. Steps 1 and 3 should be familiar to you and I invite you to try coding them yourself! Step 2 brings an opportunity to show another use case for CTK. So far we have used the http provider, but we may also use a python provider. { \"type\" : \"action\" , \"name\" : \"simulate activity\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"os\" , \"func\" : \"system\" , \"arguments\" : { \"command\" : \"python -c \\\"import activity; activity.run(100)\\\"\" } } } To make this experiment os-agnostic, we use python to run a python file through the os.system. module This should be a Python module - in our case, we use the os module since it comes with the core Python libraries. func This should be a function in the specified module that can be run. arguments If a function takes arguments, check the documentation so you know how the arguments are titled and you can list them in the standard JSON format. Here, the argument is a command and the input is '\"python -c \\\"import activity; activity.run(100)\\\"\" The activity.py file run by simulate activity randomly posts transactions from either of the two nodes and occasionally mines a block. For reference, the approximate probability of posting a transaction to any of the two chains is 75% and accordingly, the probability of mining from either of the two chains is 25%. Finally, we want to resolve the chains. This is an http request which we\u2019ve learned earlier, and I again invite you to try your hand at it!","title":"Consensus Experiment"},{"location":"reference/tutorials/blockchain/#running-the-experiment_1","text":"In your command line, you should create the blockchain and start both nodes (here we use 127.0.0.1:5000 and 127.0.0.1:5001) before running the experiment: $ python blockchain.py --port 5000 .. and on a new terminal, $ python blockchain.py --port 5001 Then, you can run the experiment by using the command: $ chaos run testConsensus.json You\u2019ve completed the tutorial!","title":"Running the experiment"},{"location":"reference/tutorials/blockchain/#some-key-takeaways","text":"The http provider makes it simple to test user requests that are very common in web applications The Python provider is a very powerful tool that can run \u2018on its own\u2019 or other Python files The CTK at the core of it tests your system on what could possibly happen This means it is context specific - walking through this tutorial, you have seen how the experiments should be tailored to how the system should work, like how there are no rollback options. On an even more abstracted level, the CTK is an automation tool - note how the consensus test essentially automates a lot of usage and then checks. This actually makes it incredibly powerful even if you aren\u2019t specifically running a chaos experiment because there is a set process that you create which is replicable. Think of experiments as blueprints for what you want to try!","title":"Some key takeaways"},{"location":"reference/tutorials/blockchain/#thanks","text":"Chaos Toolkit is an open source project hosted on Github . If you have any issues then raise them on the Github, and if you\u2019d like to contribute, start here ! The blockchain tutorial linked in the beginning is completely external to this tutorial and all credits go to Daniel van Flymen.","title":"Thanks"},{"location":"reference/tutorials/extend/","text":"Learn the basic of extending the Chaos Toolkit \u00b6 The Chaos Toolkit comes with a rich catalog of extensions. Sometimes however, this library is not enough. So, how do you go about extending the Chaos Toolkit? It turns out there are a variety of ways. Generate a binary and execute it from the experiment \u00b6 The Chaos Toolkit is written in Python 3, but you may not have the Python skills or willingness to develop it. One quick solution is to write your own small binary (say you are a rust or golang shop) and call it as a process action. Keep in mind that the binary may be used as a probe in the steady-state so ensure its returned value is easily processed via regex or jsonpath tolerance types. At the very least, the process should signal through its exit code if it completed normally (with 0). For example, let\u2019s create a simple binary with rust. In a file named echo.rs : use std :: env ; fn main () { let args : Vec < String > = env :: args (). collect (); println! ( & args [ 1 .. ]); } rustc echo.rs ./echo hello world [\"hello\", \"world\"] echo $? 0 An action using this binary would look like this: { \"name\" : \"echo-my-message\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"process\" , \"path\" : \"echo\" , \"arguments\" : \"hello world\" , } } This assumes the binary is on the chaos PATH and the user has permissions. Call a HTTP endpoint \u00b6 Sometimes, you have HTTP endpoints that are used internally for specific operational tasks. They are internals and crafted for your unique needs. This can be enough to create the bespoke condition for your probes and actions to call via a http provider. Create a simple Python function \u00b6 While extending with a piece of Python code may sound more work, it does not have to be. Indeed, you can create a simple Python module and have a set of functions that are called from your experiment directly. THe trick is to ensure the module can be found in the PYTHONPATH . Let\u2019s see an example: Assuming a Python module called kettle.py : from chaoslib.types import Configuration , Secrets __all__ = [ \"put_on\" ] def put_on ( temperature : int = 90 , configuration : Configuration = None , secrets : Secrets = None ) -> None : \"\"\" Sets the kettle to the expected temperature (celcius) and put it on. Will return when the kettle has reached it. \"\"\" # do something here pass If kettle.py lives next to experiment.json then the action could be: { \"name\" : \"put-kettle-on\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"kettle\" , \"func\" : \"put_on\" , \"arguments\" : { \"temperature\" : 80 } } } You could finally make it available as follows: ls kettle.py experiment.json export PYTHONPATH=`pwd` chaos run experiment.json The Python module does not have to live next to the experiment. It can also contain more than one function of course.","title":"An overview of extending the Chaos Toolkit"},{"location":"reference/tutorials/extend/#learn-the-basic-of-extending-the-chaos-toolkit","text":"The Chaos Toolkit comes with a rich catalog of extensions. Sometimes however, this library is not enough. So, how do you go about extending the Chaos Toolkit? It turns out there are a variety of ways.","title":"Learn the basic of extending the Chaos Toolkit"},{"location":"reference/tutorials/extend/#generate-a-binary-and-execute-it-from-the-experiment","text":"The Chaos Toolkit is written in Python 3, but you may not have the Python skills or willingness to develop it. One quick solution is to write your own small binary (say you are a rust or golang shop) and call it as a process action. Keep in mind that the binary may be used as a probe in the steady-state so ensure its returned value is easily processed via regex or jsonpath tolerance types. At the very least, the process should signal through its exit code if it completed normally (with 0). For example, let\u2019s create a simple binary with rust. In a file named echo.rs : use std :: env ; fn main () { let args : Vec < String > = env :: args (). collect (); println! ( & args [ 1 .. ]); } rustc echo.rs ./echo hello world [\"hello\", \"world\"] echo $? 0 An action using this binary would look like this: { \"name\" : \"echo-my-message\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"process\" , \"path\" : \"echo\" , \"arguments\" : \"hello world\" , } } This assumes the binary is on the chaos PATH and the user has permissions.","title":"Generate a binary and execute it from the experiment"},{"location":"reference/tutorials/extend/#call-a-http-endpoint","text":"Sometimes, you have HTTP endpoints that are used internally for specific operational tasks. They are internals and crafted for your unique needs. This can be enough to create the bespoke condition for your probes and actions to call via a http provider.","title":"Call a HTTP endpoint"},{"location":"reference/tutorials/extend/#create-a-simple-python-function","text":"While extending with a piece of Python code may sound more work, it does not have to be. Indeed, you can create a simple Python module and have a set of functions that are called from your experiment directly. THe trick is to ensure the module can be found in the PYTHONPATH . Let\u2019s see an example: Assuming a Python module called kettle.py : from chaoslib.types import Configuration , Secrets __all__ = [ \"put_on\" ] def put_on ( temperature : int = 90 , configuration : Configuration = None , secrets : Secrets = None ) -> None : \"\"\" Sets the kettle to the expected temperature (celcius) and put it on. Will return when the kettle has reached it. \"\"\" # do something here pass If kettle.py lives next to experiment.json then the action could be: { \"name\" : \"put-kettle-on\" , \"type\" : \"action\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"kettle\" , \"func\" : \"put_on\" , \"arguments\" : { \"temperature\" : 80 } } } You could finally make it available as follows: ls kettle.py experiment.json export PYTHONPATH=`pwd` chaos run experiment.json The Python module does not have to live next to the experiment. It can also contain more than one function of course.","title":"Create a simple Python function"},{"location":"reference/tutorials/run-flow/","text":"Learn all about the experiment execution\u2019s flow \u00b6 Execution Flow Diagram \u00b6 The diagram below shows the flow used by Chaos Toolkit when running an experiment: What\u2019s happening when running an experiment? \u00b6 Chaos Toolkit runs an experiment as given in the experiment\u2019s file. The default behavior is straightforward, it runs the activities from the file sequentially in the order they are declared. The first block executed, if found, is the steady-state hypothesis block. In this particular instances, it acts as a sort of a gateway to say \u201cthe system is normal and meeting its baseline, you can carry on\u201d. By doing so, we notify the world is in a state which we can comprehend and make sense of. Then, the method is applied. Usually the method consists of at least an action but can also contain probes and other actions. The first action defines the turbulence we want to introduce into the system and see if it impacts our initial baseline. Other actions should be few in numbers or they may render the reading of the results challenging. Probes are merely data collectors of what is happening in your system as the turbulence is happening. It helps the analysis. Next, the steady state hypothesis is executed again but, this time, it tells us if our baseline has deviated considering the perturbation. Finally, rollbacks are applied. They serve to usually undo the condition but should not be misunderstood as a way to put the system back to a normal state when the deviation really triggered a dire chain of events for your system. One experiment but a variety of execution strategies \u00b6 Schematically, the execution flow runs the hypothesis, the method, the hypothesis again and finally the rollbacks. However, this flow can somewhat controlled via the Chaos Toolkit runtime flags. Hypothesis strategies \u00b6 The default behavior is to execute the hypothesis before and after the method. Unless, the hypothesis fails during the \u201cbefore\u201d phase. In that case, the execution terminates as \"failed\" to signal the system wasn\u2019t in an appropriate baseline state for the experiment to make sense. The chaos run command provides the --hypothesis-strategy flag to change the default behavior. Sometimes, you have an experiment where you know the state is not appropriate but you want to see if a specific condition could bring it back and make the hypothesis valid after the method was applied. In that case, you should use --hypothesis-strategy=after-method-only . On the contrary, if you don\u2019t want to assert any deviation, you can decide to run the hypothesis only before with --hypothesis-strategy=before-method-only . More interesting use cases can then be applied. What if you have a long method and wish to not wait until it finishes to verify the hypothesis. Well, then you can use `--hypothesis-strategy=continuously to indicate that, on top of the default behavior, you want the hypothesis block to be applied during the method periodically. You can change the period, which defaults to every second, with --hypothesis-frequency=10 . Notice that, in that case, Chaos Toolkit will not interrupt as soon as a deviation is found. To do that, you need to pass the additional --fail-fast flag. Finally, you can also use --hypothesis-strategy=during-method-only to have the same behavior as continuously but removing the default verification before and after the method. Rollback strategies \u00b6 Rollbacks are always executed save for three conditions: the hypothesis failed on its first pass. Before the method was applied. There is nothing to rollback in that case. the Chaos Toolkit received a signal such as SIGINT. Maybe the operator wants to investigate the system as it is. a control triggered an interruption You may change that behavior with a chaos run flag. Pass --rollback-strategy=always to apply rollbacks no matter the state of the execution. Use --rollback-strategy=never to never play them. This can be useful during authoring of the experiment sometimes. Use --rollback-strategy=deviated to play rollbacks only if a deviation was found. Terminating the execution gracefully \u00b6 Chaos Engineering is a powerful practice that may lead to undesirable side effects in your system. Sometimes, it is expected that an operator, or an automated service, terminates an experiment much earlier to prevent further difficulties. Let\u2019s start with the default behavior \u00b6 When an experiment runs to its end it means that, even if a deviation was found, the Chaos Toolkit should leave nothing hanging around, such as zombie processes. Also, if rollbacks were declared and requested to be applied, they will be played. In other words, if your experiment is properly constructed, you should not have to do anything else. Chaos Toolkit makes no promises that your system will be back to its normal however. The discovery you make along the way usually resolves in impacts that cannot be anticipated. This means that when an experiment finishes, your system may well be in a very strange state but it does not mean Chaos Toolkit failed at doing its job. In fact, it\u2019s quite the exact nature of the beast: Chaos Engineering is making those pain points very clear to all. Experiments can be interrupted. In that case, Chaos Toolkit tries its best to abide by the runtime condition that you set. For instance, if you decided to always play the rollbacks, Chaos Toolkit will execute them. The default behavior is not to play them however for the simple reason that if you interrupted an experiment, you may well want to investigate the system and if rollbacks were executed, you may lose some important traces or state. Digging into the interruption\u2019s flow \u00b6 When the Chaos Toolkit receives a signal, it starts the termination flow of the experiment: When this happens during the first pass of the steady-state hypothesis block, this means the experiment finishes before its method is applied. In that case, rollbacks do not need to be played in any case. When the signal is caught during the method, remaining activities are not executed and the current running experiment is completed. Rollbacks are played if the strategy requested they are played. Otherwise, they are ignored. If an activity is running in the background, the experiment will wait until it finishes. When the signal is caught during the rollbacks, remaining actions are not played and the experiment finishes. Reacting to signals, aka being a good citizen \u00b6 The Chaos Toolkit knows it makes operators confident it will act appropriately upon receiving a variety of signals . It supports therefore the following signals: SIGINT Mostly received when the operator hits Ctrl-C. This triggers the interruption flow. SIGTERM This signal is often used by other processes to indicate the Chaos Toolkit process ought to terminate. For instance, this is the signal sent to Kubernetes pods (with a graceful period before the harsher SIGKILL) SIGUSR1 / SIGUSR2 (Unix only) These two signals are rarely sent by operators but are used so that experiment extension author can programmatically terminate the experiment without having to wait for any blocking operation. In all cases, the termination flow is triggered. The only different one is SIGUSR2 which will always ignore rollbacks and will not wait for background activities to terminate normally. In other words, SIGUSR2 is the only way you can terminate harshly an experiment. Otherwise, there are no visible difference between SIGINT , SIGTERM and SIGUSR1 .","title":"Understand the Execution Flow"},{"location":"reference/tutorials/run-flow/#learn-all-about-the-experiment-executions-flow","text":"","title":"Learn all about the experiment execution's flow"},{"location":"reference/tutorials/run-flow/#execution-flow-diagram","text":"The diagram below shows the flow used by Chaos Toolkit when running an experiment:","title":"Execution Flow Diagram"},{"location":"reference/tutorials/run-flow/#whats-happening-when-running-an-experiment","text":"Chaos Toolkit runs an experiment as given in the experiment\u2019s file. The default behavior is straightforward, it runs the activities from the file sequentially in the order they are declared. The first block executed, if found, is the steady-state hypothesis block. In this particular instances, it acts as a sort of a gateway to say \u201cthe system is normal and meeting its baseline, you can carry on\u201d. By doing so, we notify the world is in a state which we can comprehend and make sense of. Then, the method is applied. Usually the method consists of at least an action but can also contain probes and other actions. The first action defines the turbulence we want to introduce into the system and see if it impacts our initial baseline. Other actions should be few in numbers or they may render the reading of the results challenging. Probes are merely data collectors of what is happening in your system as the turbulence is happening. It helps the analysis. Next, the steady state hypothesis is executed again but, this time, it tells us if our baseline has deviated considering the perturbation. Finally, rollbacks are applied. They serve to usually undo the condition but should not be misunderstood as a way to put the system back to a normal state when the deviation really triggered a dire chain of events for your system.","title":"What's happening when running an experiment?"},{"location":"reference/tutorials/run-flow/#one-experiment-but-a-variety-of-execution-strategies","text":"Schematically, the execution flow runs the hypothesis, the method, the hypothesis again and finally the rollbacks. However, this flow can somewhat controlled via the Chaos Toolkit runtime flags.","title":"One experiment but a variety of execution strategies"},{"location":"reference/tutorials/run-flow/#hypothesis-strategies","text":"The default behavior is to execute the hypothesis before and after the method. Unless, the hypothesis fails during the \u201cbefore\u201d phase. In that case, the execution terminates as \"failed\" to signal the system wasn\u2019t in an appropriate baseline state for the experiment to make sense. The chaos run command provides the --hypothesis-strategy flag to change the default behavior. Sometimes, you have an experiment where you know the state is not appropriate but you want to see if a specific condition could bring it back and make the hypothesis valid after the method was applied. In that case, you should use --hypothesis-strategy=after-method-only . On the contrary, if you don\u2019t want to assert any deviation, you can decide to run the hypothesis only before with --hypothesis-strategy=before-method-only . More interesting use cases can then be applied. What if you have a long method and wish to not wait until it finishes to verify the hypothesis. Well, then you can use `--hypothesis-strategy=continuously to indicate that, on top of the default behavior, you want the hypothesis block to be applied during the method periodically. You can change the period, which defaults to every second, with --hypothesis-frequency=10 . Notice that, in that case, Chaos Toolkit will not interrupt as soon as a deviation is found. To do that, you need to pass the additional --fail-fast flag. Finally, you can also use --hypothesis-strategy=during-method-only to have the same behavior as continuously but removing the default verification before and after the method.","title":"Hypothesis strategies"},{"location":"reference/tutorials/run-flow/#rollback-strategies","text":"Rollbacks are always executed save for three conditions: the hypothesis failed on its first pass. Before the method was applied. There is nothing to rollback in that case. the Chaos Toolkit received a signal such as SIGINT. Maybe the operator wants to investigate the system as it is. a control triggered an interruption You may change that behavior with a chaos run flag. Pass --rollback-strategy=always to apply rollbacks no matter the state of the execution. Use --rollback-strategy=never to never play them. This can be useful during authoring of the experiment sometimes. Use --rollback-strategy=deviated to play rollbacks only if a deviation was found.","title":"Rollback strategies"},{"location":"reference/tutorials/run-flow/#terminating-the-execution-gracefully","text":"Chaos Engineering is a powerful practice that may lead to undesirable side effects in your system. Sometimes, it is expected that an operator, or an automated service, terminates an experiment much earlier to prevent further difficulties.","title":"Terminating the execution gracefully"},{"location":"reference/tutorials/run-flow/#lets-start-with-the-default-behavior","text":"When an experiment runs to its end it means that, even if a deviation was found, the Chaos Toolkit should leave nothing hanging around, such as zombie processes. Also, if rollbacks were declared and requested to be applied, they will be played. In other words, if your experiment is properly constructed, you should not have to do anything else. Chaos Toolkit makes no promises that your system will be back to its normal however. The discovery you make along the way usually resolves in impacts that cannot be anticipated. This means that when an experiment finishes, your system may well be in a very strange state but it does not mean Chaos Toolkit failed at doing its job. In fact, it\u2019s quite the exact nature of the beast: Chaos Engineering is making those pain points very clear to all. Experiments can be interrupted. In that case, Chaos Toolkit tries its best to abide by the runtime condition that you set. For instance, if you decided to always play the rollbacks, Chaos Toolkit will execute them. The default behavior is not to play them however for the simple reason that if you interrupted an experiment, you may well want to investigate the system and if rollbacks were executed, you may lose some important traces or state.","title":"Let's start with the default behavior"},{"location":"reference/tutorials/run-flow/#digging-into-the-interruptions-flow","text":"When the Chaos Toolkit receives a signal, it starts the termination flow of the experiment: When this happens during the first pass of the steady-state hypothesis block, this means the experiment finishes before its method is applied. In that case, rollbacks do not need to be played in any case. When the signal is caught during the method, remaining activities are not executed and the current running experiment is completed. Rollbacks are played if the strategy requested they are played. Otherwise, they are ignored. If an activity is running in the background, the experiment will wait until it finishes. When the signal is caught during the rollbacks, remaining actions are not played and the experiment finishes.","title":"Digging into the interruption's flow"},{"location":"reference/tutorials/run-flow/#reacting-to-signals-aka-being-a-good-citizen","text":"The Chaos Toolkit knows it makes operators confident it will act appropriately upon receiving a variety of signals . It supports therefore the following signals: SIGINT Mostly received when the operator hits Ctrl-C. This triggers the interruption flow. SIGTERM This signal is often used by other processes to indicate the Chaos Toolkit process ought to terminate. For instance, this is the signal sent to Kubernetes pods (with a graceful period before the harsher SIGKILL) SIGUSR1 / SIGUSR2 (Unix only) These two signals are rarely sent by operators but are used so that experiment extension author can programmatically terminate the experiment without having to wait for any blocking operation. In all cases, the termination flow is triggered. The only different one is SIGUSR2 which will always ignore rollbacks and will not wait for background activities to terminate normally. In other words, SIGUSR2 is the only way you can terminate harshly an experiment. Otherwise, there are no visible difference between SIGINT , SIGTERM and SIGUSR1 .","title":"Reacting to signals, aka being a good citizen"},{"location":"reference/tutorials/tolerance/","text":"Learn all about Steady-State Hypothesis Tolerances \u00b6 A Chaos Engineering experiment starts and ends with a steady-state hypothesis. The objective is initially to act as a validation gateway whereby, if the steady-state is not met before we execute the method, then the experiment bails out. What can you learn from an unknown state already? Then, once the method has been applied, the goal is understand if the system coped with the turbulence or if it deviated, implying a weakness may have been uncovered. To achieve this, the Chaos Toolkit experiment expects you use probes to query your system\u2019s state during the steady-state hypothesis. The validation of the probes\u2019 output is performed by what we call tolerances. Let\u2019s get started with a basic example \u00b6 Let\u2019s take the simple experimant below: { \"version\" : \"1.0.0\" , \"title\" : \"Our default language is English\" , \"description\" : \"We find the expected English language in the file\" , \"steady-state-hypothesis\" : { \"title\" : \"Our hypothesis is that lang file is in English\" , \"probes\" : [ { \"type\" : \"probe\" , \"name\" : \"lookup-lang-file\" , \"tolerance\" : true , \"provider\" : { \"type\" : \"python\" , \"module\" : \"os.path\" , \"func\" : \"exists\" , \"arguments\" : { \"path\" : \"default.locale.txt\" } } }, { \"type\" : \"probe\" , \"name\" : \"lookup-text-in-lang-file\" , \"tolerance\" : 0 , \"provider\" : { \"type\" : \"process\" , \"path\" : \"grep\" , \"arguments\" : \"welcome=hello default.locale.txt\" } } ] }, \"method\" : [ { \"type\" : \"action\" , \"name\" : \"switch-language-to-french\" , \"provider\" : { \"type\" : \"process\" , \"path\" : \"sed\" , \"arguments\" : \"-i s/hello/bonjour/ default.locale.txt\" } } ], \"rollbacks\" : [ { \"type\" : \"action\" , \"name\" : \"switch-language-back-to-english\" , \"provider\" : { \"type\" : \"process\" , \"path\" : \"sed\" , \"arguments\" : \"-i s/bonjour/hello/ default.locale.txt\" } } ] } This experiment looks for the welcome message in the default locale file and expected \"hello\" . Here is an example of it running: chaos run experiment.json [2019-06-25 21:37:59 INFO] Validating the experiment's syntax [2019-06-25 21:37:59 INFO] Experiment looks valid [2019-06-25 21:37:59 INFO] Running experiment: Our default language is English [2019-06-25 21:37:59 INFO] Steady state hypothesis: Our hypothesis is that lang file is in English [2019-06-25 21:37:59 INFO] Probe: lookup-lang-file [2019-06-25 21:37:59 INFO] Probe: lookup-text-in-lang-file [2019-06-25 21:37:59 INFO] Steady state hypothesis is met! [2019-06-25 21:37:59 INFO] Action: switch-language-to-french [2019-06-25 21:37:59 INFO] Steady state hypothesis: Our hypothesis is that lang file is in English [2019-06-25 21:37:59 INFO] Probe: lookup-lang-file [2019-06-25 21:37:59 INFO] Probe: lookup-text-in-lang-file [2019-06-25 21:37:59 INFO] Steady state hypothesis is met! [2019-06-25 21:37:59 INFO] Let's rollback... [2019-06-25 21:37:59 INFO] Rollback: switch-language-back-to-english [2019-06-25 21:37:59 INFO] Action: switch-language-back-to-english [2019-06-25 21:37:59 INFO] Experiment ended with status: completed In this experiment, we have two probes checking two basic facets of our system. First, we ensure the locale file exists and then we validate the file contains our expected value. Let\u2019s now analyse the two tolerances we used. First, we use a Python provider which calls the os.path.exists(path) standard library function. This function returns a boolean and that is what the tolerance checks for. The second probe calls a process which sets its exit code to 0 when the command succeeds. Again, this is the value that the tolerance validates. Now that we know the basics, let\u2019s move on to see what are the supported tolerances. Built-in supported tolerances \u00b6 The experiment specification describes the supported tolerances but let\u2019s review them more pragmatically here. Chaos Toolkit aims at being easy for simple tasks whenever it can. In this case, for the general use-cases, we support the following tolerances: boolean : set the tolerance property to true | false integer : set the tolerance property to any integer (negative or positive) string : set the tolerance property to a string list : set the tolerance property to a sequence of values that can be compared to the output by value In these three cases, the probe\u2019s output must equal the given tolerance. On top of this native types, we support also more advance cases such as: range : set the tolerance property to: { \"type\" : \"range\" , \"range\" : [ 6.4 , 7.5 ] } The range is an inclusive min-max range made of numerical values. This is handy when validating a gauge for instance. regex : set the tolerance property to: { \"type\" : \"regex\" , \"target\" : \"stdout\" , \"pattern\" : \"^welcome=hello$\" } pattern must be a valid regular expression, for now supported by the Python engine . This is useful when looking for a value in a raw string. target is optional, and allows changing the default target for a given provider. Currently supported targets per provider are as follows: Provider Default Values process \"status\" \"stdout\" , \"stderr\" http \"status\" \"headers\" , \"body\" python Undefined Undefined jsonpath : set the tolerance property to: { \"type\" : \"jsonpath\" , \"path\" : \"...\" } The path must be a valid JSONPath supported by the jsonpath2 library. This is handy when looking for a value in a mapping output. probe : set the tolerance property to: { \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , ... } } In that case the tolerance is run as yet another probe which must return a boolean. The probe must accept an argument called value that is set to the output of the steady-state probe. In essence, a probe validating the output of another probe. This is advanced stuff only used when the builtin probes won\u2019t cut it. Common scenarios \u00b6 Let\u2019s now review how to apply these tolerances to most common scenarios. Validate the return code of a boolean Python probe \u00b6 In this case, the simple boolean tolerance will do. For instance: { \"type\" : \"probe\" , \"name\" : \"lookup-lang-file\" , \"tolerance\" : true , \"provider\" : { \"type\" : \"python\" , \"module\" : \"os.path\" , \"func\" : \"exists\" , \"arguments\" : { \"path\" : \"default.locale.txt\" } } } Validate the exit code of a process \u00b6 In this case, the simple integer tolerance will do. Indeed, the Chaos Toolkit will look by default to the exit code of the process for validation. In the above example: { \"type\" : \"probe\" , \"name\" : \"lookup-text-in-lang-file\" , \"tolerance\" : 0 , \"provider\" : { \"type\" : \"process\" , \"path\" : \"grep\" , \"arguments\" : \"welcome=hello default.locale.txt\" } } Assuming, we would be expecting an error, which commonly translates to an exit code 1 , we would switch to \"tolerance\": 1 . Validate the status code of a HTTP probe \u00b6 In this case, the simple integer tolerance will do. Indeed, the Chaos Toolkit will look by default to the status code of the HTTP response for validation. For instance: { \"type\" : \"probe\" , \"name\" : \"resource-must-exist\" , \"tolerance\" : 200 , \"provider\" : { \"type\" : \"http\" , \"url\" : \"https://example.com/api/v1/entity\" } } Specific scenarios \u00b6 Validate the stdout/stderr of a process \u00b6 Assuming you want to validate the actual standard output of a process, you need to got a regular expression approach, as follows: { \"type\" : \"probe\" , \"name\" : \"lookup-text-in-lang-file\" , \"tolerance\" : { \"type\" : \"regex\" , \"pattern\" : \"welcome=hello\" , \"target\" : \"stdout\" }, \"provider\" : { \"type\" : \"process\" , \"path\" : \"cat\" , \"arguments\" : \"default.locale.txt\" } } The important extra property to set here is target which tells the Chaos Toolkit where to locate the value to apply the pattern against. The reason we set stdout here is because a process probe returns an object made of three properties: \"status\" , \"stdout\" and \"stderr\" . Validate the JSON body of a HTTP probe \u00b6 In this case, use a jsonpath tolerance. For instance, let\u2019s assume you receive the following JSON payload: { \"foo\" : [{ \"baz\" : \"hello\" }, { \"baz\" : \"bonjour\" }] } { \"type\" : \"probe\" , \"name\" : \"resource-must-exist\" , \"tolerance\" : { \"type\" : \"jsonpath\" , \"path\" : \"$.foo.*[?(@.baz)].baz\" , \"expect\" : [ \"hello\" , \"bonjour\" ], \"target\" : \"body\" }, \"provider\" : { \"type\" : \"http\" , \"url\" : \"https://example.com/api/v1/entities\" } } The expect property tells the Chaos Toolkit what are the values to match against once the JSON Path has been applied against the body of the response of the HTTP probe\u2019s output. You mays also validate against a number of extracted values instead: { \"type\" : \"probe\" , \"name\" : \"resource-must-exist\" , \"tolerance\" : { \"type\" : \"jsonpath\" , \"path\" : \"$.foo.*[?(@.baz)].baz\" , \"count\" : 2 , \"target\" : \"body\" }, \"provider\" : { \"type\" : \"http\" , \"url\" : \"https://example.com/api/v1/entities\" } } Validate the output of a Python probe returning a mapping \u00b6 In this case, use a jsonpath tolerance. For instance, let\u2019s assume you receive the following payload: { \"foo\" : [{ \"baz\" : \"hello\" }, { \"baz\" : \"bonjour\" }] } { \"type\" : \"probe\" , \"name\" : \"resource-must-exist\" , \"tolerance\" : { \"type\" : \"jsonpath\" , \"path\" : \"$.foo.*[?(@.baz)].baz\" , \"expect\" : [ \"hello\" , \"bonjour\" ] }, \"provider\" : { \"type\" : \"python\" , \"module\" : \"...\" , \"func\" : \"...\" } } The expect property tells the Chaos Toolkit what are the values to match against once the JSON Path has been applied against the probe\u2019s output. You mays also validate against a number of extracted values instead: { \"type\" : \"probe\" , \"name\" : \"resource-must-exist\" , \"tolerance\" : { \"type\" : \"jsonpath\" , \"path\" : \"$.foo.*[?(@.baz)].baz\" , \"count\" : 2 }, \"provider\" : { \"type\" : \"python\" , \"module\" : \"...\" , \"func\" : \"...\" } } Advanced Scenarios \u00b6 The last case you may be reviewing now is when the default tolerances cannot support your use case. Then, you want to create your own tolerance by writing a new probe that takes the output, of the tolerance under validation, as an argument. Usually, this tolerance probe is implemented in Python to have more power but this isn\u2019t compulsory. For instance, the following: { \"type\" : \"probe\" , \"name\" : \"lookup-text-in-lang-file\" , \"tolerance\" : 0 , \"provider\" : { \"type\" : \"process\" , \"path\" : \"grep\" , \"arguments\" : \"welcome=hello default.locale.txt\" } } could be written as follows: { \"type\" : \"probe\" , \"name\" : \"lookup-text-in-lang-file\" , \"tolerance\" : { \"name\" : \"search-text\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"my.package\" , \"func\" : \"search_text\" , \"arguments\" : { \"path\" : \"default.local.txt\" , \"search_for\" : \"welcome=hello\" } } }, \"provider\" : { \"type\" : \"process\" , \"path\" : \"cat\" , \"arguments\" : \"default.locale.txt\" } } In that case, implement the search_text(path: str, search_for: str, value: dict) -> bool function in the my.package Python module. import re def search_text ( path : str , search_for : str , value : dict = None ) -> bool : with open ( path ) as f : content = f . read () return re . compile ( search_for ) . match ( value [ \"stdout\" ]) is not None As you can see, the value argument is not declared but must exist in the signature of the function. It is injected by the Chaos Toolkit and is set to the probe\u2019s output.","title":"Learn all about Steady-State Tolerances"},{"location":"reference/tutorials/tolerance/#learn-all-about-steady-state-hypothesis-tolerances","text":"A Chaos Engineering experiment starts and ends with a steady-state hypothesis. The objective is initially to act as a validation gateway whereby, if the steady-state is not met before we execute the method, then the experiment bails out. What can you learn from an unknown state already? Then, once the method has been applied, the goal is understand if the system coped with the turbulence or if it deviated, implying a weakness may have been uncovered. To achieve this, the Chaos Toolkit experiment expects you use probes to query your system\u2019s state during the steady-state hypothesis. The validation of the probes\u2019 output is performed by what we call tolerances.","title":"Learn all about Steady-State Hypothesis Tolerances"},{"location":"reference/tutorials/tolerance/#lets-get-started-with-a-basic-example","text":"Let\u2019s take the simple experimant below: { \"version\" : \"1.0.0\" , \"title\" : \"Our default language is English\" , \"description\" : \"We find the expected English language in the file\" , \"steady-state-hypothesis\" : { \"title\" : \"Our hypothesis is that lang file is in English\" , \"probes\" : [ { \"type\" : \"probe\" , \"name\" : \"lookup-lang-file\" , \"tolerance\" : true , \"provider\" : { \"type\" : \"python\" , \"module\" : \"os.path\" , \"func\" : \"exists\" , \"arguments\" : { \"path\" : \"default.locale.txt\" } } }, { \"type\" : \"probe\" , \"name\" : \"lookup-text-in-lang-file\" , \"tolerance\" : 0 , \"provider\" : { \"type\" : \"process\" , \"path\" : \"grep\" , \"arguments\" : \"welcome=hello default.locale.txt\" } } ] }, \"method\" : [ { \"type\" : \"action\" , \"name\" : \"switch-language-to-french\" , \"provider\" : { \"type\" : \"process\" , \"path\" : \"sed\" , \"arguments\" : \"-i s/hello/bonjour/ default.locale.txt\" } } ], \"rollbacks\" : [ { \"type\" : \"action\" , \"name\" : \"switch-language-back-to-english\" , \"provider\" : { \"type\" : \"process\" , \"path\" : \"sed\" , \"arguments\" : \"-i s/bonjour/hello/ default.locale.txt\" } } ] } This experiment looks for the welcome message in the default locale file and expected \"hello\" . Here is an example of it running: chaos run experiment.json [2019-06-25 21:37:59 INFO] Validating the experiment's syntax [2019-06-25 21:37:59 INFO] Experiment looks valid [2019-06-25 21:37:59 INFO] Running experiment: Our default language is English [2019-06-25 21:37:59 INFO] Steady state hypothesis: Our hypothesis is that lang file is in English [2019-06-25 21:37:59 INFO] Probe: lookup-lang-file [2019-06-25 21:37:59 INFO] Probe: lookup-text-in-lang-file [2019-06-25 21:37:59 INFO] Steady state hypothesis is met! [2019-06-25 21:37:59 INFO] Action: switch-language-to-french [2019-06-25 21:37:59 INFO] Steady state hypothesis: Our hypothesis is that lang file is in English [2019-06-25 21:37:59 INFO] Probe: lookup-lang-file [2019-06-25 21:37:59 INFO] Probe: lookup-text-in-lang-file [2019-06-25 21:37:59 INFO] Steady state hypothesis is met! [2019-06-25 21:37:59 INFO] Let's rollback... [2019-06-25 21:37:59 INFO] Rollback: switch-language-back-to-english [2019-06-25 21:37:59 INFO] Action: switch-language-back-to-english [2019-06-25 21:37:59 INFO] Experiment ended with status: completed In this experiment, we have two probes checking two basic facets of our system. First, we ensure the locale file exists and then we validate the file contains our expected value. Let\u2019s now analyse the two tolerances we used. First, we use a Python provider which calls the os.path.exists(path) standard library function. This function returns a boolean and that is what the tolerance checks for. The second probe calls a process which sets its exit code to 0 when the command succeeds. Again, this is the value that the tolerance validates. Now that we know the basics, let\u2019s move on to see what are the supported tolerances.","title":"Let's get started with a basic example"},{"location":"reference/tutorials/tolerance/#built-in-supported-tolerances","text":"The experiment specification describes the supported tolerances but let\u2019s review them more pragmatically here. Chaos Toolkit aims at being easy for simple tasks whenever it can. In this case, for the general use-cases, we support the following tolerances: boolean : set the tolerance property to true | false integer : set the tolerance property to any integer (negative or positive) string : set the tolerance property to a string list : set the tolerance property to a sequence of values that can be compared to the output by value In these three cases, the probe\u2019s output must equal the given tolerance. On top of this native types, we support also more advance cases such as: range : set the tolerance property to: { \"type\" : \"range\" , \"range\" : [ 6.4 , 7.5 ] } The range is an inclusive min-max range made of numerical values. This is handy when validating a gauge for instance. regex : set the tolerance property to: { \"type\" : \"regex\" , \"target\" : \"stdout\" , \"pattern\" : \"^welcome=hello$\" } pattern must be a valid regular expression, for now supported by the Python engine . This is useful when looking for a value in a raw string. target is optional, and allows changing the default target for a given provider. Currently supported targets per provider are as follows: Provider Default Values process \"status\" \"stdout\" , \"stderr\" http \"status\" \"headers\" , \"body\" python Undefined Undefined jsonpath : set the tolerance property to: { \"type\" : \"jsonpath\" , \"path\" : \"...\" } The path must be a valid JSONPath supported by the jsonpath2 library. This is handy when looking for a value in a mapping output. probe : set the tolerance property to: { \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , ... } } In that case the tolerance is run as yet another probe which must return a boolean. The probe must accept an argument called value that is set to the output of the steady-state probe. In essence, a probe validating the output of another probe. This is advanced stuff only used when the builtin probes won\u2019t cut it.","title":"Built-in supported tolerances"},{"location":"reference/tutorials/tolerance/#common-scenarios","text":"Let\u2019s now review how to apply these tolerances to most common scenarios.","title":"Common scenarios"},{"location":"reference/tutorials/tolerance/#validate-the-return-code-of-a-boolean-python-probe","text":"In this case, the simple boolean tolerance will do. For instance: { \"type\" : \"probe\" , \"name\" : \"lookup-lang-file\" , \"tolerance\" : true , \"provider\" : { \"type\" : \"python\" , \"module\" : \"os.path\" , \"func\" : \"exists\" , \"arguments\" : { \"path\" : \"default.locale.txt\" } } }","title":"Validate the return code of a boolean Python probe"},{"location":"reference/tutorials/tolerance/#validate-the-exit-code-of-a-process","text":"In this case, the simple integer tolerance will do. Indeed, the Chaos Toolkit will look by default to the exit code of the process for validation. In the above example: { \"type\" : \"probe\" , \"name\" : \"lookup-text-in-lang-file\" , \"tolerance\" : 0 , \"provider\" : { \"type\" : \"process\" , \"path\" : \"grep\" , \"arguments\" : \"welcome=hello default.locale.txt\" } } Assuming, we would be expecting an error, which commonly translates to an exit code 1 , we would switch to \"tolerance\": 1 .","title":"Validate the exit code of a process"},{"location":"reference/tutorials/tolerance/#validate-the-status-code-of-a-http-probe","text":"In this case, the simple integer tolerance will do. Indeed, the Chaos Toolkit will look by default to the status code of the HTTP response for validation. For instance: { \"type\" : \"probe\" , \"name\" : \"resource-must-exist\" , \"tolerance\" : 200 , \"provider\" : { \"type\" : \"http\" , \"url\" : \"https://example.com/api/v1/entity\" } }","title":"Validate the status code of a HTTP probe"},{"location":"reference/tutorials/tolerance/#specific-scenarios","text":"","title":"Specific scenarios"},{"location":"reference/tutorials/tolerance/#validate-the-stdoutstderr-of-a-process","text":"Assuming you want to validate the actual standard output of a process, you need to got a regular expression approach, as follows: { \"type\" : \"probe\" , \"name\" : \"lookup-text-in-lang-file\" , \"tolerance\" : { \"type\" : \"regex\" , \"pattern\" : \"welcome=hello\" , \"target\" : \"stdout\" }, \"provider\" : { \"type\" : \"process\" , \"path\" : \"cat\" , \"arguments\" : \"default.locale.txt\" } } The important extra property to set here is target which tells the Chaos Toolkit where to locate the value to apply the pattern against. The reason we set stdout here is because a process probe returns an object made of three properties: \"status\" , \"stdout\" and \"stderr\" .","title":"Validate the stdout/stderr of a process"},{"location":"reference/tutorials/tolerance/#validate-the-json-body-of-a-http-probe","text":"In this case, use a jsonpath tolerance. For instance, let\u2019s assume you receive the following JSON payload: { \"foo\" : [{ \"baz\" : \"hello\" }, { \"baz\" : \"bonjour\" }] } { \"type\" : \"probe\" , \"name\" : \"resource-must-exist\" , \"tolerance\" : { \"type\" : \"jsonpath\" , \"path\" : \"$.foo.*[?(@.baz)].baz\" , \"expect\" : [ \"hello\" , \"bonjour\" ], \"target\" : \"body\" }, \"provider\" : { \"type\" : \"http\" , \"url\" : \"https://example.com/api/v1/entities\" } } The expect property tells the Chaos Toolkit what are the values to match against once the JSON Path has been applied against the body of the response of the HTTP probe\u2019s output. You mays also validate against a number of extracted values instead: { \"type\" : \"probe\" , \"name\" : \"resource-must-exist\" , \"tolerance\" : { \"type\" : \"jsonpath\" , \"path\" : \"$.foo.*[?(@.baz)].baz\" , \"count\" : 2 , \"target\" : \"body\" }, \"provider\" : { \"type\" : \"http\" , \"url\" : \"https://example.com/api/v1/entities\" } }","title":"Validate the JSON body of a HTTP probe"},{"location":"reference/tutorials/tolerance/#validate-the-output-of-a-python-probe-returning-a-mapping","text":"In this case, use a jsonpath tolerance. For instance, let\u2019s assume you receive the following payload: { \"foo\" : [{ \"baz\" : \"hello\" }, { \"baz\" : \"bonjour\" }] } { \"type\" : \"probe\" , \"name\" : \"resource-must-exist\" , \"tolerance\" : { \"type\" : \"jsonpath\" , \"path\" : \"$.foo.*[?(@.baz)].baz\" , \"expect\" : [ \"hello\" , \"bonjour\" ] }, \"provider\" : { \"type\" : \"python\" , \"module\" : \"...\" , \"func\" : \"...\" } } The expect property tells the Chaos Toolkit what are the values to match against once the JSON Path has been applied against the probe\u2019s output. You mays also validate against a number of extracted values instead: { \"type\" : \"probe\" , \"name\" : \"resource-must-exist\" , \"tolerance\" : { \"type\" : \"jsonpath\" , \"path\" : \"$.foo.*[?(@.baz)].baz\" , \"count\" : 2 }, \"provider\" : { \"type\" : \"python\" , \"module\" : \"...\" , \"func\" : \"...\" } }","title":"Validate the output of a Python probe returning a mapping"},{"location":"reference/tutorials/tolerance/#advanced-scenarios","text":"The last case you may be reviewing now is when the default tolerances cannot support your use case. Then, you want to create your own tolerance by writing a new probe that takes the output, of the tolerance under validation, as an argument. Usually, this tolerance probe is implemented in Python to have more power but this isn\u2019t compulsory. For instance, the following: { \"type\" : \"probe\" , \"name\" : \"lookup-text-in-lang-file\" , \"tolerance\" : 0 , \"provider\" : { \"type\" : \"process\" , \"path\" : \"grep\" , \"arguments\" : \"welcome=hello default.locale.txt\" } } could be written as follows: { \"type\" : \"probe\" , \"name\" : \"lookup-text-in-lang-file\" , \"tolerance\" : { \"name\" : \"search-text\" , \"type\" : \"probe\" , \"provider\" : { \"type\" : \"python\" , \"module\" : \"my.package\" , \"func\" : \"search_text\" , \"arguments\" : { \"path\" : \"default.local.txt\" , \"search_for\" : \"welcome=hello\" } } }, \"provider\" : { \"type\" : \"process\" , \"path\" : \"cat\" , \"arguments\" : \"default.locale.txt\" } } In that case, implement the search_text(path: str, search_for: str, value: dict) -> bool function in the my.package Python module. import re def search_text ( path : str , search_for : str , value : dict = None ) -> bool : with open ( path ) as f : content = f . read () return re . compile ( search_for ) . match ( value [ \"stdout\" ]) is not None As you can see, the value argument is not declared but must exist in the signature of the function. It is injected by the Chaos Toolkit and is set to the probe\u2019s output.","title":"Advanced Scenarios"},{"location":"reference/usage/cli/","text":"The heart of the Chaos Toolkit is the chaos command line. Activate the Python virtual environment If you run the Chaos Toolkit directly, rather than using a container, always ensure you have activated the virtual environment so that it can be found along its dependencies: source ~/.venvs/chaostk/bin/activate Once installed , the Chaos Toolkit CLI will display the commands it supports by executing: chaos --help Usage: chaos [OPTIONS] COMMAND [ARGS]... Options: --version Show the version and exit. --verbose Display debug level traces. --no-version-check Do not search for an updated version of the chaostoolkit. --change-dir TEXT Change directory before running experiment. --no-log-file Disable logging to file entirely. --log-file TEXT File path where to write the command's log. [default: chaostoolkit.log] --log-format [string|json] Console logging format: string, json. --settings TEXT Path to the settings file. [default: /Users/ciaran/.chaostoolkit/settings.yaml] --help Show this message and exit. Commands: discover Discover capabilities and experiments. info Display information about the Chaos Toolkit environment. init Initialize a new experiment from discovered capabilities. run Run the experiment loaded from SOURCE, either a local file or... settings Read, write or remove from your settings file. validate Validate the experiment at SOURCE. Configure the Chaos Toolkit \u00b6 For the most part, the Chaos Toolkit does not need to be configured. However, if it does, the settings are stored in a YAML file on your local machine. Tip Unless you enable one of the features requiring extra configuration, you don\u2019t need to create that file. If a feature requires extra configuration, its documentation will say so. Create the settings file \u00b6 The settings file for the Chaos Toolkit should be located under the following path: $HOME/.chaostoolkit/settings.yaml As this file may hold sensitive data, it is advised to make it readable only for your own user: chmod 600 $HOME/.chaostoolkit/settings.yaml How to Investigate Issues \u00b6 When your experiment fails to work as you would expect, you should start looking at the chaostoolkit.log file written to by the chaos command. This file contains a lot of traces from the Chaos Toolkit core but also any extensions that used the toolkit\u2019s logger. As new logs are appended to that file, it may grow big. Do not hesitate to wipe it out from time to time. Please, do make sure to visit our Slack or GitHub when you have a question around how the toolkit does things. The community will be pleased to help you out.","title":"Overview"},{"location":"reference/usage/cli/#configure-the-chaos-toolkit","text":"For the most part, the Chaos Toolkit does not need to be configured. However, if it does, the settings are stored in a YAML file on your local machine. Tip Unless you enable one of the features requiring extra configuration, you don\u2019t need to create that file. If a feature requires extra configuration, its documentation will say so.","title":"Configure the Chaos Toolkit"},{"location":"reference/usage/cli/#create-the-settings-file","text":"The settings file for the Chaos Toolkit should be located under the following path: $HOME/.chaostoolkit/settings.yaml As this file may hold sensitive data, it is advised to make it readable only for your own user: chmod 600 $HOME/.chaostoolkit/settings.yaml","title":"Create the settings file"},{"location":"reference/usage/cli/#how-to-investigate-issues","text":"When your experiment fails to work as you would expect, you should start looking at the chaostoolkit.log file written to by the chaos command. This file contains a lot of traces from the Chaos Toolkit core but also any extensions that used the toolkit\u2019s logger. As new logs are appended to that file, it may grow big. Do not hesitate to wipe it out from time to time. Please, do make sure to visit our Slack or GitHub when you have a question around how the toolkit does things. The community will be pleased to help you out.","title":"How to Investigate Issues"},{"location":"reference/usage/discover/","text":"The chaos discover command \u00b6 You use the chaos discover command to specify a Chaos Toolkit integration extension and, if supported by the integration, to then explore your target environment in order to build a discovery report that can be used by the chaos init command to help you bootstrap your own chaos engineering experiments. You can see the options available to you by executing: chaos discover --help Usage: chaos discover [OPTIONS] PACKAGE Discover capabilities and experiments. Options: --no-system-info Do not discover system information. --no-install Assume package already in PYTHONPATH. --discovery-path TEXT Path where to save the the discovery outcome. [default: ./discovery.json] --help Show this message and exit. A tutorial on how to use the chaos discover command is available as part of the Chaos Toolkit\u2019s Getting Started tutorials. Discovering capabilities and experiments \u00b6 To execute discover all you need to do is specify the Chaos Toolkit integration extension that you\u2019d like to use, for example to use Kubernetes: chaos discover chaostoolkit-kubernetes [2021-07-30 11:43:38 INFO] Attempting to download and install package 'chaostoolkit-kubernetes' [2021-07-30 11:43:45 INFO] Package downloaded and installed in current environment [2021-07-30 11:43:45 INFO] Discovering capabilities from chaostoolkit-kubernetes [2021-07-30 11:43:45 INFO] Searching for actions in chaosk8s.actions [2021-07-30 11:43:45 INFO] Searching for probes in chaosk8s.probes [2021-07-30 11:43:45 INFO] Searching for actions in chaosk8s.deployment.actions [2021-07-30 11:43:45 INFO] Searching for actions in chaosk8s.deployment.probes [2021-07-30 11:43:45 INFO] Searching for actions in chaosk8s.node.actions [2021-07-30 11:43:45 INFO] Searching for actions in chaosk8s.node.probes [2021-07-30 11:43:45 INFO] Searching for actions in chaosk8s.pod.actions [2021-07-30 11:43:45 INFO] Searching for probes in chaosk8s.pod.probes [2021-07-30 11:43:45 INFO] Searching for actions in chaosk8s.replicaset.actions [2021-07-30 11:43:45 INFO] Searching for actions in chaosk8s.service.actions [2021-07-30 11:43:45 INFO] Searching for actions in chaosk8s.service.probes [2021-07-30 11:43:45 INFO] Searching for actions in chaosk8s.statefulset.actions [2021-07-30 11:43:45 INFO] Searching for probes in chaosk8s.statefulset.probes [2021-07-30 11:43:45 INFO] Searching for actions in chaosk8s.crd.actions [2021-07-30 11:43:45 INFO] Searching for probes in chaosk8s.crd.probes [2021-07-30 11:43:45 INFO] Discovery outcome saved in ./discovery.json The chaos discover command will produce a report saved in ./discovery.json by default, although you can specify where this report is produced by supplying the --discovery-report-path option. Discovery without System Information \u00b6 To not probe the target system during the discovery process you can supply the --no-system-info option. Discovery without Installation of an Integration Extension \u00b6 If you already have the integration extension installed and available you can speed up the discovery process by specifying the --no-install option.","title":"Discover"},{"location":"reference/usage/discover/#the-chaos-discover-command","text":"You use the chaos discover command to specify a Chaos Toolkit integration extension and, if supported by the integration, to then explore your target environment in order to build a discovery report that can be used by the chaos init command to help you bootstrap your own chaos engineering experiments. You can see the options available to you by executing: chaos discover --help Usage: chaos discover [OPTIONS] PACKAGE Discover capabilities and experiments. Options: --no-system-info Do not discover system information. --no-install Assume package already in PYTHONPATH. --discovery-path TEXT Path where to save the the discovery outcome. [default: ./discovery.json] --help Show this message and exit. A tutorial on how to use the chaos discover command is available as part of the Chaos Toolkit\u2019s Getting Started tutorials.","title":"The chaos discover command"},{"location":"reference/usage/discover/#discovering-capabilities-and-experiments","text":"To execute discover all you need to do is specify the Chaos Toolkit integration extension that you\u2019d like to use, for example to use Kubernetes: chaos discover chaostoolkit-kubernetes [2021-07-30 11:43:38 INFO] Attempting to download and install package 'chaostoolkit-kubernetes' [2021-07-30 11:43:45 INFO] Package downloaded and installed in current environment [2021-07-30 11:43:45 INFO] Discovering capabilities from chaostoolkit-kubernetes [2021-07-30 11:43:45 INFO] Searching for actions in chaosk8s.actions [2021-07-30 11:43:45 INFO] Searching for probes in chaosk8s.probes [2021-07-30 11:43:45 INFO] Searching for actions in chaosk8s.deployment.actions [2021-07-30 11:43:45 INFO] Searching for actions in chaosk8s.deployment.probes [2021-07-30 11:43:45 INFO] Searching for actions in chaosk8s.node.actions [2021-07-30 11:43:45 INFO] Searching for actions in chaosk8s.node.probes [2021-07-30 11:43:45 INFO] Searching for actions in chaosk8s.pod.actions [2021-07-30 11:43:45 INFO] Searching for probes in chaosk8s.pod.probes [2021-07-30 11:43:45 INFO] Searching for actions in chaosk8s.replicaset.actions [2021-07-30 11:43:45 INFO] Searching for actions in chaosk8s.service.actions [2021-07-30 11:43:45 INFO] Searching for actions in chaosk8s.service.probes [2021-07-30 11:43:45 INFO] Searching for actions in chaosk8s.statefulset.actions [2021-07-30 11:43:45 INFO] Searching for probes in chaosk8s.statefulset.probes [2021-07-30 11:43:45 INFO] Searching for actions in chaosk8s.crd.actions [2021-07-30 11:43:45 INFO] Searching for probes in chaosk8s.crd.probes [2021-07-30 11:43:45 INFO] Discovery outcome saved in ./discovery.json The chaos discover command will produce a report saved in ./discovery.json by default, although you can specify where this report is produced by supplying the --discovery-report-path option.","title":"Discovering capabilities and experiments"},{"location":"reference/usage/discover/#discovery-without-system-information","text":"To not probe the target system during the discovery process you can supply the --no-system-info option.","title":"Discovery without System Information"},{"location":"reference/usage/discover/#discovery-without-installation-of-an-integration-extension","text":"If you already have the integration extension installed and available you can speed up the discovery process by specifying the --no-install option.","title":"Discovery without Installation of an Integration Extension"},{"location":"reference/usage/init/","text":"The chaos init command \u00b6 You use the chaos init command to take a discovery report , usually created by the chaos discover command, to then create an experiment based upon what has been discovered about the integration extension and, if applicable, the target environment. You can see the options available to you by executing: chaos init --help Usage: chaos init [OPTIONS] Initialize a new experiment from discovered capabilities. Options: --discovery-path PATH Path to the discovery outcome. [default: ./discovery.json] --experiment-path PATH Path where to save the experiment (.yaml or .json) [default: ./experiment.json] --help Show this message and exit. A tutorial on how to use the chaos init command is available as part of the Chaos Toolkit\u2019s Getting Started tutorials. Initialise a new experiment \u00b6 To initialise a new experiment based on what has been discovered you simply need to execute the chaos init command: chaos init The following is a capture of the output after running chaos init and following the interactive prompts: [2018-01-30 15:54:50 INFO] Let's build a new experiment Experiment's title: My new experiment Add an activity to your method Activity (0 to escape): 1 Kill a microservice by `name` in the namespace `ns`. The microservice is killed by deleting the deployment for it without a graceful period to trigger an abrupt termination. The selected resources are matched by the given `label_selector`. Do you want to use this action? [y/N]: y Argument's value for 'name': Argument's value for 'ns' [default]: Argument's value for 'label_selector' [name in ({name})]: app=webapp-app Do you want to select another activity? [y/N]: N [2018-01-30 15:55:21 INFO] Experiment created and saved in './experiment.json' By default, the chaos init command will look for a ./discovery.json file and use that as the basis of a new experiment\u2019s initialisation. You can specify another file to be used by suppling the --discovery-report-path option. In addition the default output from the init command will be a new Chaos Toolkit experiment definition in a ./experiment.json file. If you would prefer a different filename then this can be specified using the --experiment-path option.","title":"Init"},{"location":"reference/usage/init/#the-chaos-init-command","text":"You use the chaos init command to take a discovery report , usually created by the chaos discover command, to then create an experiment based upon what has been discovered about the integration extension and, if applicable, the target environment. You can see the options available to you by executing: chaos init --help Usage: chaos init [OPTIONS] Initialize a new experiment from discovered capabilities. Options: --discovery-path PATH Path to the discovery outcome. [default: ./discovery.json] --experiment-path PATH Path where to save the experiment (.yaml or .json) [default: ./experiment.json] --help Show this message and exit. A tutorial on how to use the chaos init command is available as part of the Chaos Toolkit\u2019s Getting Started tutorials.","title":"The chaos init command"},{"location":"reference/usage/init/#initialise-a-new-experiment","text":"To initialise a new experiment based on what has been discovered you simply need to execute the chaos init command: chaos init The following is a capture of the output after running chaos init and following the interactive prompts: [2018-01-30 15:54:50 INFO] Let's build a new experiment Experiment's title: My new experiment Add an activity to your method Activity (0 to escape): 1 Kill a microservice by `name` in the namespace `ns`. The microservice is killed by deleting the deployment for it without a graceful period to trigger an abrupt termination. The selected resources are matched by the given `label_selector`. Do you want to use this action? [y/N]: y Argument's value for 'name': Argument's value for 'ns' [default]: Argument's value for 'label_selector' [name in ({name})]: app=webapp-app Do you want to select another activity? [y/N]: N [2018-01-30 15:55:21 INFO] Experiment created and saved in './experiment.json' By default, the chaos init command will look for a ./discovery.json file and use that as the basis of a new experiment\u2019s initialisation. You can specify another file to be used by suppling the --discovery-report-path option. In addition the default output from the init command will be a new Chaos Toolkit experiment definition in a ./experiment.json file. If you would prefer a different filename then this can be specified using the --experiment-path option.","title":"Initialise a new experiment"},{"location":"reference/usage/install/","text":"How to Install the Chaos Toolkit \u00b6 Python Requirements \u00b6 The chaostoolkit CLI is implemented in Python 3 and this requires a working Python installation to run. It officially supports Python 3.6+. It has only been tested against CPython . Install Python \u00b6 Install Python for your system: On MacOS X: brew install python3 On Debian/Ubuntu: sudo apt-get install python3 python3-venv On Windows: Download the latest binary installer from the Python website. Create a virtual environment \u00b6 Dependencies can be installed for your system via its package management but, more likely, you will want to install them yourself in a local virtual environment. python3 -m venv ~/.venvs/chaostk Make sure to always activate your virtual environment before using it: source ~/.venvs/chaostk/bin/activate Tip You may want to use virtualenvwrapper to make this process much nicer. Install the CLI \u00b6 Install chaostoolkit in the virtual environment as follows: pip install -U chaostoolkit You can verify the command was installed by running: chaos --version Install Extensions \u00b6 At this stage, you have installed the chaos command line and its core library. To fully enjoy the Chaos Toolkit, you will also want to install extensions for the various facets of your journey into Chaos Engineering.","title":"Install"},{"location":"reference/usage/install/#how-to-install-the-chaos-toolkit","text":"","title":"How to Install the Chaos Toolkit"},{"location":"reference/usage/install/#python-requirements","text":"The chaostoolkit CLI is implemented in Python 3 and this requires a working Python installation to run. It officially supports Python 3.6+. It has only been tested against CPython .","title":"Python Requirements"},{"location":"reference/usage/install/#install-python","text":"Install Python for your system: On MacOS X: brew install python3 On Debian/Ubuntu: sudo apt-get install python3 python3-venv On Windows: Download the latest binary installer from the Python website.","title":"Install Python"},{"location":"reference/usage/install/#create-a-virtual-environment","text":"Dependencies can be installed for your system via its package management but, more likely, you will want to install them yourself in a local virtual environment. python3 -m venv ~/.venvs/chaostk Make sure to always activate your virtual environment before using it: source ~/.venvs/chaostk/bin/activate Tip You may want to use virtualenvwrapper to make this process much nicer.","title":"Create a virtual environment"},{"location":"reference/usage/install/#install-the-cli","text":"Install chaostoolkit in the virtual environment as follows: pip install -U chaostoolkit You can verify the command was installed by running: chaos --version","title":"Install the CLI"},{"location":"reference/usage/install/#install-extensions","text":"At this stage, you have installed the chaos command line and its core library. To fully enjoy the Chaos Toolkit, you will also want to install extensions for the various facets of your journey into Chaos Engineering.","title":"Install Extensions"},{"location":"reference/usage/notification/","text":"Get Notifications From The Chaos Toolkit Flow \u00b6 The Chaos Toolkit generates events when it is executed. You may benefit from those events to get notified via your chosen notification channels. Chaos Toolkit Flow Events \u00b6 The Chaos Toolkit defines the following events: Discovery flow \"discover-started\" : when the discovery flow has begun Payload: the name of the Chaos Toolkit extension used to discover the system \"discover-completed\" : when the discovery flow has completed Payload: the result of the discovery \"discover-failed\" : when the discovery flow has failed Payload: the name of the Chaos Toolkit extension usd to discover the system Additional Payload: The error Init flow \"init-started\" : when the init flow has begun Payload: None \"init-completed\" : when the init flow has completed Payload: the generated experiment Run flow \"run-started\" : when the run flow has begun Payload: The experiment that gets executed \"run-completed\" : when the run flow has completed Payload: The journal of the experiment\u2019s execution \"run-failed\" : when the run flow has failed Payload: The journal of the experiment\u2019s execution Validate flow \"validate-started\" : when the validate flow has begun Payload: The experiment to validate \"validate-completed\" : when the validate flow has completed Payload: The experiment to validate \"validate-failed\" : when the validate flow has failed Payload: The experiment to validate Additional Payload: The error Notification Event Structure \u00b6 The events structure is as follows: { \"name\" : \"run-started|...\" , \"payload\" : \"the payload for the given event\" , \"phase\" : \"run|discovery|init|validate\" , \"error\" : \"only set when an error was triggered. Set to the actual raw error\" , \"ts\" : \"<now>\" } Note, the error is not a failure of the experiment\u2019s steady-state but an error during the processing of the flow (for instance, the experiment\u2019s file has a mistake somewhere in its syntax, or an exception is raised somehow). Declare Notification Channels \u00b6 Notification channels are declared in the Chaos Toolkit settings file under the notifications: section. Here is an example: notifications : - type : http url : https://mystuff.com/api verify_tls : false headers : Authorization : \"Bearer 1234\" - type : plugin module : chaosslack.notification token : xop-1235 channel : general As you can see, channels are items in a list. Each channel is a mapping describing the kind of channel and its required information. For instance, here we have two channels. The first one is a call to the HTTPS endpoint while the other one uses the Chaos Toolkit Extension for Slack to send messages to Slack channels. Warning Notification channels are run sequential to the whole chaos flow, so the more you declare, the bigger the impact they could have on the readability of the experiment results. Filter Events \u00b6 By default, all events are sent to the channels. However, you may decide, on a per channel basis, which events you want to be sent. This is done by adding the events field to a channel: notifications : - type : plugin module : chaosslack.notification token : xop-1235 channel : general events : - run-failed The Slack channel will only receive events when a run experiment fails. This is a list so declare as many events as you need. HTTP Notification Channel \u00b6 A HTTP notification channel tells the Chaos Toolkit it must send the event over HTTP (or HTTPS) to the given endpoint. Here is the description of its fields: type : \"http\" (required) url : the endpoint address (required) verify_tls : true|false depending if the endpoint certificates are self-signed headers : a mapping where the keys are header names and their associated values forward_event_payload : true|false . If true , the default, then the event payload is sent to that endpoint in a POST request. Otherwise, a GET request is performed with no body Plugin Notification Channel \u00b6 A plugin notification channel is an integration between an external system and the Chaos Toolkit event notification flow. It is more capable than basic HTTP channels as they are fully fledged Python functions. Warning A plugin channel could also be understood as a hook point into the Chaos Toolkit flow. Nothing prevents you from writing a plugin that performs operations based on those hook events. Please note however that they run sequentially to the whole flow, so the longer your operation takes, the longer it takes for your chaos experiment to carry on. This may invalidate certain experiments when timing is critical. Here are the fields to declare one: type : \"plugin\" (required) module : the dotted path to the Python module containing the function to apply (required) func : the name of the function to apply (in that module), defaults to \"notify\" Any other fields will be passed on as-is to the function for its internal usage. For instance: notifications : - type : plugin module : chaosslack.notification token : xop-1235 channel : general The token and channel fields will be provided directly to the notify function of the chaosslack.notification module. Send Notifications To Slack \u00b6 Notifying about Chaos Experiment runs in a Slack channel is so common that we will describe this integration here. First, you must install the Chaos Toolkit Integration for Slack : pip install -U chaostoolkit-slack Then, you should declare your notification channels as follows in the Chaos Toolkit settings file: notifications : - type : plugin module : chaosslack.notification token : xop-1235 channel : general You may define as many channels as you need, for instance for different kind of events. The token and channel fields are mandatory in this case. The token field must be set to a valid Slack token. You may start with a legacy token before moving on to a Slack App as per Slack guidelines . The Chaos Toolkit itself does not provide a Slack App at this moment. The channel must be a name of an existing channel. The payload message sent to Slack is defined in the plugin . If you need to amend it, please open an issue there. Debugging Notifications \u00b6 The Chaos Toolkit does its best to not break the experiment when an event could not be pushed. If you do not see the notification you were expecting, you should start investigating in the chaostoolkit.log file. If Chaos Toolkit could handle the issue gracefully, it will log the error at the DEBUG level. If the error occurs inside the core Chaos Toolkit library, please raise an issue there . Otherwise, raise an issue with the appropriate plugin.","title":"Notifications"},{"location":"reference/usage/notification/#get-notifications-from-the-chaos-toolkit-flow","text":"The Chaos Toolkit generates events when it is executed. You may benefit from those events to get notified via your chosen notification channels.","title":"Get Notifications From The Chaos Toolkit Flow"},{"location":"reference/usage/notification/#chaos-toolkit-flow-events","text":"The Chaos Toolkit defines the following events: Discovery flow \"discover-started\" : when the discovery flow has begun Payload: the name of the Chaos Toolkit extension used to discover the system \"discover-completed\" : when the discovery flow has completed Payload: the result of the discovery \"discover-failed\" : when the discovery flow has failed Payload: the name of the Chaos Toolkit extension usd to discover the system Additional Payload: The error Init flow \"init-started\" : when the init flow has begun Payload: None \"init-completed\" : when the init flow has completed Payload: the generated experiment Run flow \"run-started\" : when the run flow has begun Payload: The experiment that gets executed \"run-completed\" : when the run flow has completed Payload: The journal of the experiment\u2019s execution \"run-failed\" : when the run flow has failed Payload: The journal of the experiment\u2019s execution Validate flow \"validate-started\" : when the validate flow has begun Payload: The experiment to validate \"validate-completed\" : when the validate flow has completed Payload: The experiment to validate \"validate-failed\" : when the validate flow has failed Payload: The experiment to validate Additional Payload: The error","title":"Chaos Toolkit Flow Events"},{"location":"reference/usage/notification/#notification-event-structure","text":"The events structure is as follows: { \"name\" : \"run-started|...\" , \"payload\" : \"the payload for the given event\" , \"phase\" : \"run|discovery|init|validate\" , \"error\" : \"only set when an error was triggered. Set to the actual raw error\" , \"ts\" : \"<now>\" } Note, the error is not a failure of the experiment\u2019s steady-state but an error during the processing of the flow (for instance, the experiment\u2019s file has a mistake somewhere in its syntax, or an exception is raised somehow).","title":"Notification Event Structure"},{"location":"reference/usage/notification/#declare-notification-channels","text":"Notification channels are declared in the Chaos Toolkit settings file under the notifications: section. Here is an example: notifications : - type : http url : https://mystuff.com/api verify_tls : false headers : Authorization : \"Bearer 1234\" - type : plugin module : chaosslack.notification token : xop-1235 channel : general As you can see, channels are items in a list. Each channel is a mapping describing the kind of channel and its required information. For instance, here we have two channels. The first one is a call to the HTTPS endpoint while the other one uses the Chaos Toolkit Extension for Slack to send messages to Slack channels. Warning Notification channels are run sequential to the whole chaos flow, so the more you declare, the bigger the impact they could have on the readability of the experiment results.","title":"Declare Notification Channels"},{"location":"reference/usage/notification/#filter-events","text":"By default, all events are sent to the channels. However, you may decide, on a per channel basis, which events you want to be sent. This is done by adding the events field to a channel: notifications : - type : plugin module : chaosslack.notification token : xop-1235 channel : general events : - run-failed The Slack channel will only receive events when a run experiment fails. This is a list so declare as many events as you need.","title":"Filter Events"},{"location":"reference/usage/notification/#http-notification-channel","text":"A HTTP notification channel tells the Chaos Toolkit it must send the event over HTTP (or HTTPS) to the given endpoint. Here is the description of its fields: type : \"http\" (required) url : the endpoint address (required) verify_tls : true|false depending if the endpoint certificates are self-signed headers : a mapping where the keys are header names and their associated values forward_event_payload : true|false . If true , the default, then the event payload is sent to that endpoint in a POST request. Otherwise, a GET request is performed with no body","title":"HTTP Notification Channel"},{"location":"reference/usage/notification/#plugin-notification-channel","text":"A plugin notification channel is an integration between an external system and the Chaos Toolkit event notification flow. It is more capable than basic HTTP channels as they are fully fledged Python functions. Warning A plugin channel could also be understood as a hook point into the Chaos Toolkit flow. Nothing prevents you from writing a plugin that performs operations based on those hook events. Please note however that they run sequentially to the whole flow, so the longer your operation takes, the longer it takes for your chaos experiment to carry on. This may invalidate certain experiments when timing is critical. Here are the fields to declare one: type : \"plugin\" (required) module : the dotted path to the Python module containing the function to apply (required) func : the name of the function to apply (in that module), defaults to \"notify\" Any other fields will be passed on as-is to the function for its internal usage. For instance: notifications : - type : plugin module : chaosslack.notification token : xop-1235 channel : general The token and channel fields will be provided directly to the notify function of the chaosslack.notification module.","title":"Plugin Notification Channel"},{"location":"reference/usage/notification/#send-notifications-to-slack","text":"Notifying about Chaos Experiment runs in a Slack channel is so common that we will describe this integration here. First, you must install the Chaos Toolkit Integration for Slack : pip install -U chaostoolkit-slack Then, you should declare your notification channels as follows in the Chaos Toolkit settings file: notifications : - type : plugin module : chaosslack.notification token : xop-1235 channel : general You may define as many channels as you need, for instance for different kind of events. The token and channel fields are mandatory in this case. The token field must be set to a valid Slack token. You may start with a legacy token before moving on to a Slack App as per Slack guidelines . The Chaos Toolkit itself does not provide a Slack App at this moment. The channel must be a name of an existing channel. The payload message sent to Slack is defined in the plugin . If you need to amend it, please open an issue there.","title":"Send Notifications To Slack"},{"location":"reference/usage/notification/#debugging-notifications","text":"The Chaos Toolkit does its best to not break the experiment when an event could not be pushed. If you do not see the notification you were expecting, you should start investigating in the chaostoolkit.log file. If Chaos Toolkit could handle the issue gracefully, it will log the error at the DEBUG level. If the error occurs inside the core Chaos Toolkit library, please raise an issue there . Otherwise, raise an issue with the appropriate plugin.","title":"Debugging Notifications"},{"location":"reference/usage/report/","text":"The chaos report command \u00b6 You use the chaos report command to take the journal produced by the chaos run command and produce a report in a specified format. Due to the many operating system-dependent features that the chaos report command relies upon, the chaos report command is not installed with the Chaos Toolkit CLI. To install the chaos report command you need to install the chaostoolkit-reporting plugin and the dependencies appropriate to your own operating system . Once the plugin is installed you can see the options available to you by executing: chaos report --help Usage: chaos report [OPTIONS] [JOURNAL]... REPORT Generate a report from the run journal(s). Options: --export-format TEXT Format to export the report to: html, markdown, pdf. --help Show this message and exit. A tutorial on how to use the chaos report command is available as part of the Chaos Toolkit\u2019s Getting Started tutorials. Generating a report \u00b6 When an experiment completes after using the chaos run command a journal is generated and stored in the chaos-report.json file. A PDF or HTML report may be generated from this journal using the chaostoolkit-reporting library. The chaos report command expects the path to the chaos-report.json file and a path to the actual report file that you require. You can export various formats of report by specifying what you want using the --export-format option. For example, to generate a PDF report you can run the following command: chaos report --export-format=pdf chaos-report.json report.pdf An HTML report can be produced using: chaos report --export-format=html5 chaos-report.json report.html","title":"Report"},{"location":"reference/usage/report/#the-chaos-report-command","text":"You use the chaos report command to take the journal produced by the chaos run command and produce a report in a specified format. Due to the many operating system-dependent features that the chaos report command relies upon, the chaos report command is not installed with the Chaos Toolkit CLI. To install the chaos report command you need to install the chaostoolkit-reporting plugin and the dependencies appropriate to your own operating system . Once the plugin is installed you can see the options available to you by executing: chaos report --help Usage: chaos report [OPTIONS] [JOURNAL]... REPORT Generate a report from the run journal(s). Options: --export-format TEXT Format to export the report to: html, markdown, pdf. --help Show this message and exit. A tutorial on how to use the chaos report command is available as part of the Chaos Toolkit\u2019s Getting Started tutorials.","title":"The chaos report command"},{"location":"reference/usage/report/#generating-a-report","text":"When an experiment completes after using the chaos run command a journal is generated and stored in the chaos-report.json file. A PDF or HTML report may be generated from this journal using the chaostoolkit-reporting library. The chaos report command expects the path to the chaos-report.json file and a path to the actual report file that you require. You can export various formats of report by specifying what you want using the --export-format option. For example, to generate a PDF report you can run the following command: chaos report --export-format=pdf chaos-report.json report.pdf An HTML report can be produced using: chaos report --export-format=html5 chaos-report.json report.html","title":"Generating a report"},{"location":"reference/usage/run/","text":"The chaos run command \u00b6 You use the chaos run command to execute your declarative chaos engineering experiments. To see the options that can be passed to the chaos run command, execute: chaos run --help Usage: chaos run [OPTIONS] SOURCE Run the experiment loaded from SOURCE, either a local file or a HTTP resource. SOURCE can be formatted as JSON or YAML. Options: --journal-path TEXT Path where to save the journal from the execution. --dry Run the experiment without executing activities. --no-validation Do not validate the experiment before running. --no-verify-tls Do not verify TLS certificate. --rollback-strategy [default|always|never|deviated] Rollback runtime strategy. Default is to never play them on interruption or failed hypothesis. --var TEXT Specify substitution values for configuration only. Can be provided multiple times. The pattern must be key=value or key:type=value. In that latter case, the value will be casted as the specified type. Supported types are: int, float, bytes. No type specified means a utf-8 decoded string. --var-file PATH Specify files that contain configuration and secret substitution values. Either as a json/yaml payload where each key has a value mapping to a configuration entry. Or a .env file defining environment variables. Can be provided multiple times. --hypothesis-strategy [default|before-method-only|after-method-only|during-method-only|continously] Strategy to execute the hypothesis during the run. --hypothesis-frequency FLOAT Pace at which running the hypothesis. Only applies when strategy is either: during- method-only or continously --fail-fast When running in the during-method-onlyt or continous strategies, indicate the hypothesis can fail the experiment as soon as it deviates once. Otherwise, keeps running until the end of the experiment. --help Show this message and exit. A tutorial on how to use the chaos run command is available as part of the Chaos Toolkit\u2019s Getting Started tutorials. Executing an Experiment Plan \u00b6 To execute an experiment plan you simply pass it to the chaos run command: chaos run experiment.json [2018-01-30 16:35:04 INFO] Validating experiment's syntax [2018-01-30 16:35:04 INFO] Experiment looks valid [2018-01-30 16:35:04 INFO] Running experiment: My new experiment [2018-01-30 16:35:04 INFO] No steady state hypothesis defined. That's ok, just exploring. [2018-01-30 16:35:04 INFO] Action: kill_microservice [2018-01-30 16:35:04 INFO] No steady state hypothesis defined. That's ok, just exploring. [2018-01-30 16:35:04 INFO] Let's rollback... [2018-01-30 16:35:04 INFO] No declared rollbacks, let's move on. [2018-01-30 16:35:04 INFO] Experiment ended with status: completed Chaos Toolkit will log all the steps it follows from your plan in a journal which by default is called journal.json . You can specify the name of this journal output file using the --journal-path option. Rehearsing an experiment execution \u00b6 To test that you have a valid experiment you can pass the --dry option. Run an experiment without validation \u00b6 You can run an experiment and skip the experiment\u2019s validation using the --no-validation option. Run an experiment with different steady state strategies \u00b6 By default, the steady state will be tested before and after an experiment runs. However, you can specify a different strategy through the --hypothesis-strategy parameter. The options are: default before-method-only after-method-only during-method-only continuously For example: chaos run ./experiment.json --hypothesis-strategy continuously Run an experiment with different rollback strategies \u00b6 In Chaos Toolkit, rollbacks are always played unless one of the two followings is true: the steady-state hypothesis deviates before the method a control interrupted the execution the chaos command receives a SIGINT or SIGTERM signal The Chaos Toolkit provides a mechanism (since v1.5.0) that gives the operator a chance to change that behavior. Always run rollbacks \u00b6 Ensure rollbacks are always applied chaos run --rollback-strategy=always experiment.json Run rollbacks only on deviation \u00b6 Run the rollbacks only if your experiment deviated. chaos run --rollback-strategy=deviated experiment.json Never run rollbacks strategy \u00b6 Never run any rollbacks, for instance when you want to explore the system after a successful experiment without undoing what the experiment changed: chaos run --rollback-strategy=never experiment.json Override configuration and secrets at runtime \u00b6 While configuration and secrets are declared in the experiment itself, you may sometimes need to override the values at runtime. This can be achieved through the --var KEY[:TYPE]=VALUE or --var-file filepath.json|yaml|.env flags. The --var KEY[:TYPE]=VALUE can only override configuration values to prevent laking secrets on the command line. The KEY is the final key used in the experiment, for instance: { \"configuration\" : { \"message\" : \"hello world\" } } or { \"configuration\" : { \"message\" : { \"type\" : \"env\" , \"key\" : \"MY_MESSAGE\" } } } In both cases, the override key is message . If you specify the TYPE it must be one of str, int, float, bytes with str the default so not required. Chaos Toolkit will try to convert the given VALUE to the specified type and fail if it cannot. The --var-file filepath.json|yaml|.env gives you the opportunity to override the configuration and secrets blocks. the format of the json and yaml files are as follows: { \"configuration\" : { \"KEY\" : VALUE }, \"secrets\" : { \"scope\" : { \"KEY\" : VALUE } } } --- configuration : KEY : VALUE secrets : scope : KEY : VALUE The secrets block follows the same format as the experiment so the scope is the scope given in the experiment. For example: { \"configuration\" : { \"service_name\" : \"ec2\" }, \"secrets\" : { \"aws\" : { \"api_token\" : \"1234\" , \"something\" : \"whatever\" } } } would turn as the following var file: { \"secrets\" : { \"aws\" : { \"api_token\" : \"56787\" } } } We are not overridding the configuration section and only part of the secrets section. Finally, should you keep your variables in a .env file, it will only be able to override the configuration.","title":"Run"},{"location":"reference/usage/run/#the-chaos-run-command","text":"You use the chaos run command to execute your declarative chaos engineering experiments. To see the options that can be passed to the chaos run command, execute: chaos run --help Usage: chaos run [OPTIONS] SOURCE Run the experiment loaded from SOURCE, either a local file or a HTTP resource. SOURCE can be formatted as JSON or YAML. Options: --journal-path TEXT Path where to save the journal from the execution. --dry Run the experiment without executing activities. --no-validation Do not validate the experiment before running. --no-verify-tls Do not verify TLS certificate. --rollback-strategy [default|always|never|deviated] Rollback runtime strategy. Default is to never play them on interruption or failed hypothesis. --var TEXT Specify substitution values for configuration only. Can be provided multiple times. The pattern must be key=value or key:type=value. In that latter case, the value will be casted as the specified type. Supported types are: int, float, bytes. No type specified means a utf-8 decoded string. --var-file PATH Specify files that contain configuration and secret substitution values. Either as a json/yaml payload where each key has a value mapping to a configuration entry. Or a .env file defining environment variables. Can be provided multiple times. --hypothesis-strategy [default|before-method-only|after-method-only|during-method-only|continously] Strategy to execute the hypothesis during the run. --hypothesis-frequency FLOAT Pace at which running the hypothesis. Only applies when strategy is either: during- method-only or continously --fail-fast When running in the during-method-onlyt or continous strategies, indicate the hypothesis can fail the experiment as soon as it deviates once. Otherwise, keeps running until the end of the experiment. --help Show this message and exit. A tutorial on how to use the chaos run command is available as part of the Chaos Toolkit\u2019s Getting Started tutorials.","title":"The chaos run command"},{"location":"reference/usage/run/#executing-an-experiment-plan","text":"To execute an experiment plan you simply pass it to the chaos run command: chaos run experiment.json [2018-01-30 16:35:04 INFO] Validating experiment's syntax [2018-01-30 16:35:04 INFO] Experiment looks valid [2018-01-30 16:35:04 INFO] Running experiment: My new experiment [2018-01-30 16:35:04 INFO] No steady state hypothesis defined. That's ok, just exploring. [2018-01-30 16:35:04 INFO] Action: kill_microservice [2018-01-30 16:35:04 INFO] No steady state hypothesis defined. That's ok, just exploring. [2018-01-30 16:35:04 INFO] Let's rollback... [2018-01-30 16:35:04 INFO] No declared rollbacks, let's move on. [2018-01-30 16:35:04 INFO] Experiment ended with status: completed Chaos Toolkit will log all the steps it follows from your plan in a journal which by default is called journal.json . You can specify the name of this journal output file using the --journal-path option.","title":"Executing an Experiment Plan"},{"location":"reference/usage/run/#rehearsing-an-experiment-execution","text":"To test that you have a valid experiment you can pass the --dry option.","title":"Rehearsing an experiment execution"},{"location":"reference/usage/run/#run-an-experiment-without-validation","text":"You can run an experiment and skip the experiment\u2019s validation using the --no-validation option.","title":"Run an experiment without validation"},{"location":"reference/usage/run/#run-an-experiment-with-different-steady-state-strategies","text":"By default, the steady state will be tested before and after an experiment runs. However, you can specify a different strategy through the --hypothesis-strategy parameter. The options are: default before-method-only after-method-only during-method-only continuously For example: chaos run ./experiment.json --hypothesis-strategy continuously","title":"Run an experiment with different steady state strategies"},{"location":"reference/usage/run/#run-an-experiment-with-different-rollback-strategies","text":"In Chaos Toolkit, rollbacks are always played unless one of the two followings is true: the steady-state hypothesis deviates before the method a control interrupted the execution the chaos command receives a SIGINT or SIGTERM signal The Chaos Toolkit provides a mechanism (since v1.5.0) that gives the operator a chance to change that behavior.","title":"Run an experiment with different rollback strategies"},{"location":"reference/usage/run/#always-run-rollbacks","text":"Ensure rollbacks are always applied chaos run --rollback-strategy=always experiment.json","title":"Always run rollbacks"},{"location":"reference/usage/run/#run-rollbacks-only-on-deviation","text":"Run the rollbacks only if your experiment deviated. chaos run --rollback-strategy=deviated experiment.json","title":"Run rollbacks only on deviation"},{"location":"reference/usage/run/#never-run-rollbacks-strategy","text":"Never run any rollbacks, for instance when you want to explore the system after a successful experiment without undoing what the experiment changed: chaos run --rollback-strategy=never experiment.json","title":"Never run rollbacks strategy"},{"location":"reference/usage/run/#override-configuration-and-secrets-at-runtime","text":"While configuration and secrets are declared in the experiment itself, you may sometimes need to override the values at runtime. This can be achieved through the --var KEY[:TYPE]=VALUE or --var-file filepath.json|yaml|.env flags. The --var KEY[:TYPE]=VALUE can only override configuration values to prevent laking secrets on the command line. The KEY is the final key used in the experiment, for instance: { \"configuration\" : { \"message\" : \"hello world\" } } or { \"configuration\" : { \"message\" : { \"type\" : \"env\" , \"key\" : \"MY_MESSAGE\" } } } In both cases, the override key is message . If you specify the TYPE it must be one of str, int, float, bytes with str the default so not required. Chaos Toolkit will try to convert the given VALUE to the specified type and fail if it cannot. The --var-file filepath.json|yaml|.env gives you the opportunity to override the configuration and secrets blocks. the format of the json and yaml files are as follows: { \"configuration\" : { \"KEY\" : VALUE }, \"secrets\" : { \"scope\" : { \"KEY\" : VALUE } } } --- configuration : KEY : VALUE secrets : scope : KEY : VALUE The secrets block follows the same format as the experiment so the scope is the scope given in the experiment. For example: { \"configuration\" : { \"service_name\" : \"ec2\" }, \"secrets\" : { \"aws\" : { \"api_token\" : \"1234\" , \"something\" : \"whatever\" } } } would turn as the following var file: { \"secrets\" : { \"aws\" : { \"api_token\" : \"56787\" } } } We are not overridding the configuration section and only part of the secrets section. Finally, should you keep your variables in a .env file, it will only be able to override the configuration.","title":"Override configuration and secrets at runtime"},{"location":"reference/usage/scheduling/","text":"Scheduling your Experiments \u00b6 Scheduling is not built into the Chaos Toolkit itself. However it is common to want to run an experiment periodically when you may not be at the keyboard. In these cases we recommend using a system such as cron to schedule your experiment executions. You can also use a Kubernetes job to give you full control over the lifecycle of that job using the common Kubernetes features.","title":"Schedule"},{"location":"reference/usage/scheduling/#scheduling-your-experiments","text":"Scheduling is not built into the Chaos Toolkit itself. However it is common to want to run an experiment periodically when you may not be at the keyboard. In these cases we recommend using a system such as cron to schedule your experiment executions. You can also use a Kubernetes job to give you full control over the lifecycle of that job using the common Kubernetes features.","title":"Scheduling your Experiments"},{"location":"reference/usage/upgrade/","text":"How to Upgrade the Chaos Toolkit \u00b6 You can update your Chaos Toolkit installation by executing: pip install -U chaostoolkit","title":"Upgrade"},{"location":"reference/usage/upgrade/#how-to-upgrade-the-chaos-toolkit","text":"You can update your Chaos Toolkit installation by executing: pip install -U chaostoolkit","title":"How to Upgrade the Chaos Toolkit"},{"location":"resources/logos/","text":"Chaos Toolkit Resources: Logos \u00b6 The following resources are licensed under the CC BY 4.0 license so you can use them wherever you (presentations, web sites etc) like as long as you attribute back to the Chaos Toolkit project : Chaos Toolkit Logo Sources","title":"Logos"},{"location":"resources/logos/#chaos-toolkit-resources-logos","text":"The following resources are licensed under the CC BY 4.0 license so you can use them wherever you (presentations, web sites etc) like as long as you attribute back to the Chaos Toolkit project : Chaos Toolkit Logo Sources","title":"Chaos Toolkit Resources: Logos"},{"location":"resources/slides/","text":"Chaos Toolkit Resources: Slides \u00b6 The following is a growing collection of slides that can be used by anyone in the community when speaking about the Chaos Toolkit. These resources are licensed under the CC BY 4.0 license so you can use them wherever you like (presentations, web sites etc) as long as you attribute back to the Chaos Toolkit project : Chaos Toolkit Timeline","title":"Slides"},{"location":"resources/slides/#chaos-toolkit-resources-slides","text":"The following is a growing collection of slides that can be used by anyone in the community when speaking about the Chaos Toolkit. These resources are licensed under the CC BY 4.0 license so you can use them wherever you like (presentations, web sites etc) as long as you attribute back to the Chaos Toolkit project : Chaos Toolkit Timeline","title":"Chaos Toolkit Resources: Slides"},{"location":"shared/code/","text":"Chaos Toolkit Documentation Support Code \u00b6 Support code for the documentation . You may want to clone this repository to play with the code used in the tutorials.","title":"Chaos Toolkit Documentation Support Code"},{"location":"shared/code/#chaos-toolkit-documentation-support-code","text":"Support code for the documentation . You may want to clone this repository to play with the code used in the tutorials.","title":"Chaos Toolkit Documentation Support Code"}]}